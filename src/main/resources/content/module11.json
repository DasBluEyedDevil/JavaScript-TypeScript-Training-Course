{
  "id": "11",
  "title": "Module 11: Storing Data - Databases & Prisma ORM",
  "description": "Learn how to persist data using databases, SQL basics, and Prisma ORM for type-safe database access",
  "goal": "Understand database concepts and use Prisma ORM to store and query data in your applications",
  "lessons": [
    {
      "id": "11.1",
      "title": "What Are Databases? (The Filing Cabinet Analogy)",
      "conceptAnalogy": "Imagine storing customer information for a business:\n\nWithout a database (variables in memory):\n- Write customer data on sticky notes\n- Keep them on your desk\n- When you close the office (restart server), all notes are thrown away\n- No way to search through thousands of notes efficiently\n- Notes get lost, damaged, or mixed up\n\nWith a database (persistent storage):\n- Organized filing cabinet with labeled drawers\n- Customer files stay there even when office closes\n- Can quickly find any customer using the index\n- Multiple people can access files simultaneously\n- Backup copies exist for safety\n\nDatabases are like permanent, organized filing systems for your application's data. They persist information even when your server restarts!",
      "codeExample": "// Understanding Databases - Concept Demo\n\n// PROBLEM: In-memory storage (data is temporary)\nlet users = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' }\n];\n\nconsole.log('Users in memory:', users.length); // 2\n\n// When server restarts... POOF! Data is gone!\n// users = [];  // Lost forever!\n\n// DATABASE CONCEPTS\n\n// 1. PERSISTENCE - Data survives server restarts\nconsole.log('Database benefit: Data persists across restarts');\n\n// 2. STRUCTURED DATA - Tables with columns\n/*\n  Users Table:\n  ┌────┬────────┬──────────────────────┐\n  │ id │ name   │ email                │\n  ├────┼────────┼──────────────────────┤\n  │ 1  │ Alice  │ alice@example.com    │\n  │ 2  │ Bob    │ bob@example.com      │\n  └────┴────────┴──────────────────────┘\n*/\n\n// 3. RELATIONSHIPS - Tables can connect to each other\n/*\n  Posts Table:\n  ┌────┬────────────────┬───────────┐\n  │ id │ title          │ userId    │\n  ├────┼────────────────┼───────────┤\n  │ 1  │ First Post     │ 1 (Alice) │\n  │ 2  │ Hello World    │ 2 (Bob)   │\n  └────┴────────────────┴───────────┘\n*/\n\nconsole.log('Database benefit: Relationships between data');\n\n// 4. QUERIES - Ask questions about your data\nlet sqlExamples = [\n  'SELECT * FROM users WHERE name = \"Alice\"',\n  'SELECT * FROM posts WHERE userId = 1',\n  'SELECT users.name, posts.title FROM users JOIN posts ON users.id = posts.userId'\n];\n\nconsole.log('SQL queries let you ask complex questions:');\nsqlExamples.forEach(sql => console.log('  -', sql));\n\n// 5. TRANSACTIONS - All-or-nothing operations\nconsole.log('Database benefit: Transactions ensure data integrity');\n/*\n  Example: Transferring money\n  - Subtract $100 from Account A\n  - Add $100 to Account B\n  \n  Either BOTH happen, or NEITHER happens!\n  No lost money!\n*/\n\n// TYPES OF DATABASES\n\nlet databaseTypes = {\n  'Relational (SQL)': {\n    examples: ['PostgreSQL', 'MySQL', 'SQLite'],\n    structure: 'Tables with rows and columns',\n    uses: 'Most applications, e-commerce, banking'\n  },\n  'NoSQL (Document)': {\n    examples: ['MongoDB', 'Firestore'],\n    structure: 'JSON-like documents',\n    uses: 'Flexible schemas, real-time apps'\n  },\n  'Key-Value': {\n    examples: ['Redis', 'DynamoDB'],\n    structure: 'Simple key-value pairs',\n    uses: 'Caching, sessions, real-time'\n  }\n};\n\nconsole.log('\\nTypes of databases:');\nfor (let [type, info] of Object.entries(databaseTypes)) {\n  console.log(`${type}: ${info.examples.join(', ')}`);\n}\n\n// WHY USE A DATABASE?\nlet benefits = [\n  'Persistence: Data survives restarts',\n  'Scalability: Handle millions of records',\n  'Concurrency: Multiple users at once',\n  'Query power: Complex data searches',\n  'Data integrity: Constraints and validation',\n  'Security: Access control and encryption',\n  'Backup: Restore data if something breaks'\n];\n\nconsole.log('\\nDatabase benefits:');\nbenefits.forEach(b => console.log(`  ✓ ${b}`));",
      "syntaxBreakdown": "Database fundamentals:\n\n1. **Database Types**:\n   - **SQL (Relational)**: Structured tables, relationships, strict schema\n     * PostgreSQL (powerful, feature-rich)\n     * MySQL (popular, web apps)\n     * SQLite (simple, file-based)\n   \n   - **NoSQL**: Flexible structure, JSON-like\n     * MongoDB (document-based)\n     * Redis (key-value, caching)\n\n2. **Key Database Concepts**:\n   - **Table**: Collection of similar data (like a spreadsheet)\n   - **Row**: Individual record (one user, one post)\n   - **Column**: Property/field (name, email, age)\n   - **Primary Key**: Unique identifier (usually `id`)\n   - **Foreign Key**: Reference to another table (userId references users table)\n\n3. **SQL Basics** (Structured Query Language):\n   ```sql\n   -- Create table\n   CREATE TABLE users (\n     id INTEGER PRIMARY KEY,\n     name TEXT NOT NULL,\n     email TEXT UNIQUE\n   );\n   \n   -- Insert data\n   INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');\n   \n   -- Read data\n   SELECT * FROM users WHERE name = 'Alice';\n   \n   -- Update data\n   UPDATE users SET email = 'newemail@example.com' WHERE id = 1;\n   \n   -- Delete data\n   DELETE FROM users WHERE id = 1;\n   ```\n\n4. **CRUD Operations**:\n   - **C**reate: INSERT\n   - **R**ead: SELECT\n   - **U**pdate: UPDATE\n   - **D**elete: DELETE\n\n5. **Relationships**:\n   - **One-to-Many**: One user has many posts\n   - **Many-to-Many**: Users can follow many users, users have many followers\n   - **One-to-One**: User has one profile\n\n6. **Choosing a Database**:\n   - **PostgreSQL**: Production apps, complex queries, reliability\n   - **SQLite**: Development, simple apps, mobile apps\n   - **MongoDB**: Flexible schemas, rapid prototyping\n   - **Redis**: Caching, sessions, real-time features",
      "challenge": {
        "instructions": "Simulate a simple database system:\n\n1. Create an array called `database` to store user objects\n2. Create a function `insertUser(name, email)` that:\n   - Generates a unique ID\n   - Adds user to database\n   - Returns the new user\n3. Create a function `findUserByEmail(email)` that:\n   - Searches the database\n   - Returns the user or null\n4. Create a function `updateUserEmail(id, newEmail)` that:\n   - Finds user by ID\n   - Updates their email\n   - Returns true/false for success\n\nTest all functions.",
        "starterCode": "// Simulated database (array of objects)\nlet database = [];\nlet nextId = 1;\n\n// Function to insert a user\nfunction insertUser(name, email) {\n  let user = {\n    id: nextId++,\n    name: name,\n    email: email\n  };\n  database.push(user);\n  return user;\n}\n\n// Function to find user by email\nfunction findUserByEmail(email) {\n  return database.find(user => user.email === email) || null;\n}\n\n// Function to update user email\nfunction updateUserEmail(id, newEmail) {\n  let user = database.find(u => u.id === id);\n  if (user) {\n    user.email = newEmail;\n    return true;\n  }\n  return false;\n}\n\n// Test the functions\nlet user1 = insertUser('Alice', 'alice@example.com');\nconsole.log('Inserted:', user1);\n\nlet found = findUserByEmail('alice@example.com');\nconsole.log('Found:', found);\n\nlet updated = updateUserEmail(1, 'alice.new@example.com');\nconsole.log('Updated:', updated);\nconsole.log('Database:', database);",
        "testCases": [
          {
            "description": "Should insert user with ID",
            "input": "let db = []; let u = { id: 1, name: 'Test', email: 'test@example.com' }; db.push(u); db[0].id",
            "expectedOutput": "1"
          },
          {
            "description": "Should find user by email",
            "input": "let db = [{ id: 1, name: 'Alice', email: 'alice@example.com' }]; db.find(u => u.email === 'alice@example.com').name",
            "expectedOutput": "Alice"
          }
        ],
        "hint": "Use array methods: push() to add, find() to search, and direct property assignment to update."
      },
      "solution": "// Complete database simulation\nlet database = [];\nlet nextId = 1;\n\n// Insert user\nfunction insertUser(name, email) {\n  let user = {\n    id: nextId++,\n    name: name,\n    email: email,\n    createdAt: new Date().toISOString()\n  };\n  database.push(user);\n  console.log(`✓ Inserted user ID ${user.id}`);\n  return user;\n}\n\n// Find user by email\nfunction findUserByEmail(email) {\n  let user = database.find(u => u.email === email);\n  return user || null;\n}\n\n// Update user email\nfunction updateUserEmail(id, newEmail) {\n  let user = database.find(u => u.id === id);\n  if (user) {\n    let oldEmail = user.email;\n    user.email = newEmail;\n    console.log(`✓ Updated user ${id}: ${oldEmail} → ${newEmail}`);\n    return true;\n  }\n  console.log(`✗ User ${id} not found`);\n  return false;\n}\n\n// Delete user\nfunction deleteUser(id) {\n  let index = database.findIndex(u => u.id === id);\n  if (index !== -1) {\n    let deleted = database.splice(index, 1)[0];\n    console.log(`✓ Deleted user ${id}`);\n    return deleted;\n  }\n  return null;\n}\n\n// List all users\nfunction getAllUsers() {\n  return database;\n}\n\n// Test the database\nconsole.log('=== Database Simulation ===\\n');\n\nlet alice = insertUser('Alice', 'alice@example.com');\nlet bob = insertUser('Bob', 'bob@example.com');\nlet charlie = insertUser('Charlie', 'charlie@example.com');\n\nconsole.log('\\nAll users:', getAllUsers().length);\n\nlet found = findUserByEmail('bob@example.com');\nconsole.log('\\nFound Bob:', found ? found.name : 'Not found');\n\nupdateUserEmail(1, 'alice.new@example.com');\n\ndeleteUser(2);\n\nconsole.log('\\nFinal database:', database);",
      "commonStickingPoints": "Common database misconceptions:\n\n1. **\"Databases are too complex for beginners\"**:\n   - Start simple with SQLite or Prisma\n   - You don't need to be a DBA to use databases\n   - ORMs (like Prisma) make it much easier\n\n2. **\"I can just use variables/files instead\"**:\n   ```javascript\n   // This seems easier but...\n   let users = [];  // Lost on restart!\n   \n   // Or\n   fs.writeFileSync('users.json', JSON.stringify(users));\n   // File corruption? Race conditions? Concurrent access?\n   ```\n   Databases solve these problems professionally\n\n3. **\"All databases are the same\"**:\n   - SQL databases: Structured, relations, ACID guarantees\n   - NoSQL databases: Flexible, scalable, eventual consistency\n   - Choose based on your needs!\n\n4. **\"I need to learn raw SQL first\"**:\n   - Modern ORMs (Prisma, TypeORM) abstract SQL\n   - You can learn SQL gradually\n   - Start with ORM, understand SQL over time\n\n5. **\"Databases are slow\"**:\n   - Modern databases are EXTREMELY fast\n   - Proper indexes make queries lightning quick\n   - Can handle millions of queries per second\n\n6. **\"I don't need relationships\"**:\n   - Even simple apps benefit from relationships\n   - User → Posts → Comments (natural hierarchy)\n   - Avoids data duplication\n\n7. **\"Development database vs Production database\"**:\n   - Use SQLite for development (simple, file-based)\n   - Use PostgreSQL for production (robust, scalable)\n   - Prisma makes switching databases easy!"
    },
    {
      "id": "11.2",
      "title": "Introduction to Prisma ORM (The Translator Analogy)",
      "conceptAnalogy": "Imagine you're traveling in a foreign country:\n\nWithout a translator (raw SQL):\n- You need to learn the local language fluently\n- Every conversation requires you to form sentences carefully\n- Easy to make grammar mistakes\n- Different regions have different dialects (MySQL vs PostgreSQL)\n- Stressful and error-prone\n\nWith a translator (Prisma ORM):\n- You speak in your native language (TypeScript/JavaScript)\n- Translator converts to local language (SQL)\n- Translator knows all the dialects\n- Type-safe: Translator stops you from saying nonsense\n- Confident communication!\n\nPrisma ORM (Object-Relational Mapping) is a translator between your JavaScript code and your database. You write TypeScript, Prisma generates the SQL!",
      "codeExample": "// Prisma ORM Demonstration (Conceptual)\n// In real projects, Prisma generates TypeScript types automatically!\n\n// TRADITIONAL WAY: Raw SQL (error-prone)\nlet rawSQL = `\n  SELECT users.name, posts.title \n  FROM users \n  JOIN posts ON users.id = posts.userId \n  WHERE users.email = 'alice@example.com'\n`;\n\nconsole.log('Raw SQL (requires SQL knowledge):', rawSQL);\nconsole.log('Problems: SQL injection, typos, no type safety\\n');\n\n// PRISMA WAY: Type-safe JavaScript/TypeScript\n// (Simulated - real Prisma connects to actual database)\n\nclass PrismaClient {\n  constructor() {\n    this.user = {\n      create: async (data) => {\n        console.log('[Prisma] Creating user:', data.data);\n        return { id: 1, ...data.data, createdAt: new Date() };\n      },\n      findUnique: async (query) => {\n        console.log('[Prisma] Finding user where:', query.where);\n        return {\n          id: 1,\n          name: 'Alice',\n          email: 'alice@example.com',\n          posts: [\n            { id: 1, title: 'First Post', content: 'Hello!' }\n          ]\n        };\n      },\n      findMany: async (query) => {\n        console.log('[Prisma] Finding many users');\n        return [\n          { id: 1, name: 'Alice', email: 'alice@example.com' },\n          { id: 2, name: 'Bob', email: 'bob@example.com' }\n        ];\n      },\n      update: async (query) => {\n        console.log('[Prisma] Updating user:', query.where, 'with:', query.data);\n        return { id: 1, ...query.data };\n      },\n      delete: async (query) => {\n        console.log('[Prisma] Deleting user:', query.where);\n        return { id: 1, name: 'Alice' };\n      }\n    };\n    \n    this.post = {\n      create: async (data) => {\n        console.log('[Prisma] Creating post:', data.data);\n        return { id: 1, ...data.data };\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// PRISMA EXAMPLES (async/await pattern)\n\n// 1. CREATE a user\nasync function createUser() {\n  let user = await prisma.user.create({\n    data: {\n      name: 'Alice',\n      email: 'alice@example.com'\n    }\n  });\n  console.log('Created user:', user);\n  return user;\n}\n\n// 2. FIND a user by email\nasync function findUser() {\n  let user = await prisma.user.findUnique({\n    where: {\n      email: 'alice@example.com'\n    },\n    include: {\n      posts: true  // Include related posts!\n    }\n  });\n  console.log('Found user with posts:', user);\n  return user;\n}\n\n// 3. UPDATE a user\nasync function updateUser() {\n  let user = await prisma.user.update({\n    where: { id: 1 },\n    data: {\n      name: 'Alice Smith'\n    }\n  });\n  console.log('Updated user:', user);\n  return user;\n}\n\n// 4. DELETE a user\nasync function deleteUser() {\n  let user = await prisma.user.delete({\n    where: { id: 1 }\n  });\n  console.log('Deleted user:', user);\n  return user;\n}\n\n// 5. LIST all users\nasync function listUsers() {\n  let users = await prisma.user.findMany();\n  console.log('All users:', users);\n  return users;\n}\n\n// Run examples\nconsole.log('=== Prisma ORM Examples ===\\n');\n\ncreateUser();\nsetTimeout(() => findUser(), 100);\nsetTimeout(() => updateUser(), 200);\nsetTimeout(() => listUsers(), 300);\n\n// PRISMA BENEFITS\nconsole.log('\\n=== Prisma Benefits ===');\nlet benefits = [\n  '✓ Type-safe database queries (TypeScript)',\n  '✓ Auto-generated types from schema',\n  '✓ Database agnostic (PostgreSQL, MySQL, SQLite, etc.)',\n  '✓ Intuitive API (JavaScript objects, not SQL strings)',\n  '✓ Migrations built-in',\n  '✓ Prisma Studio (database GUI)',\n  '✓ Query builder prevents SQL injection',\n  '✓ Excellent autocomplete in IDE'\n];\n\nbenefits.forEach(b => console.log(b));",
      "syntaxBreakdown": "Understanding Prisma ORM:\n\n1. **What is Prisma?**\n   - Modern ORM (Object-Relational Mapping)\n   - Translates TypeScript ↔ SQL\n   - Type-safe database client\n   - Works with PostgreSQL, MySQL, SQLite, MongoDB, etc.\n\n2. **Prisma Setup** (typical workflow):\n   ```bash\n   # Install Prisma\n   npm install prisma --save-dev\n   npm install @prisma/client\n   \n   # Initialize Prisma\n   npx prisma init\n   \n   # This creates:\n   # - prisma/schema.prisma (database schema)\n   # - .env (database connection string)\n   ```\n\n3. **Prisma Schema** (schema.prisma):\n   ```prisma\n   model User {\n     id        Int      @id @default(autoincrement())\n     email     String   @unique\n     name      String\n     posts     Post[]\n     createdAt DateTime @default(now())\n   }\n   \n   model Post {\n     id        Int      @id @default(autoincrement())\n     title     String\n     content   String?\n     published Boolean  @default(false)\n     userId    Int\n     user      User     @relation(fields: [userId], references: [id])\n   }\n   ```\n\n4. **Prisma Client Usage**:\n   ```typescript\n   import { PrismaClient } from '@prisma/client';\n   const prisma = new PrismaClient();\n   \n   // All your database operations...\n   ```\n\n5. **CRUD Operations**:\n   - **Create**: `prisma.user.create({ data: {...} })`\n   - **Read**: `prisma.user.findUnique({ where: {...} })`\n   - **Update**: `prisma.user.update({ where: {...}, data: {...} })`\n   - **Delete**: `prisma.user.delete({ where: {...} })`\n\n6. **Relationships**:\n   ```typescript\n   // Get user with all their posts\n   const userWithPosts = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: { posts: true }\n   });\n   ```\n\n7. **Migrations** (database schema changes):\n   ```bash\n   # Create migration\n   npx prisma migrate dev --name add_users_table\n   \n   # Apply migrations to production\n   npx prisma migrate deploy\n   ```\n\n8. **Prisma Studio** (database GUI):\n   ```bash\n   npx prisma studio\n   # Opens visual database editor in browser\n   ```",
      "challenge": {
        "instructions": "Simulate Prisma-style database operations:\n\n1. Create a mock Prisma client class with a `book` property\n2. Implement these methods on the `book` object:\n   - `create(data)` - Returns new book with generated ID\n   - `findMany()` - Returns all books array\n   - `findUnique(where)` - Finds book by ID\n   - `update(where, data)` - Updates book and returns it\n\n3. Create a books array to store data\n4. Test all CRUD operations\n\nMake it feel like Prisma's API!",
        "starterCode": "// Mock Prisma client\nclass PrismaClient {\n  constructor() {\n    this.booksData = [];\n    this.nextId = 1;\n    \n    this.book = {\n      create: async (options) => {\n        let book = {\n          id: this.nextId++,\n          ...options.data\n        };\n        this.booksData.push(book);\n        return book;\n      },\n      \n      findMany: async () => {\n        return this.booksData;\n      },\n      \n      findUnique: async (options) => {\n        return this.booksData.find(b => b.id === options.where.id) || null;\n      },\n      \n      update: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        if (book) {\n          Object.assign(book, options.data);\n          return book;\n        }\n        return null;\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// Test CRUD operations\nasync function testPrisma() {\n  // Create\n  let book1 = await prisma.book.create({\n    data: { title: '1984', author: 'George Orwell', pages: 328 }\n  });\n  console.log('Created:', book1);\n  \n  // Find all\n  let books = await prisma.book.findMany();\n  console.log('All books:', books);\n  \n  // Find one\n  let found = await prisma.book.findUnique({ where: { id: 1 } });\n  console.log('Found:', found);\n  \n  // Update\n  let updated = await prisma.book.update({\n    where: { id: 1 },\n    data: { pages: 330 }\n  });\n  console.log('Updated:', updated);\n}\n\ntestPrisma();",
        "testCases": [
          {
            "description": "Should create book with generated ID",
            "input": "let books = []; let book = { id: 1, title: 'Test' }; books.push(book); books[0].id",
            "expectedOutput": "1"
          },
          {
            "description": "Should find book by id",
            "input": "let books = [{ id: 1, title: 'Test' }]; books.find(b => b.id === 1).title",
            "expectedOutput": "Test"
          }
        ],
        "hint": "Use async functions and make methods return promises. Store books in an array."
      },
      "solution": "// Complete Prisma-style mock client\nclass PrismaClient {\n  constructor() {\n    this.booksData = [];\n    this.nextId = 1;\n    \n    this.book = {\n      create: async (options) => {\n        let book = {\n          id: this.nextId++,\n          ...options.data,\n          createdAt: new Date()\n        };\n        this.booksData.push(book);\n        console.log(`✓ Created book ID ${book.id}`);\n        return book;\n      },\n      \n      findMany: async (options = {}) => {\n        let books = this.booksData;\n        \n        // Filter if where clause provided\n        if (options.where) {\n          books = books.filter(book => {\n            return Object.entries(options.where).every(([key, value]) => {\n              return book[key] === value;\n            });\n          });\n        }\n        \n        return books;\n      },\n      \n      findUnique: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        return book || null;\n      },\n      \n      update: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        if (book) {\n          Object.assign(book, options.data);\n          book.updatedAt = new Date();\n          console.log(`✓ Updated book ID ${book.id}`);\n          return book;\n        }\n        throw new Error(`Book with ID ${options.where.id} not found`);\n      },\n      \n      delete: async (options) => {\n        let index = this.booksData.findIndex(b => b.id === options.where.id);\n        if (index !== -1) {\n          let deleted = this.booksData.splice(index, 1)[0];\n          console.log(`✓ Deleted book ID ${deleted.id}`);\n          return deleted;\n        }\n        throw new Error(`Book with ID ${options.where.id} not found`);\n      },\n      \n      count: async () => {\n        return this.booksData.length;\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// Comprehensive test\nasync function testPrisma() {\n  console.log('=== Prisma-Style ORM Demo ===\\n');\n  \n  // Create books\n  await prisma.book.create({\n    data: { title: '1984', author: 'George Orwell', pages: 328 }\n  });\n  \n  await prisma.book.create({\n    data: { title: 'The Great Gatsby', author: 'F. Scott Fitzgerald', pages: 180 }\n  });\n  \n  // Find all\n  let allBooks = await prisma.book.findMany();\n  console.log('\\nAll books:', allBooks.length);\n  \n  // Find specific\n  let book = await prisma.book.findUnique({ where: { id: 1 } });\n  console.log('\\nFound book:', book.title);\n  \n  // Update\n  await prisma.book.update({\n    where: { id: 1 },\n    data: { pages: 330 }\n  });\n  \n  // Count\n  let count = await prisma.book.count();\n  console.log('\\nTotal books:', count);\n  \n  // Delete\n  await prisma.book.delete({ where: { id: 2 } });\n  \n  // Final state\n  let remaining = await prisma.book.findMany();\n  console.log('\\nRemaining books:', remaining);\n}\n\ntestPrisma();",
      "commonStickingPoints": "Common Prisma mistakes:\n\n1. **Forgetting async/await**:\n   ```typescript\n   // Wrong!\n   let user = prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // ERROR: user is a Promise!\n   \n   // Correct!\n   let user = await prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // Works!\n   ```\n\n2. **Not running migrations**:\n   - After changing schema.prisma, run: `npx prisma migrate dev`\n   - Then: `npx prisma generate` to update TypeScript types\n   - Without this, your code won't match the database!\n\n3. **Prisma Client not initialized**:\n   ```typescript\n   // Create once, reuse everywhere\n   // prisma/client.ts\n   import { PrismaClient } from '@prisma/client';\n   export const prisma = new PrismaClient();\n   \n   // other files\n   import { prisma } from './prisma/client';\n   ```\n\n4. **Not handling null results**:\n   ```typescript\n   let user = await prisma.user.findUnique({ where: { id: 999 } });\n   console.log(user.name); // ERROR if user is null!\n   \n   // Better:\n   if (!user) {\n     throw new Error('User not found');\n   }\n   console.log(user.name);\n   ```\n\n5. **Forgetting to connect/disconnect**:\n   ```typescript\n   // Usually not needed in serverless\n   // But for long-running servers:\n   await prisma.$connect();\n   // ... use prisma ...\n   await prisma.$disconnect();\n   ```\n\n6. **Schema syntax errors**:\n   ```prisma\n   // Wrong!\n   model User {\n     id Int @id\n     name String\n     // Missing newline before }\n   }\n   \n   // Correct!\n   model User {\n     id   Int    @id @default(autoincrement())\n     name String\n   }\n   ```\n\n7. **Not using Prisma Studio**:\n   - Run `npx prisma studio` to see your data visually\n   - Great for debugging and understanding your database\n   - Much easier than writing SELECT queries!"
    }
  ]
}
