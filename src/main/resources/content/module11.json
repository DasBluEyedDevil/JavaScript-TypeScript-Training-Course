{
  "id": "11",
  "title": "Module 11: Storing Data - Databases & Prisma ORM",
  "description": "Learn how to persist data using databases, SQL basics, and Prisma ORM for type-safe database access",
  "goal": "Understand database concepts and use Prisma ORM to store and query data in your applications",
  "lessons": [
    {
      "id": "11.1",
      "title": "What Are Databases? (The Filing Cabinet Analogy)",
      "conceptAnalogy": "Imagine storing customer information for a business:\n\nWithout a database (variables in memory):\n- Write customer data on sticky notes\n- Keep them on your desk\n- When you close the office (restart server), all notes are thrown away\n- No way to search through thousands of notes efficiently\n- Notes get lost, damaged, or mixed up\n\nWith a database (persistent storage):\n- Organized filing cabinet with labeled drawers\n- Customer files stay there even when office closes\n- Can quickly find any customer using the index\n- Multiple people can access files simultaneously\n- Backup copies exist for safety\n\nDatabases are like permanent, organized filing systems for your application's data. They persist information even when your server restarts!",
      "codeExample": "// Understanding Databases - Concept Demo\n\n// PROBLEM: In-memory storage (data is temporary)\nlet users = [\n  { id: 1, name: 'Alice', email: 'alice@example.com' },\n  { id: 2, name: 'Bob', email: 'bob@example.com' }\n];\n\nconsole.log('Users in memory:', users.length); // 2\n\n// When server restarts... POOF! Data is gone!\n// users = [];  // Lost forever!\n\n// DATABASE CONCEPTS\n\n// 1. PERSISTENCE - Data survives server restarts\nconsole.log('Database benefit: Data persists across restarts');\n\n// 2. STRUCTURED DATA - Tables with columns\n/*\n  Users Table:\n  ┌────┬────────┬──────────────────────┐\n  │ id │ name   │ email                │\n  ├────┼────────┼──────────────────────┤\n  │ 1  │ Alice  │ alice@example.com    │\n  │ 2  │ Bob    │ bob@example.com      │\n  └────┴────────┴──────────────────────┘\n*/\n\n// 3. RELATIONSHIPS - Tables can connect to each other\n/*\n  Posts Table:\n  ┌────┬────────────────┬───────────┐\n  │ id │ title          │ userId    │\n  ├────┼────────────────┼───────────┤\n  │ 1  │ First Post     │ 1 (Alice) │\n  │ 2  │ Hello World    │ 2 (Bob)   │\n  └────┴────────────────┴───────────┘\n*/\n\nconsole.log('Database benefit: Relationships between data');\n\n// 4. QUERIES - Ask questions about your data\nlet sqlExamples = [\n  'SELECT * FROM users WHERE name = \"Alice\"',\n  'SELECT * FROM posts WHERE userId = 1',\n  'SELECT users.name, posts.title FROM users JOIN posts ON users.id = posts.userId'\n];\n\nconsole.log('SQL queries let you ask complex questions:');\nsqlExamples.forEach(sql => console.log('  -', sql));\n\n// 5. TRANSACTIONS - All-or-nothing operations\nconsole.log('Database benefit: Transactions ensure data integrity');\n/*\n  Example: Transferring money\n  - Subtract $100 from Account A\n  - Add $100 to Account B\n  \n  Either BOTH happen, or NEITHER happens!\n  No lost money!\n*/\n\n// TYPES OF DATABASES\n\nlet databaseTypes = {\n  'Relational (SQL)': {\n    examples: ['PostgreSQL', 'MySQL', 'SQLite'],\n    structure: 'Tables with rows and columns',\n    uses: 'Most applications, e-commerce, banking'\n  },\n  'NoSQL (Document)': {\n    examples: ['MongoDB', 'Firestore'],\n    structure: 'JSON-like documents',\n    uses: 'Flexible schemas, real-time apps'\n  },\n  'Key-Value': {\n    examples: ['Redis', 'DynamoDB'],\n    structure: 'Simple key-value pairs',\n    uses: 'Caching, sessions, real-time'\n  }\n};\n\nconsole.log('\\nTypes of databases:');\nfor (let [type, info] of Object.entries(databaseTypes)) {\n  console.log(`${type}: ${info.examples.join(', ')}`);\n}\n\n// WHY USE A DATABASE?\nlet benefits = [\n  'Persistence: Data survives restarts',\n  'Scalability: Handle millions of records',\n  'Concurrency: Multiple users at once',\n  'Query power: Complex data searches',\n  'Data integrity: Constraints and validation',\n  'Security: Access control and encryption',\n  'Backup: Restore data if something breaks'\n];\n\nconsole.log('\\nDatabase benefits:');\nbenefits.forEach(b => console.log(`  ✓ ${b}`));",
      "syntaxBreakdown": "Database fundamentals:\n\n1. **Database Types**:\n   - **SQL (Relational)**: Structured tables, relationships, strict schema\n     * PostgreSQL (powerful, feature-rich)\n     * MySQL (popular, web apps)\n     * SQLite (simple, file-based)\n   \n   - **NoSQL**: Flexible structure, JSON-like\n     * MongoDB (document-based)\n     * Redis (key-value, caching)\n\n2. **Key Database Concepts**:\n   - **Table**: Collection of similar data (like a spreadsheet)\n   - **Row**: Individual record (one user, one post)\n   - **Column**: Property/field (name, email, age)\n   - **Primary Key**: Unique identifier (usually `id`)\n   - **Foreign Key**: Reference to another table (userId references users table)\n\n3. **SQL Basics** (Structured Query Language):\n   ```sql\n   -- Create table\n   CREATE TABLE users (\n     id INTEGER PRIMARY KEY,\n     name TEXT NOT NULL,\n     email TEXT UNIQUE\n   );\n   \n   -- Insert data\n   INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');\n   \n   -- Read data\n   SELECT * FROM users WHERE name = 'Alice';\n   \n   -- Update data\n   UPDATE users SET email = 'newemail@example.com' WHERE id = 1;\n   \n   -- Delete data\n   DELETE FROM users WHERE id = 1;\n   ```\n\n4. **CRUD Operations**:\n   - **C**reate: INSERT\n   - **R**ead: SELECT\n   - **U**pdate: UPDATE\n   - **D**elete: DELETE\n\n5. **Relationships**:\n   - **One-to-Many**: One user has many posts\n   - **Many-to-Many**: Users can follow many users, users have many followers\n   - **One-to-One**: User has one profile\n\n6. **Choosing a Database**:\n   - **PostgreSQL**: Production apps, complex queries, reliability\n   - **SQLite**: Development, simple apps, mobile apps\n   - **MongoDB**: Flexible schemas, rapid prototyping\n   - **Redis**: Caching, sessions, real-time features",
      "challenge": {
        "instructions": "Simulate a simple database system:\n\n1. Create an array called `database` to store user objects\n2. Create a function `insertUser(name, email)` that:\n   - Generates a unique ID\n   - Adds user to database\n   - Returns the new user\n3. Create a function `findUserByEmail(email)` that:\n   - Searches the database\n   - Returns the user or null\n4. Create a function `updateUserEmail(id, newEmail)` that:\n   - Finds user by ID\n   - Updates their email\n   - Returns true/false for success\n\nTest all functions.",
        "starterCode": "// Simulated database (array of objects)\nlet database = [];\nlet nextId = 1;\n\n// Function to insert a user\nfunction insertUser(name, email) {\n  let user = {\n    id: nextId++,\n    name: name,\n    email: email\n  };\n  database.push(user);\n  return user;\n}\n\n// Function to find user by email\nfunction findUserByEmail(email) {\n  return database.find(user => user.email === email) || null;\n}\n\n// Function to update user email\nfunction updateUserEmail(id, newEmail) {\n  let user = database.find(u => u.id === id);\n  if (user) {\n    user.email = newEmail;\n    return true;\n  }\n  return false;\n}\n\n// Test the functions\nlet user1 = insertUser('Alice', 'alice@example.com');\nconsole.log('Inserted:', user1);\n\nlet found = findUserByEmail('alice@example.com');\nconsole.log('Found:', found);\n\nlet updated = updateUserEmail(1, 'alice.new@example.com');\nconsole.log('Updated:', updated);\nconsole.log('Database:', database);",
        "testCases": [
          {
            "description": "Should insert user with ID",
            "input": "let db = []; let u = { id: 1, name: 'Test', email: 'test@example.com' }; db.push(u); db[0].id",
            "expectedOutput": "1"
          },
          {
            "description": "Should find user by email",
            "input": "let db = [{ id: 1, name: 'Alice', email: 'alice@example.com' }]; db.find(u => u.email === 'alice@example.com').name",
            "expectedOutput": "Alice"
          }
        ],
        "hint": "Use array methods: push() to add, find() to search, and direct property assignment to update."
      },
      "solution": "// Complete database simulation\nlet database = [];\nlet nextId = 1;\n\n// Insert user\nfunction insertUser(name, email) {\n  let user = {\n    id: nextId++,\n    name: name,\n    email: email,\n    createdAt: new Date().toISOString()\n  };\n  database.push(user);\n  console.log(`✓ Inserted user ID ${user.id}`);\n  return user;\n}\n\n// Find user by email\nfunction findUserByEmail(email) {\n  let user = database.find(u => u.email === email);\n  return user || null;\n}\n\n// Update user email\nfunction updateUserEmail(id, newEmail) {\n  let user = database.find(u => u.id === id);\n  if (user) {\n    let oldEmail = user.email;\n    user.email = newEmail;\n    console.log(`✓ Updated user ${id}: ${oldEmail} → ${newEmail}`);\n    return true;\n  }\n  console.log(`✗ User ${id} not found`);\n  return false;\n}\n\n// Delete user\nfunction deleteUser(id) {\n  let index = database.findIndex(u => u.id === id);\n  if (index !== -1) {\n    let deleted = database.splice(index, 1)[0];\n    console.log(`✓ Deleted user ${id}`);\n    return deleted;\n  }\n  return null;\n}\n\n// List all users\nfunction getAllUsers() {\n  return database;\n}\n\n// Test the database\nconsole.log('=== Database Simulation ===\\n');\n\nlet alice = insertUser('Alice', 'alice@example.com');\nlet bob = insertUser('Bob', 'bob@example.com');\nlet charlie = insertUser('Charlie', 'charlie@example.com');\n\nconsole.log('\\nAll users:', getAllUsers().length);\n\nlet found = findUserByEmail('bob@example.com');\nconsole.log('\\nFound Bob:', found ? found.name : 'Not found');\n\nupdateUserEmail(1, 'alice.new@example.com');\n\ndeleteUser(2);\n\nconsole.log('\\nFinal database:', database);",
      "commonStickingPoints": "Common database misconceptions:\n\n1. **\"Databases are too complex for beginners\"**:\n   - Start simple with SQLite or Prisma\n   - You don't need to be a DBA to use databases\n   - ORMs (like Prisma) make it much easier\n\n2. **\"I can just use variables/files instead\"**:\n   ```javascript\n   // This seems easier but...\n   let users = [];  // Lost on restart!\n   \n   // Or\n   fs.writeFileSync('users.json', JSON.stringify(users));\n   // File corruption? Race conditions? Concurrent access?\n   ```\n   Databases solve these problems professionally\n\n3. **\"All databases are the same\"**:\n   - SQL databases: Structured, relations, ACID guarantees\n   - NoSQL databases: Flexible, scalable, eventual consistency\n   - Choose based on your needs!\n\n4. **\"I need to learn raw SQL first\"**:\n   - Modern ORMs (Prisma, TypeORM) abstract SQL\n   - You can learn SQL gradually\n   - Start with ORM, understand SQL over time\n\n5. **\"Databases are slow\"**:\n   - Modern databases are EXTREMELY fast\n   - Proper indexes make queries lightning quick\n   - Can handle millions of queries per second\n\n6. **\"I don't need relationships\"**:\n   - Even simple apps benefit from relationships\n   - User → Posts → Comments (natural hierarchy)\n   - Avoids data duplication\n\n7. **\"Development database vs Production database\"**:\n   - Use SQLite for development (simple, file-based)\n   - Use PostgreSQL for production (robust, scalable)\n   - Prisma makes switching databases easy!"
    },
    {
      "id": "11.2",
      "title": "Introduction to Prisma ORM (The Translator Analogy)",
      "conceptAnalogy": "Imagine you're traveling in a foreign country:\n\nWithout a translator (raw SQL):\n- You need to learn the local language fluently\n- Every conversation requires you to form sentences carefully\n- Easy to make grammar mistakes\n- Different regions have different dialects (MySQL vs PostgreSQL)\n- Stressful and error-prone\n\nWith a translator (Prisma ORM):\n- You speak in your native language (TypeScript/JavaScript)\n- Translator converts to local language (SQL)\n- Translator knows all the dialects\n- Type-safe: Translator stops you from saying nonsense\n- Confident communication!\n\nPrisma ORM (Object-Relational Mapping) is a translator between your JavaScript code and your database. You write TypeScript, Prisma generates the SQL!",
      "codeExample": "// Prisma ORM Demonstration (Conceptual)\n// In real projects, Prisma generates TypeScript types automatically!\n\n// TRADITIONAL WAY: Raw SQL (error-prone)\nlet rawSQL = `\n  SELECT users.name, posts.title \n  FROM users \n  JOIN posts ON users.id = posts.userId \n  WHERE users.email = 'alice@example.com'\n`;\n\nconsole.log('Raw SQL (requires SQL knowledge):', rawSQL);\nconsole.log('Problems: SQL injection, typos, no type safety\\n');\n\n// PRISMA WAY: Type-safe JavaScript/TypeScript\n// (Simulated - real Prisma connects to actual database)\n\nclass PrismaClient {\n  constructor() {\n    this.user = {\n      create: async (data) => {\n        console.log('[Prisma] Creating user:', data.data);\n        return { id: 1, ...data.data, createdAt: new Date() };\n      },\n      findUnique: async (query) => {\n        console.log('[Prisma] Finding user where:', query.where);\n        return {\n          id: 1,\n          name: 'Alice',\n          email: 'alice@example.com',\n          posts: [\n            { id: 1, title: 'First Post', content: 'Hello!' }\n          ]\n        };\n      },\n      findMany: async (query) => {\n        console.log('[Prisma] Finding many users');\n        return [\n          { id: 1, name: 'Alice', email: 'alice@example.com' },\n          { id: 2, name: 'Bob', email: 'bob@example.com' }\n        ];\n      },\n      update: async (query) => {\n        console.log('[Prisma] Updating user:', query.where, 'with:', query.data);\n        return { id: 1, ...query.data };\n      },\n      delete: async (query) => {\n        console.log('[Prisma] Deleting user:', query.where);\n        return { id: 1, name: 'Alice' };\n      }\n    };\n    \n    this.post = {\n      create: async (data) => {\n        console.log('[Prisma] Creating post:', data.data);\n        return { id: 1, ...data.data };\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// PRISMA EXAMPLES (async/await pattern)\n\n// 1. CREATE a user\nasync function createUser() {\n  let user = await prisma.user.create({\n    data: {\n      name: 'Alice',\n      email: 'alice@example.com'\n    }\n  });\n  console.log('Created user:', user);\n  return user;\n}\n\n// 2. FIND a user by email\nasync function findUser() {\n  let user = await prisma.user.findUnique({\n    where: {\n      email: 'alice@example.com'\n    },\n    include: {\n      posts: true  // Include related posts!\n    }\n  });\n  console.log('Found user with posts:', user);\n  return user;\n}\n\n// 3. UPDATE a user\nasync function updateUser() {\n  let user = await prisma.user.update({\n    where: { id: 1 },\n    data: {\n      name: 'Alice Smith'\n    }\n  });\n  console.log('Updated user:', user);\n  return user;\n}\n\n// 4. DELETE a user\nasync function deleteUser() {\n  let user = await prisma.user.delete({\n    where: { id: 1 }\n  });\n  console.log('Deleted user:', user);\n  return user;\n}\n\n// 5. LIST all users\nasync function listUsers() {\n  let users = await prisma.user.findMany();\n  console.log('All users:', users);\n  return users;\n}\n\n// Run examples\nconsole.log('=== Prisma ORM Examples ===\\n');\n\ncreateUser();\nsetTimeout(() => findUser(), 100);\nsetTimeout(() => updateUser(), 200);\nsetTimeout(() => listUsers(), 300);\n\n// PRISMA BENEFITS\nconsole.log('\\n=== Prisma Benefits ===');\nlet benefits = [\n  '✓ Type-safe database queries (TypeScript)',\n  '✓ Auto-generated types from schema',\n  '✓ Database agnostic (PostgreSQL, MySQL, SQLite, etc.)',\n  '✓ Intuitive API (JavaScript objects, not SQL strings)',\n  '✓ Migrations built-in',\n  '✓ Prisma Studio (database GUI)',\n  '✓ Query builder prevents SQL injection',\n  '✓ Excellent autocomplete in IDE'\n];\n\nbenefits.forEach(b => console.log(b));",
      "syntaxBreakdown": "Understanding Prisma ORM:\n\n1. **What is Prisma?**\n   - Modern ORM (Object-Relational Mapping)\n   - Translates TypeScript ↔ SQL\n   - Type-safe database client\n   - Works with PostgreSQL, MySQL, SQLite, MongoDB, etc.\n\n2. **Prisma Setup** (typical workflow):\n   ```bash\n   # Install Prisma\n   npm install prisma --save-dev\n   npm install @prisma/client\n   \n   # Initialize Prisma\n   npx prisma init\n   \n   # This creates:\n   # - prisma/schema.prisma (database schema)\n   # - .env (database connection string)\n   ```\n\n3. **Prisma Schema** (schema.prisma):\n   ```prisma\n   model User {\n     id        Int      @id @default(autoincrement())\n     email     String   @unique\n     name      String\n     posts     Post[]\n     createdAt DateTime @default(now())\n   }\n   \n   model Post {\n     id        Int      @id @default(autoincrement())\n     title     String\n     content   String?\n     published Boolean  @default(false)\n     userId    Int\n     user      User     @relation(fields: [userId], references: [id])\n   }\n   ```\n\n4. **Prisma Client Usage**:\n   ```typescript\n   import { PrismaClient } from '@prisma/client';\n   const prisma = new PrismaClient();\n   \n   // All your database operations...\n   ```\n\n5. **CRUD Operations**:\n   - **Create**: `prisma.user.create({ data: {...} })`\n   - **Read**: `prisma.user.findUnique({ where: {...} })`\n   - **Update**: `prisma.user.update({ where: {...}, data: {...} })`\n   - **Delete**: `prisma.user.delete({ where: {...} })`\n\n6. **Relationships**:\n   ```typescript\n   // Get user with all their posts\n   const userWithPosts = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: { posts: true }\n   });\n   ```\n\n7. **Migrations** (database schema changes):\n   ```bash\n   # Create migration\n   npx prisma migrate dev --name add_users_table\n   \n   # Apply migrations to production\n   npx prisma migrate deploy\n   ```\n\n8. **Prisma Studio** (database GUI):\n   ```bash\n   npx prisma studio\n   # Opens visual database editor in browser\n   ```",
      "challenge": {
        "instructions": "Simulate Prisma-style database operations:\n\n1. Create a mock Prisma client class with a `book` property\n2. Implement these methods on the `book` object:\n   - `create(data)` - Returns new book with generated ID\n   - `findMany()` - Returns all books array\n   - `findUnique(where)` - Finds book by ID\n   - `update(where, data)` - Updates book and returns it\n\n3. Create a books array to store data\n4. Test all CRUD operations\n\nMake it feel like Prisma's API!",
        "starterCode": "// Mock Prisma client\nclass PrismaClient {\n  constructor() {\n    this.booksData = [];\n    this.nextId = 1;\n    \n    this.book = {\n      create: async (options) => {\n        let book = {\n          id: this.nextId++,\n          ...options.data\n        };\n        this.booksData.push(book);\n        return book;\n      },\n      \n      findMany: async () => {\n        return this.booksData;\n      },\n      \n      findUnique: async (options) => {\n        return this.booksData.find(b => b.id === options.where.id) || null;\n      },\n      \n      update: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        if (book) {\n          Object.assign(book, options.data);\n          return book;\n        }\n        return null;\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// Test CRUD operations\nasync function testPrisma() {\n  // Create\n  let book1 = await prisma.book.create({\n    data: { title: '1984', author: 'George Orwell', pages: 328 }\n  });\n  console.log('Created:', book1);\n  \n  // Find all\n  let books = await prisma.book.findMany();\n  console.log('All books:', books);\n  \n  // Find one\n  let found = await prisma.book.findUnique({ where: { id: 1 } });\n  console.log('Found:', found);\n  \n  // Update\n  let updated = await prisma.book.update({\n    where: { id: 1 },\n    data: { pages: 330 }\n  });\n  console.log('Updated:', updated);\n}\n\ntestPrisma();",
        "testCases": [
          {
            "description": "Should create book with generated ID",
            "input": "let books = []; let book = { id: 1, title: 'Test' }; books.push(book); books[0].id",
            "expectedOutput": "1"
          },
          {
            "description": "Should find book by id",
            "input": "let books = [{ id: 1, title: 'Test' }]; books.find(b => b.id === 1).title",
            "expectedOutput": "Test"
          }
        ],
        "hint": "Use async functions and make methods return promises. Store books in an array."
      },
      "solution": "// Complete Prisma-style mock client\nclass PrismaClient {\n  constructor() {\n    this.booksData = [];\n    this.nextId = 1;\n    \n    this.book = {\n      create: async (options) => {\n        let book = {\n          id: this.nextId++,\n          ...options.data,\n          createdAt: new Date()\n        };\n        this.booksData.push(book);\n        console.log(`✓ Created book ID ${book.id}`);\n        return book;\n      },\n      \n      findMany: async (options = {}) => {\n        let books = this.booksData;\n        \n        // Filter if where clause provided\n        if (options.where) {\n          books = books.filter(book => {\n            return Object.entries(options.where).every(([key, value]) => {\n              return book[key] === value;\n            });\n          });\n        }\n        \n        return books;\n      },\n      \n      findUnique: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        return book || null;\n      },\n      \n      update: async (options) => {\n        let book = this.booksData.find(b => b.id === options.where.id);\n        if (book) {\n          Object.assign(book, options.data);\n          book.updatedAt = new Date();\n          console.log(`✓ Updated book ID ${book.id}`);\n          return book;\n        }\n        throw new Error(`Book with ID ${options.where.id} not found`);\n      },\n      \n      delete: async (options) => {\n        let index = this.booksData.findIndex(b => b.id === options.where.id);\n        if (index !== -1) {\n          let deleted = this.booksData.splice(index, 1)[0];\n          console.log(`✓ Deleted book ID ${deleted.id}`);\n          return deleted;\n        }\n        throw new Error(`Book with ID ${options.where.id} not found`);\n      },\n      \n      count: async () => {\n        return this.booksData.length;\n      }\n    };\n  }\n}\n\nlet prisma = new PrismaClient();\n\n// Comprehensive test\nasync function testPrisma() {\n  console.log('=== Prisma-Style ORM Demo ===\\n');\n  \n  // Create books\n  await prisma.book.create({\n    data: { title: '1984', author: 'George Orwell', pages: 328 }\n  });\n  \n  await prisma.book.create({\n    data: { title: 'The Great Gatsby', author: 'F. Scott Fitzgerald', pages: 180 }\n  });\n  \n  // Find all\n  let allBooks = await prisma.book.findMany();\n  console.log('\\nAll books:', allBooks.length);\n  \n  // Find specific\n  let book = await prisma.book.findUnique({ where: { id: 1 } });\n  console.log('\\nFound book:', book.title);\n  \n  // Update\n  await prisma.book.update({\n    where: { id: 1 },\n    data: { pages: 330 }\n  });\n  \n  // Count\n  let count = await prisma.book.count();\n  console.log('\\nTotal books:', count);\n  \n  // Delete\n  await prisma.book.delete({ where: { id: 2 } });\n  \n  // Final state\n  let remaining = await prisma.book.findMany();\n  console.log('\\nRemaining books:', remaining);\n}\n\ntestPrisma();",
      "commonStickingPoints": "Common Prisma mistakes:\n\n1. **Forgetting async/await**:\n   ```typescript\n   // Wrong!\n   let user = prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // ERROR: user is a Promise!\n   \n   // Correct!\n   let user = await prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.name); // Works!\n   ```\n\n2. **Not running migrations**:\n   - After changing schema.prisma, run: `npx prisma migrate dev`\n   - Then: `npx prisma generate` to update TypeScript types\n   - Without this, your code won't match the database!\n\n3. **Prisma Client not initialized**:\n   ```typescript\n   // Create once, reuse everywhere\n   // prisma/client.ts\n   import { PrismaClient } from '@prisma/client';\n   export const prisma = new PrismaClient();\n   \n   // other files\n   import { prisma } from './prisma/client';\n   ```\n\n4. **Not handling null results**:\n   ```typescript\n   let user = await prisma.user.findUnique({ where: { id: 999 } });\n   console.log(user.name); // ERROR if user is null!\n   \n   // Better:\n   if (!user) {\n     throw new Error('User not found');\n   }\n   console.log(user.name);\n   ```\n\n5. **Forgetting to connect/disconnect**:\n   ```typescript\n   // Usually not needed in serverless\n   // But for long-running servers:\n   await prisma.$connect();\n   // ... use prisma ...\n   await prisma.$disconnect();\n   ```\n\n6. **Schema syntax errors**:\n   ```prisma\n   // Wrong!\n   model User {\n     id Int @id\n     name String\n     // Missing newline before }\n   }\n   \n   // Correct!\n   model User {\n     id   Int    @id @default(autoincrement())\n     name String\n   }\n   ```\n\n7. **Not using Prisma Studio**:\n   - Run `npx prisma studio` to see your data visually\n   - Great for debugging and understanding your database\n   - Much easier than writing SELECT queries!"
    },
    {
      "id": "11.3",
      "title": "Writing the Prisma Schema (The Blueprint Analogy)",
      "conceptAnalogy": "Imagine you're an architect designing a house:\n\nWithout a blueprint:\n- Builders have no clear plan\n- Everyone interprets requirements differently\n- Walls might not line up\n- No standard for room sizes\n- Chaos!\n\nWith a blueprint (Prisma schema):\n- Clear specification for every room\n- Exact measurements and connections\n- Everyone follows the same plan\n- Changes update the whole design\n- Professional and organized!\n\nThe Prisma schema file (schema.prisma) is your database blueprint. It defines your data models, their fields, types, and relationships. Prisma reads this file and:\n1. Creates the database tables for you\n2. Generates TypeScript types automatically\n3. Ensures your code and database always match!\n\nNo more writing SQL CREATE TABLE statements by hand!",
      "codeExample": "// Understanding Prisma Schema (schema.prisma file)\n// This is NOT JavaScript - it's Prisma's special language!\n\n// CONCEPTUAL DEMO - showing schema structure in JavaScript comments\n\n/*\nPrisma Schema Structure:\n\n// 1. DATABASE CONNECTION\ndatasource db {\n  provider = \"postgresql\"  // or \"mysql\", \"sqlite\", \"mongodb\"\n  url      = env(\"DATABASE_URL\")  // Connection string from .env\n}\n\n// 2. PRISMA CLIENT GENERATOR\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\n// 3. DATA MODELS (Tables)\n\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  name      String\n  password  String\n  role      String   @default(\"user\")\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  \n  posts     Post[]   // Relationship: User has many Posts\n  profile   Profile? // Relationship: User has one optional Profile\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  viewCount Int      @default(0)\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  \n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n  \n  categories Category[]\n}\n\nmodel Profile {\n  id       Int    @id @default(autoincrement())\n  bio      String?\n  avatar   String?\n  \n  userId   Int    @unique\n  user     User   @relation(fields: [userId], references: [id])\n}\n\nmodel Category {\n  id    Int    @id @default(autoincrement())\n  name  String @unique\n  \n  posts Post[]\n}\n*/\n\n// SCHEMA CONCEPTS EXPLAINED\n\nlet schemaExplanation = {\n  'Field Types': {\n    'String': 'Text data (\"hello\", \"user@example.com\")',\n    'Int': 'Whole numbers (1, 42, 1000)',\n    'Float': 'Decimal numbers (3.14, 99.99)',\n    'Boolean': 'true or false',\n    'DateTime': 'Dates and times',\n    'Json': 'JSON objects (flexible data)'\n  },\n  \n  'Attributes': {\n    '@id': 'Primary key (unique identifier)',\n    '@unique': 'Value must be unique across all records',\n    '@default(value)': 'Default value if not provided',\n    '@updatedAt': 'Auto-updates to current time on changes',\n    '@relation': 'Defines relationships between models'\n  },\n  \n  'Type Modifiers': {\n    'field String': 'Required field (cannot be null)',\n    'field String?': 'Optional field (can be null)',\n    'field String[]': 'Array of strings'\n  },\n  \n  'Default Functions': {\n    'autoincrement()': 'Auto-increment integers (1, 2, 3...)',\n    'now()': 'Current timestamp',\n    'uuid()': 'Generate random UUID',\n    'cuid()': 'Generate random CUID (shorter than UUID)'\n  }\n};\n\nconsole.log('=== Prisma Schema Concepts ===\\n');\n\nfor (let [category, details] of Object.entries(schemaExplanation)) {\n  console.log(category + ':');\n  for (let [key, desc] of Object.entries(details)) {\n    console.log(`  ${key}: ${desc}`);\n  }\n  console.log('');\n}\n\n// EXAMPLE: What this schema creates\n\nlet exampleData = {\n  users: [\n    {\n      id: 1,\n      email: 'alice@example.com',\n      name: 'Alice',\n      password: 'hashed_password',\n      role: 'user',\n      createdAt: new Date('2025-01-01'),\n      updatedAt: new Date('2025-01-15')\n    }\n  ],\n  posts: [\n    {\n      id: 1,\n      title: 'My First Post',\n      content: 'Hello world!',\n      published: true,\n      viewCount: 42,\n      authorId: 1,  // References user with id 1\n      createdAt: new Date('2025-01-10')\n    }\n  ],\n  profiles: [\n    {\n      id: 1,\n      bio: 'Software developer',\n      avatar: 'https://example.com/avatar.jpg',\n      userId: 1  // References user with id 1\n    }\n  ]\n};\n\nconsole.log('Example database structure:');\nconsole.log(JSON.stringify(exampleData, null, 2));\n\n// WORKFLOW\nconsole.log('\\n=== Prisma Schema Workflow ===');\n\nlet workflow = [\n  '1. Write schema.prisma file (define your models)',\n  '2. Run: npx prisma migrate dev --name init',\n  '   → Creates database tables',\n  '   → Creates migration files',\n  '3. Run: npx prisma generate',\n  '   → Generates TypeScript types',\n  '   → Updates Prisma Client',\n  '4. Use in your code with full type safety!'\n];\n\nworkflow.forEach(step => console.log(step));",
      "syntaxBreakdown": "Prisma Schema Syntax Guide:\n\n1. **File Structure** (schema.prisma):\n   ```prisma\n   // Database connection\n   datasource db {\n     provider = \"postgresql\"\n     url      = env(\"DATABASE_URL\")\n   }\n   \n   // TypeScript client generator\n   generator client {\n     provider = \"prisma-client-js\"\n   }\n   \n   // Your data models\n   model ModelName {\n     // fields here\n   }\n   ```\n\n2. **Field Syntax**:\n   ```prisma\n   model User {\n     fieldName  FieldType  @attribute\n   }\n   ```\n\n3. **Common Field Types**:\n   - `String` - Text (VARCHAR)\n   - `Int` - Integer\n   - `Float` - Decimal number\n   - `Boolean` - true/false\n   - `DateTime` - Timestamp\n   - `Json` - JSON object\n   - `Bytes` - Binary data\n\n4. **Field Attributes**:\n   ```prisma\n   id        Int      @id @default(autoincrement())\n   email     String   @unique\n   name      String   @default(\"Anonymous\")\n   createdAt DateTime @default(now())\n   updatedAt DateTime @updatedAt\n   bio       String?  // ? makes it optional\n   tags      String[] // [] makes it an array\n   ```\n\n5. **Primary Key Options**:\n   ```prisma\n   // Auto-incrementing integer\n   id Int @id @default(autoincrement())\n   \n   // UUID (random unique string)\n   id String @id @default(uuid())\n   \n   // CUID (shorter unique string)\n   id String @id @default(cuid())\n   ```\n\n6. **Unique Constraints**:\n   ```prisma\n   email String @unique  // Single unique field\n   \n   // Compound unique (combination must be unique)\n   @@unique([email, username])\n   ```\n\n7. **Indexes for Performance**:\n   ```prisma\n   email String @unique  // Automatically indexed\n   \n   // Manual index\n   @@index([email])\n   \n   // Compound index\n   @@index([lastName, firstName])\n   ```\n\n8. **Database Providers**:\n   ```prisma\n   provider = \"postgresql\"  // Recommended for production\n   provider = \"mysql\"\n   provider = \"sqlite\"      // Good for development\n   provider = \"sqlserver\"\n   provider = \"mongodb\"\n   provider = \"cockroachdb\"\n   ```\n\n9. **Environment Variables**:\n   ```prisma\n   url = env(\"DATABASE_URL\")\n   ```\n   \n   In your .env file:\n   ```\n   DATABASE_URL=\"postgresql://user:password@localhost:5432/mydb\"\n   ```\n\n10. **Complete Example**:\n    ```prisma\n    datasource db {\n      provider = \"postgresql\"\n      url      = env(\"DATABASE_URL\")\n    }\n    \n    generator client {\n      provider = \"prisma-client-js\"\n    }\n    \n    model User {\n      id        Int      @id @default(autoincrement())\n      email     String   @unique\n      name      String\n      age       Int?\n      isActive  Boolean  @default(true)\n      createdAt DateTime @default(now())\n      updatedAt DateTime @updatedAt\n    }\n    ```",
      "challenge": {
        "instructions": "Simulate a Prisma schema structure in JavaScript:\n\n1. Create an object called `schema` with a `models` property\n2. Add a 'Product' model with these fields:\n   - id (integer, auto-increment)\n   - name (string, required)\n   - price (number, required)\n   - inStock (boolean, default true)\n   - description (string, optional)\n   - createdAt (date, default now)\n\n3. Create a function `generateModelSQL(model)` that simulates generating SQL\n4. Display the schema structure\n\nYou're simulating what Prisma does internally!",
        "starterCode": "// Simulated Prisma schema structure\nlet schema = {\n  models: {\n    Product: {\n      fields: {\n        id: { type: 'Int', primaryKey: true, autoIncrement: true },\n        name: { type: 'String', required: true },\n        price: { type: 'Float', required: true },\n        inStock: { type: 'Boolean', default: true },\n        description: { type: 'String', required: false },\n        createdAt: { type: 'DateTime', default: 'now()' }\n      }\n    }\n  }\n};\n\n// Function to generate SQL from model\nfunction generateModelSQL(modelName, model) {\n  let sql = `CREATE TABLE ${modelName} (\\n`;\n  \n  let fields = [];\n  for (let [fieldName, field] of Object.entries(model.fields)) {\n    let line = `  ${fieldName} `;\n    \n    // Type mapping\n    if (field.type === 'Int') line += 'INTEGER';\n    else if (field.type === 'String') line += 'TEXT';\n    else if (field.type === 'Float') line += 'REAL';\n    else if (field.type === 'Boolean') line += 'BOOLEAN';\n    else if (field.type === 'DateTime') line += 'TIMESTAMP';\n    \n    // Constraints\n    if (field.primaryKey) line += ' PRIMARY KEY';\n    if (field.autoIncrement) line += ' AUTOINCREMENT';\n    if (field.required) line += ' NOT NULL';\n    if (field.default !== undefined) {\n      if (field.default === 'now()') line += ' DEFAULT CURRENT_TIMESTAMP';\n      else if (typeof field.default === 'boolean') line += ` DEFAULT ${field.default ? 1 : 0}`;\n      else line += ` DEFAULT ${field.default}`;\n    }\n    \n    fields.push(line);\n  }\n  \n  sql += fields.join(',\\n');\n  sql += '\\n);';\n  \n  return sql;\n}\n\n// Generate SQL\nlet sql = generateModelSQL('Product', schema.models.Product);\nconsole.log('Generated SQL:\\n');\nconsole.log(sql);\n\n// Display schema\nconsole.log('\\nPrisma Schema Structure:');\nconsole.log(JSON.stringify(schema, null, 2));",
        "testCases": [
          {
            "description": "Schema has Product model",
            "input": "let schema = { models: { Product: { fields: { id: { type: 'Int' } } } } }; console.log('Product' in schema.models);",
            "expectedOutput": "true"
          },
          {
            "description": "Product has required name field",
            "input": "let model = { fields: { name: { type: 'String', required: true } } }; console.log(model.fields.name.required);",
            "expectedOutput": "true"
          }
        ],
        "hint": "Create nested objects: schema → models → Product → fields → {id, name, price...}"
      },
      "solution": "// Complete Prisma schema simulator\nlet schema = {\n  datasource: {\n    provider: 'postgresql',\n    url: 'env(\"DATABASE_URL\")'\n  },\n  generator: {\n    provider: 'prisma-client-js'\n  },\n  models: {\n    Product: {\n      fields: {\n        id: {\n          type: 'Int',\n          primaryKey: true,\n          autoIncrement: true\n        },\n        name: {\n          type: 'String',\n          required: true\n        },\n        price: {\n          type: 'Float',\n          required: true\n        },\n        inStock: {\n          type: 'Boolean',\n          default: true\n        },\n        description: {\n          type: 'String',\n          required: false\n        },\n        category: {\n          type: 'String',\n          default: 'General'\n        },\n        createdAt: {\n          type: 'DateTime',\n          default: 'now()'\n        },\n        updatedAt: {\n          type: 'DateTime',\n          updatedAt: true\n        }\n      }\n    },\n    Order: {\n      fields: {\n        id: {\n          type: 'Int',\n          primaryKey: true,\n          autoIncrement: true\n        },\n        productId: {\n          type: 'Int',\n          required: true\n        },\n        quantity: {\n          type: 'Int',\n          required: true,\n          default: 1\n        },\n        total: {\n          type: 'Float',\n          required: true\n        },\n        createdAt: {\n          type: 'DateTime',\n          default: 'now()'\n        }\n      }\n    }\n  }\n};\n\nfunction generateModelSQL(modelName, model) {\n  let sql = `CREATE TABLE ${modelName} (\\n`;\n  let fields = [];\n  \n  for (let [fieldName, field] of Object.entries(model.fields)) {\n    let line = `  ${fieldName} `;\n    \n    // Map Prisma types to SQL types\n    let typeMap = {\n      'Int': 'INTEGER',\n      'String': 'TEXT',\n      'Float': 'REAL',\n      'Boolean': 'BOOLEAN',\n      'DateTime': 'TIMESTAMP'\n    };\n    \n    line += typeMap[field.type] || 'TEXT';\n    \n    if (field.primaryKey) line += ' PRIMARY KEY';\n    if (field.autoIncrement) line += ' AUTOINCREMENT';\n    if (field.required) line += ' NOT NULL';\n    \n    if (field.default !== undefined) {\n      if (field.default === 'now()') {\n        line += ' DEFAULT CURRENT_TIMESTAMP';\n      } else if (typeof field.default === 'boolean') {\n        line += ` DEFAULT ${field.default ? 1 : 0}`;\n      } else if (typeof field.default === 'string') {\n        line += ` DEFAULT '${field.default}'`;\n      } else {\n        line += ` DEFAULT ${field.default}`;\n      }\n    }\n    \n    fields.push(line);\n  }\n  \n  sql += fields.join(',\\n');\n  sql += '\\n);';\n  return sql;\n}\n\nconsole.log('=== Prisma Schema Simulator ===\\n');\n\n// Generate SQL for all models\nfor (let [modelName, model] of Object.entries(schema.models)) {\n  console.log(`${modelName} Model SQL:\\n`);\n  console.log(generateModelSQL(modelName, model));\n  console.log('');\n}\n\n// Display schema structure\nconsole.log('Complete Prisma Schema:');\nconsole.log(`datasource: ${schema.datasource.provider}`);\nconsole.log(`generator: ${schema.generator.provider}`);\nconsole.log(`models: ${Object.keys(schema.models).join(', ')}`);\nconsole.log('\\nDetailed Schema:');\nconsole.log(JSON.stringify(schema, null, 2));",
      "commonStickingPoints": "Common Prisma schema mistakes:\n\n1. **Forgetting semicolons or using wrong syntax**:\n   ```prisma\n   // Wrong! Prisma doesn't use semicolons\n   model User {\n     id Int @id;\n   }\n   \n   // Correct!\n   model User {\n     id Int @id\n   }\n   ```\n\n2. **Wrong field type capitalization**:\n   ```prisma\n   // Wrong!\n   name string  // lowercase\n   \n   // Correct!\n   name String  // Pascal case\n   ```\n\n3. **Forgetting @id attribute**:\n   ```prisma\n   // Wrong! Every model needs an @id\n   model User {\n     email String @unique\n     name  String\n   }\n   \n   // Correct!\n   model User {\n     id    Int    @id @default(autoincrement())\n     email String @unique\n     name  String\n   }\n   ```\n\n4. **Using JavaScript syntax in schema**:\n   ```prisma\n   // Wrong! This is not JavaScript\n   model User {\n     isActive: Boolean = true\n   }\n   \n   // Correct! This is Prisma schema language\n   model User {\n     isActive Boolean @default(true)\n   }\n   ```\n\n5. **Wrong default value syntax**:\n   ```prisma\n   // Wrong!\n   createdAt DateTime default(now())\n   \n   // Correct!\n   createdAt DateTime @default(now())\n   ```\n\n6. **Not running migrate after schema changes**:\n   - Changed schema.prisma?\n   - Run: `npx prisma migrate dev`\n   - Otherwise database won't match your schema!\n\n7. **Incorrect optional syntax**:\n   ```prisma\n   // Wrong!\n   bio String | null\n   \n   // Correct!\n   bio String?  // Question mark makes it optional\n   ```\n\n8. **Forgetting environment variables**:\n   - Schema uses: `url = env(\"DATABASE_URL\")`\n   - Must create .env file:\n   ```\n   DATABASE_URL=\"postgresql://user:pass@localhost:5432/db\"\n   ```\n\n9. **Using relations without foreign keys**:\n   ```prisma\n   // Incomplete! Missing authorId field\n   model Post {\n     id     Int  @id @default(autoincrement())\n     author User @relation(fields: [authorId], references: [id])\n   }\n   \n   // Correct!\n   model Post {\n     id       Int  @id @default(autoincrement())\n     authorId Int  // Foreign key field\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```"
    },
    {
      "id": "11.4",
      "title": "Running Migrations (The Construction Log Analogy)",
      "conceptAnalogy": "Imagine you're building a house over several months:\n\nWithout a construction log:\n- Workers forget what was done yesterday\n- No record of foundation changes\n- Can't rebuild if something breaks\n- No way to share changes with other teams\n- Every site does things differently\n\nWith a construction log (Prisma migrations):\n- Detailed record of every change\n- Day 1: Poured foundation\n- Day 5: Built first floor walls\n- Day 10: Added plumbing\n- Any worker can see the full history\n- Can replay changes to build identical houses\n\nPrisma migrations are a construction log for your database. Each migration file records ONE specific change (like adding a table or field). These files:\n1. Track database evolution over time\n2. Can be replayed on other computers\n3. Make it easy to update production databases\n4. Keep your team synchronized\n\nInstead of manually writing SQL to update your database, Prisma generates migration files automatically from your schema changes!",
      "codeExample": "// Understanding Prisma Migrations\n// Migrations are SQL files that modify your database structure\n\n// SCENARIO: Building a blog app\n\n// Step 1: Initial schema (schema.prisma)\n/*\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String\n}\n*/\n\n// Run migration command:\n// npx prisma migrate dev --name init\n\n// Prisma generates:\n// migrations/20250114_init/migration.sql\n/*\nCREATE TABLE \"User\" (\n  \"id\" INTEGER PRIMARY KEY AUTOINCREMENT,\n  \"email\" TEXT UNIQUE NOT NULL,\n  \"name\" TEXT NOT NULL\n);\n*/\n\nconsole.log('Migration 1: Created User table');\n\n// Step 2: Add posts table\n// Update schema.prisma:\n/*\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String\n  posts Post[]  // NEW: Added relationship\n}\n\nmodel Post {  // NEW: Added entire model\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n}\n*/\n\n// Run migration:\n// npx prisma migrate dev --name add_posts\n\n// Prisma generates:\n// migrations/20250114_add_posts/migration.sql\n/*\nCREATE TABLE \"Post\" (\n  \"id\" INTEGER PRIMARY KEY AUTOINCREMENT,\n  \"title\" TEXT NOT NULL,\n  \"content\" TEXT,\n  \"published\" BOOLEAN NOT NULL DEFAULT 0,\n  \"authorId\" INTEGER NOT NULL,\n  FOREIGN KEY (\"authorId\") REFERENCES \"User\"(\"id\")\n);\n*/\n\nconsole.log('Migration 2: Created Post table with relationship to User');\n\n// Step 3: Add createdAt timestamps\n// Update schema.prisma:\n/*\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  name      String\n  createdAt DateTime @default(now())  // NEW\n  posts     Post[]\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  createdAt DateTime @default(now())  // NEW\n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n}\n*/\n\n// Run migration:\n// npx prisma migrate dev --name add_timestamps\n\n// Prisma generates:\n// migrations/20250114_add_timestamps/migration.sql\n/*\nALTER TABLE \"User\" ADD COLUMN \"createdAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;\nALTER TABLE \"Post\" ADD COLUMN \"createdAt\" DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;\n*/\n\nconsole.log('Migration 3: Added createdAt to User and Post tables');\n\n// MIGRATION COMMANDS EXPLAINED\n\nlet migrationCommands = {\n  'Development': {\n    'npx prisma migrate dev': 'Create and apply migrations in development',\n    'npx prisma migrate dev --name <name>': 'Create migration with descriptive name',\n    'npx prisma migrate reset': 'Reset database and replay all migrations',\n    'npx prisma db push': 'Quick prototype without creating migration file'\n  },\n  \n  'Production': {\n    'npx prisma migrate deploy': 'Apply pending migrations to production',\n    'npx prisma migrate resolve': 'Mark migration as applied/rolled back',\n    'npx prisma migrate status': 'Check which migrations are pending'\n  },\n  \n  'Inspection': {\n    'npx prisma migrate diff': 'Compare database to schema',\n    'npx prisma db pull': 'Introspect existing database to generate schema',\n    'npx prisma studio': 'Visual database browser'\n  }\n};\n\nconsole.log('\\n=== Prisma Migration Commands ===\\n');\n\nfor (let [category, commands] of Object.entries(migrationCommands)) {\n  console.log(category + ' Commands:');\n  for (let [cmd, desc] of Object.entries(commands)) {\n    console.log(`  ${cmd}`);\n    console.log(`    → ${desc}`);\n  }\n  console.log('');\n}\n\n// MIGRATION WORKFLOW SIMULATION\n\nlet migrationHistory = [\n  {\n    name: '20250114_init',\n    description: 'Initial database setup',\n    changes: ['Created User table']\n  },\n  {\n    name: '20250114_add_posts',\n    description: 'Add blog posts',\n    changes: ['Created Post table', 'Added User.posts relation']\n  },\n  {\n    name: '20250114_add_timestamps',\n    description: 'Add audit timestamps',\n    changes: ['Added User.createdAt', 'Added Post.createdAt']\n  }\n];\n\nconsole.log('Migration History:');\nmigrationHistory.forEach((migration, index) => {\n  console.log(`\\n${index + 1}. ${migration.name}`);\n  console.log(`   Description: ${migration.description}`);\n  console.log('   Changes:');\n  migration.changes.forEach(change => {\n    console.log(`     - ${change}`);\n  });\n});\n\n// BENEFITS OF MIGRATIONS\n\nlet benefits = [\n  'Version control: Track database changes like code',\n  'Reproducible: Same migrations = identical databases',\n  'Team sync: Everyone applies same changes',\n  'Rollback: Can undo changes if needed',\n  'Production safety: Test migrations before deploying',\n  'Documentation: Clear history of schema evolution',\n  'CI/CD: Automated database updates in pipelines'\n];\n\nconsole.log('\\nBenefits of Migrations:');\nbenefits.forEach(benefit => console.log(`  ✓ ${benefit}`));",
      "syntaxBreakdown": "Prisma Migration Commands Guide:\n\n1. **Creating Migrations** (Development):\n   ```bash\n   # Standard workflow\n   npx prisma migrate dev --name add_user_table\n   \n   # What this does:\n   # 1. Compares schema.prisma to current database\n   # 2. Generates SQL migration file\n   # 3. Applies migration to database\n   # 4. Runs prisma generate (updates Prisma Client)\n   ```\n\n2. **Migration File Structure**:\n   ```\n   prisma/\n   ├── schema.prisma\n   └── migrations/\n       ├── 20250114120000_init/\n       │   └── migration.sql\n       ├── 20250114130000_add_posts/\n       │   └── migration.sql\n       └── migration_lock.toml\n   ```\n\n3. **Example Migration File**:\n   ```sql\n   -- CreateTable\n   CREATE TABLE \"User\" (\n       \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n       \"email\" TEXT NOT NULL,\n       \"name\" TEXT NOT NULL\n   );\n   \n   -- CreateIndex\n   CREATE UNIQUE INDEX \"User_email_key\" ON \"User\"(\"email\");\n   ```\n\n4. **Common Migration Workflows**:\n\n   **First Migration**:\n   ```bash\n   # 1. Write schema.prisma\n   # 2. Create initial migration\n   npx prisma migrate dev --name init\n   ```\n\n   **Add New Table**:\n   ```bash\n   # 1. Add model to schema.prisma\n   # 2. Create migration\n   npx prisma migrate dev --name add_posts\n   ```\n\n   **Modify Existing Table**:\n   ```bash\n   # 1. Update model in schema.prisma\n   # 2. Create migration\n   npx prisma migrate dev --name add_user_bio\n   ```\n\n5. **Development vs Production**:\n\n   **Development** (migrate dev):\n   - Creates migration files\n   - Applies to local database\n   - Updates Prisma Client\n   - Can reset database easily\n   \n   ```bash\n   npx prisma migrate dev\n   ```\n\n   **Production** (migrate deploy):\n   - Only applies existing migrations\n   - Never creates new migrations\n   - Safe for production\n   - No schema changes\n   \n   ```bash\n   npx prisma migrate deploy\n   ```\n\n6. **Reset Database** (Development Only!):\n   ```bash\n   npx prisma migrate reset\n   \n   # This:\n   # 1. Drops entire database\n   # 2. Creates new database\n   # 3. Applies all migrations\n   # 4. Runs seed script (if exists)\n   ```\n\n7. **Prototyping Without Migrations**:\n   ```bash\n   npx prisma db push\n   \n   # Use when:\n   # - Early prototyping\n   # - Don't want migration files yet\n   # - Quick schema tests\n   \n   # DON'T use in production!\n   ```\n\n8. **Check Migration Status**:\n   ```bash\n   npx prisma migrate status\n   \n   # Shows:\n   # - Applied migrations\n   # - Pending migrations\n   # - Database drift (manual changes)\n   ```\n\n9. **Naming Conventions**:\n   ```bash\n   # Good names (descriptive):\n   npx prisma migrate dev --name init\n   npx prisma migrate dev --name add_user_profile\n   npx prisma migrate dev --name make_email_unique\n   npx prisma migrate dev --name add_post_comments\n   \n   # Bad names (not descriptive):\n   npx prisma migrate dev --name update\n   npx prisma migrate dev --name fix\n   npx prisma migrate dev --name changes\n   ```\n\n10. **Full Deployment Workflow**:\n    ```bash\n    # Development:\n    git checkout -b feature/add-comments\n    # Update schema.prisma\n    npx prisma migrate dev --name add_comments\n    git add prisma/\n    git commit -m \"Add comments table\"\n    git push\n    \n    # Production (CI/CD or manual):\n    git pull\n    npx prisma migrate deploy  # Apply pending migrations\n    npm run build\n    npm run start\n    ```",
      "challenge": {
        "instructions": "Simulate a migration system:\n\n1. Create a `migrations` array to store migration records\n2. Create a function `createMigration(name, sql)` that:\n   - Generates a timestamp\n   - Creates migration object\n   - Adds to migrations array\n   - Returns the migration\n3. Create a function `applyMigrations()` that:\n   - Loops through all migrations\n   - Simulates executing SQL\n   - Tracks which are applied\n4. Simulate creating 3 migrations:\n   - 'init' (create users table)\n   - 'add_posts' (create posts table)\n   - 'add_timestamps' (add createdAt fields)\n5. Display migration history\n\nYou're simulating what Prisma does!",
        "starterCode": "// Migration system simulator\nlet migrations = [];\nlet appliedMigrations = new Set();\n\n// Create migration\nfunction createMigration(name, sql) {\n  let timestamp = Date.now();\n  let migration = {\n    id: `${timestamp}_${name}`,\n    name: name,\n    sql: sql,\n    createdAt: new Date().toISOString()\n  };\n  \n  migrations.push(migration);\n  console.log(`✓ Created migration: ${migration.id}`);\n  return migration;\n}\n\n// Apply migrations\nfunction applyMigrations() {\n  console.log('\\nApplying migrations...');\n  \n  for (let migration of migrations) {\n    if (!appliedMigrations.has(migration.id)) {\n      console.log(`  Running: ${migration.name}`);\n      console.log(`  SQL: ${migration.sql}`);\n      appliedMigrations.add(migration.id);\n      console.log(`  ✓ Applied: ${migration.id}\\n`);\n    } else {\n      console.log(`  ⊘ Skipped (already applied): ${migration.name}`);\n    }\n  }\n}\n\n// Get migration status\nfunction getMigrationStatus() {\n  console.log('=== Migration Status ===');\n  console.log(`Total migrations: ${migrations.length}`);\n  console.log(`Applied: ${appliedMigrations.size}`);\n  console.log(`Pending: ${migrations.length - appliedMigrations.size}`);\n}\n\n// Create migrations\nconsole.log('=== Creating Migrations ===\\n');\n\ncreateMigration('init', 'CREATE TABLE users (id INT, email TEXT, name TEXT);');\n\nsetTimeout(() => {\n  createMigration('add_posts', 'CREATE TABLE posts (id INT, title TEXT, author_id INT);');\n}, 100);\n\nsetTimeout(() => {\n  createMigration('add_timestamps', 'ALTER TABLE users ADD COLUMN created_at TIMESTAMP;');\n}, 200);\n\nsetTimeout(() => {\n  applyMigrations();\n  getMigrationStatus();\n  \n  console.log('\\n=== Migration History ===');\n  migrations.forEach((m, i) => {\n    let status = appliedMigrations.has(m.id) ? '✓ Applied' : '⏳ Pending';\n    console.log(`${i + 1}. ${m.name} - ${status}`);\n  });\n}, 400);",
        "testCases": [
          {
            "description": "Creates migration with timestamp",
            "input": "let migrations = []; let m = { id: Date.now() + '_init', name: 'init' }; migrations.push(m); console.log(migrations.length);",
            "expectedOutput": "1"
          },
          {
            "description": "Tracks applied migrations",
            "input": "let applied = new Set(); applied.add('123_init'); console.log(applied.has('123_init'));",
            "expectedOutput": "true"
          }
        ],
        "hint": "Use timestamps for unique IDs, Set to track applied migrations, loops to apply each one"
      },
      "solution": "// Complete migration system simulator\nlet migrations = [];\nlet appliedMigrations = new Set();\nlet database = {\n  tables: {},\n  indexes: []\n};\n\nfunction createMigration(name, description, sql) {\n  let timestamp = Date.now();\n  let migration = {\n    id: `${timestamp}_${name}`,\n    name: name,\n    description: description,\n    sql: sql,\n    createdAt: new Date().toISOString(),\n    applied: false\n  };\n  \n  migrations.push(migration);\n  console.log(`✓ Created migration: ${migration.id}`);\n  console.log(`  Description: ${description}`);\n  return migration;\n}\n\nfunction applyMigrations() {\n  console.log('\\n=== Applying Migrations ===\\n');\n  \n  let applied = 0;\n  for (let migration of migrations) {\n    if (!appliedMigrations.has(migration.id)) {\n      console.log(`Running: ${migration.name}`);\n      console.log(`SQL: ${migration.sql}`);\n      \n      // Simulate executing SQL\n      executeSQLSimulation(migration.sql);\n      \n      appliedMigrations.add(migration.id);\n      migration.applied = true;\n      applied++;\n      \n      console.log(`✓ Applied: ${migration.id}\\n`);\n    } else {\n      console.log(`⊘ Skipped (already applied): ${migration.name}\\n`);\n    }\n  }\n  \n  console.log(`Completed: ${applied} migration(s) applied`);\n}\n\nfunction executeSQLSimulation(sql) {\n  // Simulate SQL execution\n  if (sql.includes('CREATE TABLE')) {\n    let match = sql.match(/CREATE TABLE (\\w+)/);\n    if (match) {\n      let tableName = match[1];\n      database.tables[tableName] = { created: true };\n      console.log(`  → Created table: ${tableName}`);\n    }\n  } else if (sql.includes('ALTER TABLE')) {\n    console.log('  → Altered table structure');\n  }\n}\n\nfunction getMigrationStatus() {\n  console.log('\\n=== Migration Status ===');\n  console.log(`Total migrations: ${migrations.length}`);\n  console.log(`Applied: ${appliedMigrations.size}`);\n  console.log(`Pending: ${migrations.length - appliedMigrations.size}`);\n  console.log(`Database tables: ${Object.keys(database.tables).join(', ') || 'none'}`);\n}\n\nfunction rollbackLastMigration() {\n  let lastApplied = migrations.filter(m => m.applied).pop();\n  if (lastApplied) {\n    appliedMigrations.delete(lastApplied.id);\n    lastApplied.applied = false;\n    console.log(`\\n✓ Rolled back: ${lastApplied.name}`);\n  } else {\n    console.log('\\nNo migrations to roll back');\n  }\n}\n\nfunction listMigrations() {\n  console.log('\\n=== Migration History ===');\n  migrations.forEach((m, i) => {\n    let status = m.applied ? '✓ Applied' : '⏳ Pending';\n    console.log(`${i + 1}. ${m.name}`);\n    console.log(`   ID: ${m.id}`);\n    console.log(`   Status: ${status}`);\n    console.log(`   Created: ${m.createdAt}`);\n    console.log(`   Description: ${m.description}`);\n    console.log('');\n  });\n}\n\n// Create migrations\nconsole.log('=== Migration System Simulator ===\\n');\n\ncreateMigration(\n  'init',\n  'Initial database setup',\n  'CREATE TABLE users (id INT PRIMARY KEY, email TEXT UNIQUE, name TEXT);'\n);\n\nsetTimeout(() => {\n  createMigration(\n    'add_posts',\n    'Add blog posts table',\n    'CREATE TABLE posts (id INT PRIMARY KEY, title TEXT, content TEXT, author_id INT);'\n  );\n}, 100);\n\nsetTimeout(() => {\n  createMigration(\n    'add_timestamps',\n    'Add audit timestamps',\n    'ALTER TABLE users ADD COLUMN created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;'\n  );\n}, 200);\n\nsetTimeout(() => {\n  applyMigrations();\n  getMigrationStatus();\n  listMigrations();\n}, 400);",
      "commonStickingPoints": "Common migration mistakes:\n\n1. **Forgetting to run migrations**:\n   ```bash\n   # Changed schema.prisma but database not updated!\n   \n   # Must run:\n   npx prisma migrate dev\n   ```\n\n2. **Using db push in production**:\n   ```bash\n   # NEVER do this in production:\n   npx prisma db push  # No migration history!\n   \n   # Use migrate deploy instead:\n   npx prisma migrate deploy\n   ```\n\n3. **Editing migration files manually**:\n   - Don't edit generated migrations unless absolutely necessary\n   - Prisma tracks checksums - manual edits can cause errors\n   - Better: create new migration to fix issues\n\n4. **Not committing migration files**:\n   ```bash\n   # WRONG: Ignoring migrations in .gitignore\n   prisma/migrations/  # Don't do this!\n   \n   # CORRECT: Commit migrations to git\n   git add prisma/migrations/\n   git commit -m \"Add user table migration\"\n   ```\n\n5. **Running migrate dev in production**:\n   ```bash\n   # Development:\n   npx prisma migrate dev  # Creates migrations\n   \n   # Production:\n   npx prisma migrate deploy  # Only applies existing migrations\n   ```\n\n6. **Schema drift (manual database changes)**:\n   ```bash\n   # Problem: Someone manually altered database\n   # Solution: Check drift\n   npx prisma migrate diff\n   \n   # Then either:\n   # - Revert manual changes\n   # - Create migration to match changes\n   ```\n\n7. **Migration conflicts in teams**:\n   ```bash\n   # Two developers create migrations at same time\n   # Git merge conflict in migrations folder\n   \n   # Resolution:\n   # 1. Pull latest changes\n   # 2. Reset local database\n   npx prisma migrate reset\n   # 3. Migrations will replay in correct order\n   ```\n\n8. **Forgetting to generate Prisma Client**:\n   ```bash\n   # After migration, types might be outdated\n   npx prisma generate\n   \n   # Or use migrate dev which does it automatically\n   npx prisma migrate dev\n   ```\n\n9. **Not testing migrations**:\n   ```bash\n   # Best practice:\n   # 1. Create migration in development\n   npx prisma migrate dev --name add_feature\n   \n   # 2. Test thoroughly\n   npm run test\n   \n   # 3. Deploy to staging\n   npx prisma migrate deploy\n   \n   # 4. Test staging\n   \n   # 5. Deploy to production\n   npx prisma migrate deploy\n   ```\n\n10. **Breaking changes without data migration**:\n    ```prisma\n    // Dangerous: Deleting field loses data!\n    model User {\n      id    Int    @id\n      email String\n      // name String  ← Deleted! Data lost!\n    }\n    \n    // Better: Make optional first, then remove later\n    model User {\n      id    Int     @id\n      email String\n      name  String? ← Made optional, can migrate data\n    }\n    ```"
    },
    {
      "id": "11.5",
      "title": "Handling Relations (The Social Network Analogy)",
      "conceptAnalogy": "Imagine designing a social network:\n\nWithout relationships:\n- Each user's posts stored separately\n- No way to find who wrote which post\n- Comments disconnected from posts\n- Can't see friends list\n- Data duplication everywhere!\n\nWith relationships (Prisma relations):\n- Users ← many → Posts (one user has many posts)\n- Posts ← many → Comments (one post has many comments)\n- Users ← many ↔ many → Users (users can follow each other)\n- Data connected logically\n- No duplication!\n\nDatabase relations are like links between different entities. They mirror real-world connections:\n- A customer has many orders\n- A blog post has many comments\n- A student enrolls in many courses\n\nPrisma makes defining these relationships incredibly simple with its intuitive syntax!",
      "codeExample": "// Understanding Prisma Relations\n\n// THREE TYPES OF RELATIONSHIPS:\n\n// 1. ONE-TO-MANY (Most common)\n// Example: One user has many posts\n/*\nmodel User {\n  id    Int    @id @default(autoincrement())\n  email String @unique\n  name  String\n  \n  posts Post[]  // Array: User has many posts\n}\n\nmodel Post {\n  id       Int    @id @default(autoincrement())\n  title    String\n  content  String?\n  \n  authorId Int    // Foreign key\n  author   User   @relation(fields: [authorId], references: [id])\n}\n*/\n\nconsole.log('=== ONE-TO-MANY Relationship ===');\nconsole.log('One User → Many Posts');\nconsole.log('Schema: User.posts (array), Post.author (single)');\nconsole.log('');\n\n// Example data structure:\nlet oneToManyExample = {\n  user: {\n    id: 1,\n    email: 'alice@example.com',\n    name: 'Alice',\n    posts: [  // Array of posts\n      { id: 1, title: 'First Post', authorId: 1 },\n      { id: 2, title: 'Second Post', authorId: 1 },\n      { id: 3, title: 'Third Post', authorId: 1 }\n    ]\n  }\n};\n\nconsole.log('Example data:');\nconsole.log(JSON.stringify(oneToManyExample, null, 2));\nconsole.log('');\n\n// 2. ONE-TO-ONE (Less common)\n// Example: One user has one profile\n/*\nmodel User {\n  id      Int      @id @default(autoincrement())\n  email   String   @unique\n  name    String\n  \n  profile Profile? // Optional: User might not have profile yet\n}\n\nmodel Profile {\n  id     Int    @id @default(autoincrement())\n  bio    String?\n  avatar String?\n  \n  userId Int     @unique  // UNIQUE makes it one-to-one!\n  user   User    @relation(fields: [userId], references: [id])\n}\n*/\n\nconsole.log('=== ONE-TO-ONE Relationship ===');\nconsole.log('One User → One Profile');\nconsole.log('Schema: Profile.userId must be @unique');\nconsole.log('');\n\nlet oneToOneExample = {\n  user: {\n    id: 1,\n    email: 'alice@example.com',\n    name: 'Alice',\n    profile: {  // Single profile object\n      id: 1,\n      bio: 'Software developer',\n      avatar: 'https://example.com/alice.jpg',\n      userId: 1\n    }\n  }\n};\n\nconsole.log('Example data:');\nconsole.log(JSON.stringify(oneToOneExample, null, 2));\nconsole.log('');\n\n// 3. MANY-TO-MANY (Complex but powerful)\n// Example: Users can like many posts, posts can be liked by many users\n/*\nmodel User {\n  id        Int    @id @default(autoincrement())\n  email     String @unique\n  name      String\n  \n  likedPosts Post[] @relation(\"PostLikes\")\n}\n\nmodel Post {\n  id       Int      @id @default(autoincrement())\n  title    String\n  content  String?\n  \n  likedBy  User[]   @relation(\"PostLikes\")\n}\n\n// Prisma creates a join table automatically:\n// _PostLikes (userId, postId)\n*/\n\nconsole.log('=== MANY-TO-MANY Relationship ===');\nconsole.log('Many Users ↔ Many Posts (likes)');\nconsole.log('Schema: Both sides have arrays, named relation');\nconsole.log('Prisma auto-creates join table: _PostLikes');\nconsole.log('');\n\nlet manyToManyExample = {\n  user: {\n    id: 1,\n    name: 'Alice',\n    likedPosts: [  // Array of posts Alice liked\n      { id: 5, title: 'Cool Post' },\n      { id: 7, title: 'Amazing Article' }\n    ]\n  },\n  post: {\n    id: 5,\n    title: 'Cool Post',\n    likedBy: [  // Array of users who liked this post\n      { id: 1, name: 'Alice' },\n      { id: 2, name: 'Bob' },\n      { id: 3, name: 'Charlie' }\n    ]\n  }\n};\n\nconsole.log('Example data:');\nconsole.log(JSON.stringify(manyToManyExample, null, 2));\nconsole.log('');\n\n// EXPLICIT MANY-TO-MANY (when you need extra fields)\n// Example: User enrollments in courses (with enrollment date)\n/*\nmodel User {\n  id          Int          @id @default(autoincrement())\n  name        String\n  enrollments Enrollment[]\n}\n\nmodel Course {\n  id          Int          @id @default(autoincrement())\n  title       String\n  enrollments Enrollment[]\n}\n\nmodel Enrollment {\n  id         Int      @id @default(autoincrement())\n  enrolledAt DateTime @default(now())\n  grade      String?\n  \n  userId     Int\n  user       User     @relation(fields: [userId], references: [id])\n  \n  courseId   Int\n  course     Course   @relation(fields: [courseId], references: [id])\n  \n  @@unique([userId, courseId])  // Can't enroll in same course twice\n}\n*/\n\nconsole.log('=== EXPLICIT MANY-TO-MANY ===');\nconsole.log('When you need extra fields on the relationship');\nconsole.log('Example: Enrollment date, grade, status');\nconsole.log('');\n\n// QUERYING RELATIONS WITH PRISMA CLIENT\n\nlet queryExamples = [\n  '// Get user with all their posts',\n  'let user = await prisma.user.findUnique({',\n  '  where: { id: 1 },',\n  '  include: { posts: true }  // Include related posts',\n  '});',\n  '',\n  '// Get post with author info',\n  'let post = await prisma.post.findUnique({',\n  '  where: { id: 1 },',\n  '  include: { author: true }  // Include related user',\n  '});',\n  '',\n  '// Create post with author connection',\n  'let post = await prisma.post.create({',\n  '  data: {',\n  '    title: \"New Post\",',\n  '    content: \"Hello!\",',\n  '    author: {',\n  '      connect: { id: 1 }  // Connect to existing user',\n  '    }',\n  '  }',\n  '});',\n  '',\n  '// Create user with posts in one go',\n  'let user = await prisma.user.create({',\n  '  data: {',\n  '    email: \"bob@example.com\",',\n  '    name: \"Bob\",',\n  '    posts: {',\n  '      create: [  // Create posts at same time',\n  '        { title: \"First\", content: \"Content 1\" },',\n  '        { title: \"Second\", content: \"Content 2\" }',\n  '      ]',\n  '    }',\n  '  }',\n  '});'\n];\n\nconsole.log('Querying Relations:');\nqueryExamples.forEach(line => console.log(line));",
      "syntaxBreakdown": "Prisma Relations Syntax Guide:\n\n1. **ONE-TO-MANY Relationship**:\n   ```prisma\n   model User {\n     id    Int    @id @default(autoincrement())\n     posts Post[] // Relation field (no column in database)\n   }\n   \n   model Post {\n     id       Int  @id @default(autoincrement())\n     authorId Int  // Foreign key (actual column)\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```\n   \n   Key points:\n   - \"Many\" side: array type (Post[])\n   - \"One\" side: singular type + @relation\n   - Foreign key: actual database column\n   - Relation field: virtual, not in database\n\n2. **ONE-TO-ONE Relationship**:\n   ```prisma\n   model User {\n     id      Int      @id\n     profile Profile? // Optional (user might not have profile)\n   }\n   \n   model Profile {\n     id     Int  @id\n     userId Int  @unique // UNIQUE makes it one-to-one!\n     user   User @relation(fields: [userId], references: [id])\n   }\n   ```\n   \n   Key points:\n   - Foreign key must be @unique\n   - One side usually optional (?)\n\n3. **MANY-TO-MANY (Implicit)**:\n   ```prisma\n   model User {\n     id    Int    @id\n     posts Post[] @relation(\"UserLikes\")\n   }\n   \n   model Post {\n     id     Int    @id\n     likedBy User[] @relation(\"UserLikes\")\n   }\n   ```\n   \n   Key points:\n   - Both sides are arrays\n   - Named relation (\"UserLikes\")\n   - Prisma auto-creates join table (_UserLikes)\n   - No foreign keys needed!\n\n4. **MANY-TO-MANY (Explicit)**:\n   ```prisma\n   model User {\n     id          Int          @id\n     enrollments Enrollment[]\n   }\n   \n   model Course {\n     id          Int          @id\n     enrollments Enrollment[]\n   }\n   \n   model Enrollment {\n     id       Int      @id\n     userId   Int\n     user     User     @relation(fields: [userId], references: [id])\n     courseId Int\n     course   Course   @relation(fields: [courseId], references: [id])\n     \n     enrolledAt DateTime @default(now())\n     grade      String?\n     \n     @@unique([userId, courseId])\n   }\n   ```\n   \n   Use when you need:\n   - Extra fields (enrolledAt, grade)\n   - Composite unique constraints\n   - More control over join table\n\n5. **Relation Attributes**:\n   ```prisma\n   @relation(fields: [authorId], references: [id])\n   ```\n   \n   - `fields`: Foreign key in this model\n   - `references`: Primary key in related model\n   - Both are arrays (can be composite keys)\n\n6. **Cascade Delete** (be careful!):\n   ```prisma\n   model User {\n     id    Int    @id\n     posts Post[]\n   }\n   \n   model Post {\n     id       Int  @id\n     authorId Int\n     author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)\n   }\n   ```\n   \n   Options:\n   - `Cascade`: Delete posts when user deleted\n   - `SetNull`: Set authorId to null\n   - `Restrict`: Prevent deletion if posts exist\n   - `NoAction`: Database default\n\n7. **Self-Relations** (like followers):\n   ```prisma\n   model User {\n     id         Int    @id\n     followers  User[] @relation(\"UserFollows\")\n     following  User[] @relation(\"UserFollows\")\n   }\n   ```\n\n8. **Querying Relations**:\n   ```typescript\n   // Include related data\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: {\n       posts: true,\n       profile: true\n     }\n   });\n   \n   // Select specific fields\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     select: {\n       name: true,\n       posts: {\n         select: {\n           title: true,\n           createdAt: true\n         }\n       }\n     }\n   });\n   \n   // Filter relations\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: {\n       posts: {\n         where: { published: true },\n         orderBy: { createdAt: 'desc' },\n         take: 5\n       }\n     }\n   });\n   ```\n\n9. **Creating with Relations**:\n   ```typescript\n   // Connect to existing\n   await prisma.post.create({\n     data: {\n       title: 'New Post',\n       author: { connect: { id: 1 } }\n     }\n   });\n   \n   // Create related\n   await prisma.user.create({\n     data: {\n       email: 'bob@example.com',\n       posts: {\n         create: [\n           { title: 'First Post' },\n           { title: 'Second Post' }\n         ]\n       }\n     }\n   });\n   \n   // Nested writes\n   await prisma.user.update({\n     where: { id: 1 },\n     data: {\n       posts: {\n         create: { title: 'Another Post' },\n         delete: { id: 5 },\n         update: {\n           where: { id: 3 },\n           data: { title: 'Updated Title' }\n         }\n       }\n     }\n   });\n   ```",
      "challenge": {
        "instructions": "Simulate Prisma relations:\n\n1. Create a schema object with three models:\n   - Author (id, name, books array)\n   - Book (id, title, authorId, author)\n   - Category (id, name, books array)\n2. Set up a one-to-many relation: Author → Books\n3. Set up a many-to-many relation: Books ↔ Categories\n4. Create sample data showing:\n   - One author with multiple books\n   - Books connected to multiple categories\n5. Create a function `getAuthorWithBooks(authorId)` that returns author with their books\n6. Display the relational data\n\nYou're simulating Prisma's relation system!",
        "starterCode": "// Simulated Prisma relations\nlet database = {\n  authors: [\n    {\n      id: 1,\n      name: 'J.K. Rowling',\n      books: []  // Will populate\n    }\n  ],\n  books: [\n    {\n      id: 1,\n      title: 'Harry Potter',\n      authorId: 1,\n      categories: []  // Will populate\n    },\n    {\n      id: 2,\n      title: 'Fantastic Beasts',\n      authorId: 1,\n      categories: []\n    }\n  ],\n  categories: [\n    { id: 1, name: 'Fantasy', books: [] },\n    { id: 2, name: 'Adventure', books: [] }\n  ]\n};\n\n// Function to get author with books\nfunction getAuthorWithBooks(authorId) {\n  let author = database.authors.find(a => a.id === authorId);\n  if (!author) return null;\n  \n  // Find books by this author (one-to-many)\n  let books = database.books.filter(b => b.authorId === authorId);\n  \n  return {\n    ...author,\n    books: books\n  };\n}\n\n// Function to get book with categories\nfunction getBookWithCategories(bookId) {\n  let book = database.books.find(b => b.id === bookId);\n  if (!book) return null;\n  \n  // Many-to-many: find categories for this book\n  let categories = database.categories.filter(c => \n    c.books.includes(bookId)\n  );\n  \n  return {\n    ...book,\n    categories: categories\n  };\n}\n\n// Set up many-to-many relations\ndatabase.categories[0].books = [1, 2];  // Fantasy has both books\ndatabase.categories[1].books = [1];     // Adventure has HP only\n\ndatabase.books[0].categories = [1, 2];  // HP is Fantasy + Adventure\ndatabase.books[1].categories = [1];     // FB is Fantasy only\n\n// Test relations\nconsole.log('=== One-to-Many: Author → Books ===');\nlet authorWithBooks = getAuthorWithBooks(1);\nconsole.log(JSON.stringify(authorWithBooks, null, 2));\n\nconsole.log('\\n=== Many-to-Many: Book ↔ Categories ===');\nlet bookWithCategories = getBookWithCategories(1);\nconsole.log(JSON.stringify(bookWithCategories, null, 2));",
        "testCases": [
          {
            "description": "Author has multiple books",
            "input": "let books = [{ id: 1, authorId: 1 }, { id: 2, authorId: 1 }]; let authorBooks = books.filter(b => b.authorId === 1); console.log(authorBooks.length);",
            "expectedOutput": "2"
          },
          {
            "description": "Many-to-many with arrays",
            "input": "let book = { id: 1, categories: [1, 2] }; console.log(book.categories.length);",
            "expectedOutput": "2"
          }
        ],
        "hint": "Use filter() for one-to-many, arrays for many-to-many relationships"
      },
      "solution": "// Complete Prisma relations simulator\nlet database = {\n  authors: [\n    { id: 1, name: 'J.K. Rowling', bio: 'British author' },\n    { id: 2, name: 'George R.R. Martin', bio: 'American novelist' }\n  ],\n  books: [\n    { id: 1, title: 'Harry Potter and the Philosopher\\'s Stone', authorId: 1, published: true },\n    { id: 2, title: 'Harry Potter and the Chamber of Secrets', authorId: 1, published: true },\n    { id: 3, title: 'Fantastic Beasts', authorId: 1, published: true },\n    { id: 4, title: 'A Game of Thrones', authorId: 2, published: true },\n    { id: 5, title: 'A Clash of Kings', authorId: 2, published: true }\n  ],\n  categories: [\n    { id: 1, name: 'Fantasy' },\n    { id: 2, name: 'Adventure' },\n    { id: 3, name: 'Young Adult' },\n    { id: 4, name: 'Epic Fantasy' }\n  ],\n  // Many-to-many join table\n  bookCategories: [\n    { bookId: 1, categoryId: 1 },  // HP1 → Fantasy\n    { bookId: 1, categoryId: 2 },  // HP1 → Adventure\n    { bookId: 1, categoryId: 3 },  // HP1 → YA\n    { bookId: 2, categoryId: 1 },  // HP2 → Fantasy\n    { bookId: 2, categoryId: 3 },  // HP2 → YA\n    { bookId: 3, categoryId: 1 },  // FB → Fantasy\n    { bookId: 4, categoryId: 1 },  // GoT → Fantasy\n    { bookId: 4, categoryId: 4 },  // GoT → Epic Fantasy\n    { bookId: 5, categoryId: 1 },  // Clash → Fantasy\n    { bookId: 5, categoryId: 4 }   // Clash → Epic Fantasy\n  ]\n};\n\n// Prisma-style queries\n\nfunction findAuthorWithBooks(authorId) {\n  let author = database.authors.find(a => a.id === authorId);\n  if (!author) return null;\n  \n  // One-to-many: get all books by this author\n  let books = database.books.filter(b => b.authorId === authorId);\n  \n  // Include categories for each book\n  books = books.map(book => {\n    let categoryIds = database.bookCategories\n      .filter(bc => bc.bookId === book.id)\n      .map(bc => bc.categoryId);\n    \n    let categories = database.categories.filter(c => \n      categoryIds.includes(c.id)\n    );\n    \n    return { ...book, categories };\n  });\n  \n  return { ...author, books };\n}\n\nfunction findBookWithRelations(bookId) {\n  let book = database.books.find(b => b.id === bookId);\n  if (!book) return null;\n  \n  // Get author (many-to-one)\n  let author = database.authors.find(a => a.id === book.authorId);\n  \n  // Get categories (many-to-many)\n  let categoryIds = database.bookCategories\n    .filter(bc => bc.bookId === bookId)\n    .map(bc => bc.categoryId);\n  \n  let categories = database.categories.filter(c => \n    categoryIds.includes(c.id)\n  );\n  \n  return { ...book, author, categories };\n}\n\nfunction findCategoryWithBooks(categoryId) {\n  let category = database.categories.find(c => c.id === categoryId);\n  if (!category) return null;\n  \n  // Many-to-many: get all books in this category\n  let bookIds = database.bookCategories\n    .filter(bc => bc.categoryId === categoryId)\n    .map(bc => bc.bookId);\n  \n  let books = database.books.filter(b => bookIds.includes(b.id));\n  \n  // Include authors\n  books = books.map(book => {\n    let author = database.authors.find(a => a.id === book.authorId);\n    return { ...book, author };\n  });\n  \n  return { ...category, books };\n}\n\nfunction getStats() {\n  return {\n    totalAuthors: database.authors.length,\n    totalBooks: database.books.length,\n    totalCategories: database.categories.length,\n    averageBooksPerAuthor: (database.books.length / database.authors.length).toFixed(1)\n  };\n}\n\n// Test the relations\nconsole.log('=== Prisma Relations Simulator ===\\n');\n\nconsole.log('1. ONE-TO-MANY: Author with Books');\nconsole.log('Query: prisma.author.findUnique({ where: { id: 1 }, include: { books: true } })\\n');\nlet jkRowling = findAuthorWithBooks(1);\nconsole.log(JSON.stringify(jkRowling, null, 2));\n\nconsole.log('\\n2. MANY-TO-MANY: Book with Categories');\nconsole.log('Query: prisma.book.findUnique({ where: { id: 1 }, include: { categories: true } })\\n');\nlet hp1 = findBookWithRelations(1);\nconsole.log(JSON.stringify(hp1, null, 2));\n\nconsole.log('\\n3. MANY-TO-MANY REVERSE: Category with Books');\nconsole.log('Query: prisma.category.findUnique({ where: { id: 1 }, include: { books: true } })\\n');\nlet fantasy = findCategoryWithBooks(1);\nconsole.log(JSON.stringify(fantasy, null, 2));\n\nconsole.log('\\n4. Database Statistics');\nconsole.log(getStats());",
      "commonStickingPoints": "Common relation mistakes:\n\n1. **Forgetting foreign key field**:\n   ```prisma\n   // WRONG! Missing authorId\n   model Post {\n     id     Int  @id\n     author User @relation(fields: [authorId], references: [id])\n   }\n   \n   // CORRECT!\n   model Post {\n     id       Int  @id\n     authorId Int  // Foreign key field\n     author   User @relation(fields: [authorId], references: [id])\n   }\n   ```\n\n2. **Wrong array syntax**:\n   ```prisma\n   // WRONG!\n   model User {\n     posts Post  // Missing brackets!\n   }\n   \n   // CORRECT!\n   model User {\n     posts Post[]  // Array of posts\n   }\n   ```\n\n3. **Missing @relation name for many-to-many**:\n   ```prisma\n   // WRONG! Ambiguous relation\n   model User {\n     posts Post[]\n   }\n   model Post {\n     users User[]\n   }\n   \n   // CORRECT!\n   model User {\n     posts Post[] @relation(\"UserPosts\")\n   }\n   model Post {\n     users User[] @relation(\"UserPosts\")\n   }\n   ```\n\n4. **Not using @unique for one-to-one**:\n   ```prisma\n   // WRONG! This is one-to-many without @unique\n   model Profile {\n     userId Int\n     user   User @relation(fields: [userId], references: [id])\n   }\n   \n   // CORRECT! @unique makes it one-to-one\n   model Profile {\n     userId Int  @unique\n     user   User @relation(fields: [userId], references: [id])\n   }\n   ```\n\n5. **Forgetting include in queries**:\n   ```typescript\n   // WRONG! This doesn't include posts\n   const user = await prisma.user.findUnique({ where: { id: 1 } });\n   console.log(user.posts);  // undefined!\n   \n   // CORRECT!\n   const user = await prisma.user.findUnique({\n     where: { id: 1 },\n     include: { posts: true }\n   });\n   console.log(user.posts);  // Array of posts\n   ```\n\n6. **Cascade delete pitfalls**:\n   ```prisma\n   // DANGEROUS! Deleting user deletes all posts\n   model Post {\n     authorId Int\n     author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)\n   }\n   \n   // Better: Prevent deletion if posts exist\n   model Post {\n     authorId Int\n     author   User @relation(fields: [authorId], references: [id], onDelete: Restrict)\n   }\n   ```\n\n7. **Creating without connecting**:\n   ```typescript\n   // WRONG! Post needs an author\n   await prisma.post.create({\n     data: {\n       title: 'New Post'\n       // Missing author connection!\n     }\n   });\n   \n   // CORRECT!\n   await prisma.post.create({\n     data: {\n       title: 'New Post',\n       author: { connect: { id: 1 } }\n     }\n   });\n   ```\n\n8. **Self-relation confusion**:\n   ```prisma\n   // WRONG! Ambiguous self-relation\n   model User {\n     followers User[]\n     following User[]\n   }\n   \n   // CORRECT! Named relation\n   model User {\n     followers User[] @relation(\"UserFollows\")\n     following User[] @relation(\"UserFollows\")\n   }\n   ```\n\n9. **Not understanding implicit vs explicit many-to-many**:\n   ```prisma\n   // Implicit: Prisma manages join table\n   model User {\n     posts Post[] @relation(\"Likes\")\n   }\n   model Post {\n     likedBy User[] @relation(\"Likes\")\n   }\n   \n   // Explicit: You control join table (when you need extra fields)\n   model User {\n     likes Like[]\n   }\n   model Post {\n     likes Like[]\n   }\n   model Like {\n     userId Int\n     user   User @relation(fields: [userId], references: [id])\n     postId Int\n     post   Post @relation(fields: [postId], references: [id])\n     likedAt DateTime @default(now())  // Extra field!\n   }\n   ```\n\n10. **Relation filtering mistakes**:\n    ```typescript\n    // WRONG! Can't filter like this\n    const users = await prisma.user.findMany({\n      where: { posts.published: true }  // Error!\n    });\n    \n    // CORRECT! Use relation filters\n    const users = await prisma.user.findMany({\n      where: {\n        posts: {\n          some: { published: true }  // Users with at least one published post\n        }\n      }\n    });\n    ```"
    }
  ]
}
