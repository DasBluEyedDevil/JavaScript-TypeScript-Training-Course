{
  "id": 7,
  "title": "Module 7: Working with the Web Page (The 'Browser')",
  "description": "Make your code interact with HTML and create dynamic web pages",
  "goal": "Master DOM manipulation to create interactive web experiences",
  "lessons": [
    {
      "id": "7.1",
      "title": "The Three Layers of a Webpage (HTML, CSS, and JavaScript)",
      "conceptAnalogy": "Building a house has three distinct phases:\n\n**HTML (The Structure)**: This is like the wooden frame of a house - the walls, roof, floors. It defines WHAT exists (rooms, doors, windows) but not how they look or behave.\n\n**CSS (The Styling)**: This is like painting, decorating, choosing furniture. It makes the structure LOOK good - colors, fonts, layouts, spacing.\n\n**JavaScript (The Behavior)**: This is like the electrical wiring, plumbing, security system. It makes things WORK - lights turn on/off, doors lock/unlock, alarms sound.\n\nYou need all three! A house with just a frame is boring. A house with no wiring doesn't work. Together, they create a complete, functional, beautiful home.",
      "codeExample": "<!-- HTML: The structure (skeleton) -->\n<!DOCTYPE html>\n<html>\n<head>\n  <title>My Page</title>\n  <!-- CSS: The styling (clothes) -->\n  <style>\n    h1 {\n      color: blue;        /* Make heading blue */\n      font-size: 32px;    /* Make it big */\n    }\n    .highlight {\n      background-color: yellow;\n    }\n  </style>\n</head>\n<body>\n  <h1 id=\"title\">Hello, World!</h1>\n  <button id=\"myButton\">Click Me!</button>\n  <p id=\"message\"></p>\n\n  <!-- JavaScript: The behavior (brain) -->\n  <script>\n    // This code runs when the page loads\n    \n    // Find the button element\n    let button = document.getElementById('myButton');\n    \n    // Make something happen when button is clicked\n    button.addEventListener('click', function() {\n      // Find the message paragraph\n      let message = document.getElementById('message');\n      \n      // Change its text content\n      message.textContent = 'Button was clicked!';\n      \n      // Add styling class\n      message.className = 'highlight';\n    });\n  </script>\n</body>\n</html>",
      "syntaxBreakdown": "Understanding the three layers:\n\n**1. HTML (HyperText Markup Language)**\n- Defines the STRUCTURE and CONTENT\n- Uses tags: <tagname>content</tagname>\n- Common tags:\n  - <h1> to <h6>: Headings\n  - <p>: Paragraphs\n  - <div>: Generic container\n  - <button>: Clickable button\n  - <input>: Form input\n- Attributes give extra info:\n  - id=\"unique-name\" (unique identifier)\n  - class=\"style-class\" (styling group)\n\n**2. CSS (Cascading Style Sheets)**\n- Defines how HTML elements LOOK\n- Syntax: selector { property: value; }\n- Can be:\n  - Inline: <p style=\"color: red\">Text</p>\n  - Internal: <style> tags in <head>\n  - External: <link rel=\"stylesheet\" href=\"style.css\">\n- Selectors:\n  - h1 { } - All <h1> tags\n  - #myId { } - Element with id=\"myId\"\n  - .myClass { } - Elements with class=\"myClass\"\n\n**3. JavaScript (The Programming Language)**\n- Makes pages INTERACTIVE and DYNAMIC\n- Can:\n  - Find HTML elements\n  - Change their content\n  - Change their styling\n  - Respond to user actions (clicks, typing, etc.)\n  - Fetch data from servers\n  - Validate forms\n  - Animate elements\n\nHow they work together:\n1. HTML creates structure\n2. CSS makes it pretty\n3. JavaScript makes it interactive\n\nExample flow:\n1. User sees button (HTML)\n2. Button is styled blue (CSS)\n3. User clicks button (JavaScript detects)\n4. Message appears (JavaScript changes HTML)\n5. Message is highlighted (JavaScript adds CSS class)",
      "challenge": {
        "instructions": "You'll work with this HTML structure:\n\n<h1 id=\"heading\">Welcome</h1>\n<button id=\"changeButton\">Change Text</button>\n\nWrite JavaScript that:\n1. Finds the heading element (use document.getElementById)\n2. Finds the button element\n3. When button is clicked, change heading text to 'Hello, JavaScript!'",
        "starterCode": "// Find the heading element\nlet heading = document.getElementById('heading');\n\n// Find the button element\nlet button = document.getElementById('changeButton');\n\n// Add click event listener\nbutton.addEventListener('click', function() {\n  // YOUR CODE HERE: Change heading.textContent\n});",
        "testCases": [
          {
            "description": "Changes heading text on click",
            "input": "let heading = {textContent: 'Welcome'}; let button = {addEventListener: function(event, callback) { callback(); }}; button.addEventListener('click', function() { heading.textContent = 'Hello, JavaScript!'; }); console.log(heading.textContent);",
            "expectedOutput": "Hello, JavaScript!"
          }
        ],
        "hint": "Inside the click function, use: heading.textContent = 'Hello, JavaScript!';"
      },
      "solution": "let heading = document.getElementById('heading');\nlet button = document.getElementById('changeButton');\n\nbutton.addEventListener('click', function() {\n  heading.textContent = 'Hello, JavaScript!';\n});",
      "commonStickingPoints": "Common mistakes:\n\n1. Forgetting quotes around IDs:\n   document.getElementById(heading)  // WRONG - thinks heading is a variable\n   document.getElementById('heading')  // CORRECT - string literal\n\n2. Running JavaScript before HTML loads:\n   <script>document.getElementById('myButton')</script>\n   <button id=\"myButton\">Click</button>\n   The script runs before button exists! Put scripts at end of <body>\n\n3. Typos in IDs (case-sensitive!):\n   HTML: <div id=\"myDiv\"></div>\n   JS: document.getElementById('mydiv')  // WRONG - lowercase d\n   JS: document.getElementById('myDiv')  // CORRECT\n\n4. Confusing textContent, innerHTML, and value:\n   - textContent: Text only (safe, no HTML)\n   - innerHTML: HTML content (can be dangerous!)\n   - value: For form inputs (<input>, <textarea>)\n\n5. Forgetting to attach event listener:\n   button.addEventListener('click', myFunction)  // Correct\n   button.addEventListener('click', myFunction())  // WRONG - calls immediately!"
    },
    {
      "id": "7.2",
      "title": "The Browser's Live Blueprint (What Is the DOM?)",
      "conceptAnalogy": "Imagine you're building with LEGO blocks. You have the instruction manual (HTML code), but you also have the actual LEGO structure you've built (the DOM).\n\nThe **DOM (Document Object Model)** is the browser's LIVE representation of your webpage. It's not the HTML code itself - it's the browser's interpretation of that code, turned into a tree of objects that JavaScript can manipulate.\n\nThink of it like this:\n- **HTML**: Blueprint on paper (static text)\n- **DOM**: Actual LEGO construction (living, changeable structure)\n\nWhen you use JavaScript to change the DOM, you're rebuilding parts of the LEGO structure on the fly. The browser immediately shows your changes on screen.",
      "codeExample": "// The DOM is a tree structure\n// HTML:\n// <html>\n//   <body>\n//     <h1>Title</h1>\n//     <p>Paragraph</p>\n//   </body>\n// </html>\n//\n// Becomes this tree:\n// document\n//   └─ html\n//      └─ body\n//         ├─ h1 (\"Title\")\n//         └─ p (\"Paragraph\")\n\n// Accessing the DOM\nconsole.log(document);  // The entire page\nconsole.log(document.body);  // The <body> element\nconsole.log(document.title);  // Page title\n\n// Finding elements (we'll learn more about this next)\nlet element = document.getElementById('myId');\nlet elements = document.getElementsByClassName('myClass');\nlet firstDiv = document.querySelector('div');\nlet allDivs = document.querySelectorAll('div');\n\n// The DOM is LIVE - changes appear immediately\nlet heading = document.getElementById('title');\nheading.textContent = 'New Title';  // Page updates instantly!\n\n// DOM nodes have properties\nconsole.log(heading.tagName);  // 'H1'\nconsole.log(heading.id);  // 'title'\nconsole.log(heading.className);  // CSS classes\n\n// DOM nodes have relationships (tree structure)\nlet parent = heading.parentElement;  // Element above\nlet children = parent.children;  // Elements below\nlet nextSibling = heading.nextElementSibling;  // Next element at same level",
      "syntaxBreakdown": "Understanding the DOM:\n\n**What is the DOM?**\n- Browser's representation of the HTML page\n- Tree structure of objects\n- Each HTML element becomes a JavaScript object\n- You can read and modify these objects\n- Changes appear instantly on the page\n\n**DOM Tree Structure:**\n\nHTML:\n<body>\n  <div id=\"container\">\n    <h1>Title</h1>\n    <p>Text</p>\n  </div>\n</body>\n\nDOM Tree:\ndocument\n  └─ body\n     └─ div (id=\"container\")\n        ├─ h1 (\"Title\")\n        └─ p (\"Text\")\n\n**Key DOM Methods:**\n\n1. Finding single elements:\n   - document.getElementById('id')\n   - document.querySelector('selector')\n\n2. Finding multiple elements:\n   - document.getElementsByClassName('class')\n   - document.getElementsByTagName('tag')\n   - document.querySelectorAll('selector')\n\n3. Element properties:\n   - element.textContent (text only)\n   - element.innerHTML (HTML content)\n   - element.value (for inputs)\n   - element.id (element's ID)\n   - element.className (CSS classes)\n   - element.style (inline CSS)\n\n4. Tree navigation:\n   - element.parentElement (parent)\n   - element.children (child elements)\n   - element.nextElementSibling (next)\n   - element.previousElementSibling (previous)\n\n**Important Concepts:**\n\n1. The DOM is LIVE\n   - Changes happen immediately\n   - No need to \"refresh\" or \"save\"\n\n2. Elements are objects\n   - They have properties you can read/write\n   - They have methods you can call\n\n3. Everything is a node\n   - Elements, text, comments, etc.\n   - Forms a tree structure\n\n4. querySelector is modern and flexible\n   - Uses CSS selectors\n   - More powerful than getElementBy...\n   - We'll use this primarily",
      "challenge": {
        "instructions": "Given this HTML:\n<div id=\"container\">\n  <h1 id=\"title\">Original Title</h1>\n  <p id=\"description\">Original description</p>\n</div>\n\nWrite JavaScript that:\n1. Finds the container div\n2. Finds the title h1\n3. Finds the description p\n4. Change title to 'Updated Title'\n5. Change description to 'Updated description'\n6. Log the container's number of children",
        "starterCode": "// Find the elements\nlet container = // YOUR CODE\nlet title = // YOUR CODE\nlet description = // YOUR CODE\n\n// Update content\n// YOUR CODE\n\n// Log number of children\nconsole.log(container.children.length);",
        "testCases": [
          {
            "description": "Updates both elements correctly",
            "input": "let container = {children: {length: 2}}; let title = {textContent: 'Original'}; let description = {textContent: 'Original'}; title.textContent = 'Updated Title'; description.textContent = 'Updated description'; console.log(container.children.length);",
            "expectedOutput": "2"
          }
        ],
        "hint": "Use document.getElementById('id') for each element"
      },
      "solution": "let container = document.getElementById('container');\nlet title = document.getElementById('title');\nlet description = document.getElementById('description');\n\ntitle.textContent = 'Updated Title';\ndescription.textContent = 'Updated description';\n\nconsole.log(container.children.length);  // 2",
      "commonStickingPoints": "Common mistakes:\n\n1. Confusing the DOM with HTML:\n   - HTML: Static code you write\n   - DOM: Live structure in browser\n   - Changing HTML file doesn't change running page\n   - Changing DOM changes page immediately\n\n2. Null reference errors:\n   let element = document.getElementById('wrong-id');\n   element.textContent = 'Hi';  // ERROR - element is null!\n   \n   Always check:\n   if (element !== null) {\n     element.textContent = 'Hi';\n   }\n\n3. Mixing up textContent and innerHTML:\n   element.textContent = '<b>Bold</b>';  // Shows literal <b> tags\n   element.innerHTML = '<b>Bold</b>';  // Renders as bold\n   \n   Use textContent for safety (prevents XSS attacks)\n\n4. Timing issues:\n   If JavaScript runs before HTML loads, elements don't exist yet\n   Solution: Put <script> at end of <body> or use DOMContentLoaded event\n\n5. getElementsByClassName returns collection, not array:\n   let items = document.getElementsByClassName('item');\n   items.forEach(...)  // ERROR - not an array!\n   Array.from(items).forEach(...)  // Correct"
    },
    {
      "id": "7.3",
      "title": "Finding Elements on the Page (querySelector)",
      "conceptAnalogy": "Imagine you're in a huge library looking for books:\n\n**Old way** (getElementById, getElementsByClassName): You can only search by:\n- Call number (ID): \"Find book #12345\"\n- Category (class): \"Find all books in Science section\"\n\n**New way** (querySelector): You can search by ANYTHING:\n- \"Find the first red book on the third shelf\"\n- \"Find all books by Author X with 'JavaScript' in the title\"\n- \"Find the book inside the Special Collections room\"\n\nquerySelector uses CSS selectors, which means you can find elements in incredibly flexible ways. It's like having a super-powered library search system!",
      "codeExample": "// querySelector finds the FIRST match\n// querySelectorAll finds ALL matches\n\n// By ID (same as getElementById, but with # prefix)\nlet title = document.querySelector('#title');\n\n// By class (same as getElementsByClassName, but with . prefix)\nlet firstItem = document.querySelector('.item');\nlet allItems = document.querySelectorAll('.item');\n\n// By tag name\nlet firstParagraph = document.querySelector('p');\nlet allParagraphs = document.querySelectorAll('p');\n\n// By attribute\nlet input = document.querySelector('[type=\"email\"]');\nlet required = document.querySelectorAll('[required]');\n\n// Combining selectors\nlet redButton = document.querySelector('button.red');\nlet containerDiv = document.querySelector('div#container');\n\n// Descendant selectors (inside)\nlet linkInNav = document.querySelector('nav a');\nlet itemsInList = document.querySelectorAll('ul.menu li');\n\n// Direct children (>)\nlet directChild = document.querySelector('div > p');\n\n// Pseudo-selectors\nlet firstChild = document.querySelector('li:first-child');\nlet lastChild = document.querySelector('li:last-child');\nlet evenItems = document.querySelectorAll('li:nth-child(even)');\n\n// Complex example\nlet specificButton = document.querySelector('div.container button.primary:not(.disabled)');\n// Finds: button with class 'primary', inside div with class 'container', not having class 'disabled'\n\n// querySelectorAll returns NodeList (array-like)\nlet buttons = document.querySelectorAll('button');\nconsole.log(buttons.length);  // Number of buttons\nbuttons.forEach(btn => {\n  console.log(btn.textContent);\n});",
      "syntaxBreakdown": "querySelector syntax (uses CSS selectors):\n\n**Basic Selectors:**\n\n1. By ID: #idName\n   document.querySelector('#myId')\n   // Same as: document.getElementById('myId')\n\n2. By class: .className\n   document.querySelector('.myClass')\n   document.querySelectorAll('.myClass')  // All matches\n\n3. By tag: tagname\n   document.querySelector('p')\n   document.querySelectorAll('div')\n\n4. By attribute: [attribute]\n   document.querySelector('[href]')  // Has href attribute\n   document.querySelector('[type=\"submit\"]')  // type=\"submit\"\n\n**Combinators:**\n\n1. Descendant: space (anywhere inside)\n   document.querySelector('div p')  // p inside any div\n\n2. Direct child: >\n   document.querySelector('div > p')  // p directly inside div\n\n3. Multiple selectors: comma\n   document.querySelectorAll('h1, h2, h3')  // All headings\n\n4. Combined: no space\n   document.querySelector('button.primary')  // button with class 'primary'\n\n**Pseudo-selectors:**\n\n1. :first-child, :last-child\n2. :nth-child(n) - The nth child\n3. :nth-child(even), :nth-child(odd)\n4. :not(selector) - Exclude matches\n5. :hover, :focus, :checked (for CSS, less useful in JS)\n\n**Differences from getElementBy...:**\n\nquerySelector:\n✓ More flexible (any CSS selector)\n✓ Consistent syntax\n✓ Returns null if not found\n✓ Modern and recommended\n✗ Slightly slower (negligible)\n\ngetElementBy...:\n✓ Slightly faster\n✓ Returns live collections (auto-updates)\n✗ Limited to ID, class, or tag\n✗ Different syntax for each\n\n**Best Practice:**\nUse querySelector/querySelectorAll for everything. They're more powerful and the syntax is consistent.\n\n**NodeList vs Array:**\nquerySelectorAll returns a NodeList (not an Array)\n- Has .length\n- Has .forEach() (modern browsers)\n- Doesn't have .map(), .filter(), etc.\n\nConvert to array if needed:\nlet itemsArray = Array.from(document.querySelectorAll('.item'));",
      "challenge": {
        "instructions": "Given this HTML:\n<nav>\n  <ul class=\"menu\">\n    <li class=\"item\">Home</li>\n    <li class=\"item active\">About</li>\n    <li class=\"item\">Contact</li>\n  </ul>\n</nav>\n<div class=\"content\">\n  <button class=\"primary\">Save</button>\n  <button class=\"secondary\">Cancel</button>\n</div>\n\nWrite JavaScript using querySelector to:\n1. Find the active menu item\n2. Find all menu items\n3. Find the primary button\n4. Find all buttons\n5. Log the text of the active item",
        "starterCode": "// Find the active menu item\nlet activeItem = document.querySelector(/* YOUR SELECTOR */);\n\n// Find all menu items\nlet allItems = document.querySelectorAll(/* YOUR SELECTOR */);\n\n// Find the primary button\nlet primaryButton = document.querySelector(/* YOUR SELECTOR */);\n\n// Find all buttons\nlet allButtons = document.querySelectorAll(/* YOUR SELECTOR */);\n\n// Log the active item text\nconsole.log(activeItem.textContent);",
        "testCases": [
          {
            "description": "Finds active item correctly",
            "input": "let activeItem = {textContent: 'About', className: 'item active'}; console.log(activeItem.textContent);",
            "expectedOutput": "About"
          }
        ],
        "hint": "Use '.item.active' for active item, '.item' for all items, '.primary' for primary button, 'button' for all buttons"
      },
      "solution": "let activeItem = document.querySelector('.item.active');\nlet allItems = document.querySelectorAll('.item');\nlet primaryButton = document.querySelector('.primary');\nlet allButtons = document.querySelectorAll('button');\n\nconsole.log(activeItem.textContent);  // About",
      "commonStickingPoints": "Common mistakes:\n\n1. Forgetting the . or # prefix:\n   document.querySelector('myClass')  // WRONG - looks for <myClass> tag\n   document.querySelector('.myClass')  // CORRECT - looks for class\n\n2. Expecting querySelectorAll to be an array:\n   let items = document.querySelectorAll('.item');\n   items.map(...)  // ERROR - NodeList doesn't have map\n   \n   Convert first:\n   Array.from(items).map(...)\n   // Or use forEach (works on NodeList):\n   items.forEach(...)\n\n3. Confusing querySelector with querySelectorAll:\n   querySelector returns: first match or null\n   querySelectorAll returns: NodeList of all matches (can be empty)\n\n4. Complex selectors with typos:\n   'div.container button.primary'  // Correct\n   'div .container button .primary'  // WRONG - extra spaces change meaning\n\n5. Not checking for null:\n   let element = document.querySelector('.doesnt-exist');\n   element.textContent = 'Hi';  // ERROR - element is null!\n   \n   Always check:\n   if (element) {\n     element.textContent = 'Hi';\n   }"
    },
    {
      "id": "7.4",
      "title": "Changing What Users See (Modifying .textContent and .style)",
      "conceptAnalogy": "Imagine you have a puppet theater:\n\n**textContent**: This is like changing what the puppet SAYS. You're swapping out the dialogue.\n\n**style**: This is like changing what the puppet WEARS or how it LOOKS. You're changing the costume, makeup, lighting.\n\nJavaScript lets you be the puppeteer - you can change what elements say (their text) and how they look (their styling) on the fly, creating a dynamic, interactive show for your users.",
      "codeExample": "// Changing text content\nlet heading = document.querySelector('h1');\nheading.textContent = 'New Heading';\n\nlet paragraph = document.querySelector('p');\nparagraph.textContent = 'New paragraph text';\n\n// Changing inline styles (CSS properties)\nlet box = document.querySelector('.box');\nbox.style.color = 'red';  // Text color\nbox.style.backgroundColor = 'yellow';  // Background (note camelCase!)\nbox.style.fontSize = '24px';  // Font size\nbox.style.width = '200px';  // Width\nbox.style.padding = '20px';  // Padding\nbox.style.border = '2px solid black';  // Border\n\n// CSS properties with hyphens become camelCase in JavaScript\n// CSS: background-color → JavaScript: backgroundColor\n// CSS: font-size → JavaScript: fontSize\n// CSS: margin-top → JavaScript: marginTop\n\n// Working with classes (better than inline styles!)\nlet element = document.querySelector('.item');\n\n// Add a class\nelement.classList.add('active');\n\n// Remove a class\nelement.classList.remove('inactive');\n\n// Toggle a class (add if missing, remove if present)\nelement.classList.toggle('highlighted');\n\n// Check if class exists\nif (element.classList.contains('active')) {\n  console.log('Element is active');\n}\n\n// Practical example: Dark mode toggle\nlet button = document.querySelector('#darkModeBtn');\nbutton.addEventListener('click', function() {\n  document.body.classList.toggle('dark-mode');\n});\n\n// Changing multiple styles at once\nlet card = document.querySelector('.card');\nObject.assign(card.style, {\n  width: '300px',\n  height: '200px',\n  backgroundColor: '#f0f0f0',\n  borderRadius: '10px',\n  padding: '20px'\n});\n\n// Getting current styles\nlet computedStyle = window.getComputedStyle(element);\nconsole.log(computedStyle.color);  // Current color",
      "syntaxBreakdown": "Modifying DOM elements:\n\n**1. Changing Text Content:**\n\n// textContent (recommended - safe, text only)\nelement.textContent = 'New text';\n\n// innerHTML (can include HTML, but risky!)\nelement.innerHTML = '<b>Bold text</b>';\n\n// innerText (similar to textContent, but respects CSS visibility)\nelement.innerText = 'New text';\n\n**Best practice**: Use textContent unless you specifically need HTML\n\n**2. Changing Inline Styles:**\n\nelement.style.propertyName = 'value';\n\nKey points:\n- CSS properties with hyphens become camelCase\n- Values are strings (include units: '20px', '50%')\n- This adds inline styles (highest priority)\n\nExamples:\nCSS Property        → JavaScript Property\ncolor               → color\nbackground-color    → backgroundColor\nfont-size           → fontSize\nmargin-top          → marginTop\nborder-radius       → borderRadius\nz-index             → zIndex\n\n**3. Working with Classes (Preferred Method):**\n\n// classList provides methods to manipulate classes\nelement.classList.add('class1', 'class2');\nelement.classList.remove('class1');\nelement.classList.toggle('class1');  // Add if missing, remove if present\nelement.classList.contains('class1');  // Returns true/false\nelement.classList.replace('old', 'new');\n\n// Old way (not recommended):\nelement.className = 'class1 class2';  // Replaces all classes\n\n**Why use classes instead of inline styles?**\n\n✓ Separation of concerns (CSS in CSS, JS in JS)\n✓ Easier to maintain\n✓ Can change multiple properties at once\n✓ Better performance\n✓ CSS can be cached\n✓ Easier to override\n\nExample:\n// Instead of:\nelement.style.color = 'red';\nelement.style.fontWeight = 'bold';\nelement.style.fontSize = '20px';\n\n// Do this:\nelement.classList.add('error');\n\n// And in CSS:\n.error {\n  color: red;\n  font-weight: bold;\n  font-size: 20px;\n}\n\n**4. Reading Styles:**\n\n// Inline styles only\nelement.style.color  // Only returns inline styles\n\n// All computed styles (including CSS)\nlet styles = window.getComputedStyle(element);\nstyles.color\nstyles.fontSize",
      "challenge": {
        "instructions": "Create an interactive element:\n\n<div id=\"box\" class=\"normal\">Click Me!</div>\n\nWrite JavaScript that:\n1. Finds the box\n2. When clicked, toggles a 'highlighted' class\n3. Also changes the textContent to show if it's highlighted or normal\n\nCSS (already defined):\n.normal { background: gray; }\n.highlighted { background: yellow; }",
        "starterCode": "let box = document.querySelector('#box');\n\nbox.addEventListener('click', function() {\n  // Toggle the highlighted class\n  \n  // Check if highlighted and update text\n  if (box.classList.contains('highlighted')) {\n    box.textContent = 'Highlighted!';\n  } else {\n    box.textContent = 'Click Me!';\n  }\n});",
        "testCases": [
          {
            "description": "Toggles class and updates text",
            "input": "let box = {classList: {toggle: function(c) { this.highlighted = !this.highlighted; }, contains: function(c) { return this.highlighted; }, highlighted: false}, textContent: ''}; box.addEventListener = function(e, cb) { cb(); cb(); }; box.addEventListener('click', function() { box.classList.toggle('highlighted'); if (box.classList.contains('highlighted')) { box.textContent = 'Highlighted!'; } else { box.textContent = 'Click Me!'; } }); console.log(box.textContent);",
            "expectedOutput": "Click Me!"
          }
        ],
        "hint": "Use box.classList.toggle('highlighted') and box.classList.contains('highlighted')"
      },
      "solution": "let box = document.querySelector('#box');\n\nbox.addEventListener('click', function() {\n  box.classList.toggle('highlighted');\n  \n  if (box.classList.contains('highlighted')) {\n    box.textContent = 'Highlighted!';\n  } else {\n    box.textContent = 'Click Me!';\n  }\n});",
      "commonStickingPoints": "Common mistakes:\n\n1. Forgetting camelCase for CSS properties:\n   element.style.background-color = 'red';  // SYNTAX ERROR\n   element.style.backgroundColor = 'red';  // CORRECT\n\n2. Forgetting units:\n   element.style.width = 200;  // WRONG - no effect\n   element.style.width = '200px';  // CORRECT\n\n3. Overusing inline styles instead of classes:\n   Bad:\n   element.style.color = 'red';\n   element.style.fontWeight = 'bold';\n   \n   Better:\n   element.classList.add('error');\n   // Define .error in CSS\n\n4. Confusing textContent, innerHTML, and innerText:\n   textContent: Safest, pure text\n   innerHTML: Can include HTML (security risk if user input!)\n   innerText: Respects CSS (slower)\n\n5. Not checking if element exists:\n   let el = document.querySelector('.missing');\n   el.textContent = 'Hi';  // ERROR if el is null!\n   \n   Always check:\n   if (el) {\n     el.textContent = 'Hi';\n   }"
    },
    {
      "id": "7.5",
      "title": "Responding to User Actions (Event Listeners)",
      "conceptAnalogy": "Imagine you're a security guard at a building:\n\nYou're not actively doing anything most of the time - you're LISTENING and WAITING for specific events to happen:\n\n- **Event**: Someone presses the doorbell → **Response**: You open the door\n- **Event**: Fire alarm goes off → **Response**: You evacuate everyone\n- **Event**: Someone tries wrong password 3 times → **Response**: You lock them out\n\nEvent listeners work the same way. Your JavaScript code sits idle, LISTENING for specific events (clicks, key presses, mouse movements, etc.). When an event happens, your code RESPONDS by running a function.",
      "codeExample": "// Basic event listener\nlet button = document.querySelector('#myButton');\n\nbutton.addEventListener('click', function() {\n  console.log('Button was clicked!');\n});\n\n// Common events\nlet input = document.querySelector('#nameInput');\n\n// 'input' fires when user types\ninput.addEventListener('input', function(event) {\n  console.log('User typed:', event.target.value);\n});\n\n// 'change' fires when input loses focus after being changed\ninput.addEventListener('change', function(event) {\n  console.log('Input changed to:', event.target.value);\n});\n\n// 'focus' fires when element receives focus\ninput.addEventListener('focus', function() {\n  console.log('Input focused');\n});\n\n// 'blur' fires when element loses focus\ninput.addEventListener('blur', function() {\n  console.log('Input lost focus');\n});\n\n// Mouse events\nlet box = document.querySelector('.box');\n\nbox.addEventListener('mouseenter', function() {\n  console.log('Mouse entered box');\n});\n\nbox.addEventListener('mouseleave', function() {\n  console.log('Mouse left box');\n});\n\nbox.addEventListener('mousemove', function(event) {\n  console.log('Mouse position:', event.clientX, event.clientY);\n});\n\n// Keyboard events\ndocument.addEventListener('keydown', function(event) {\n  console.log('Key pressed:', event.key);\n  \n  if (event.key === 'Enter') {\n    console.log('Enter key pressed!');\n  }\n});\n\n// Form events\nlet form = document.querySelector('#myForm');\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();  // Prevent default form submission\n  console.log('Form submitted');\n  \n  // Get form data\n  let formData = new FormData(form);\n  console.log(formData.get('username'));\n});\n\n// Event object\nbutton.addEventListener('click', function(event) {\n  console.log('Event type:', event.type);  // 'click'\n  console.log('Target element:', event.target);  // The button\n  console.log('Mouse position:', event.clientX, event.clientY);\n});\n\n// Removing event listeners\nfunction handleClick() {\n  console.log('Clicked!');\n}\n\nbutton.addEventListener('click', handleClick);\nbutton.removeEventListener('click', handleClick);  // Must be same function\n\n// Multiple listeners on same event\nbutton.addEventListener('click', function() {\n  console.log('First listener');\n});\n\nbutton.addEventListener('click', function() {\n  console.log('Second listener');\n});\n// Both run when button is clicked!",
      "syntaxBreakdown": "Event listeners syntax:\n\nelement.addEventListener(eventType, callbackFunction);\n│                        │          │\n│                        │          └─ Function to run when event fires\n│                        └──────────── Type of event to listen for\n└───────────────────────────────────── Element to listen on\n\n**Common Event Types:**\n\nMouse Events:\n- 'click' - Element is clicked\n- 'dblclick' - Element is double-clicked\n- 'mouseenter' - Mouse enters element\n- 'mouseleave' - Mouse leaves element\n- 'mousemove' - Mouse moves over element\n- 'mousedown' - Mouse button pressed\n- 'mouseup' - Mouse button released\n\nKeyboard Events:\n- 'keydown' - Key is pressed down\n- 'keyup' - Key is released\n- 'keypress' - Key is pressed (deprecated, use keydown)\n\nForm Events:\n- 'submit' - Form is submitted\n- 'input' - Input value changes (real-time)\n- 'change' - Input value changes (on blur)\n- 'focus' - Element receives focus\n- 'blur' - Element loses focus\n\nWindow/Document Events:\n- 'load' - Page fully loaded\n- 'DOMContentLoaded' - HTML loaded (before images)\n- 'resize' - Window resized\n- 'scroll' - Page scrolled\n\n**Event Object:**\n\nThe callback receives an event object:\n\nelement.addEventListener('click', function(event) {\n  // event contains information about the event\n});\n\nUseful properties:\n- event.type - Type of event ('click', 'keydown', etc.)\n- event.target - Element that triggered the event\n- event.currentTarget - Element the listener is attached to\n- event.key - Key that was pressed (keyboard events)\n- event.clientX, event.clientY - Mouse position\n- event.preventDefault() - Prevent default behavior\n- event.stopPropagation() - Stop event bubbling\n\n**Preventing Defaults:**\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();  // Stop form from actually submitting\n  // Handle with JavaScript instead\n});\n\nlink.addEventListener('click', function(event) {\n  event.preventDefault();  // Stop link from navigating\n  // Do something else\n});\n\n**Arrow Functions:**\n\n// Traditional function\nelement.addEventListener('click', function() {\n  console.log('Clicked');\n});\n\n// Arrow function (more modern)\nelement.addEventListener('click', () => {\n  console.log('Clicked');\n});\n\n// With event parameter\nelement.addEventListener('click', (event) => {\n  console.log(event.target);\n});",
      "challenge": {
        "instructions": "Create an interactive form validator:\n\n<form id=\"signupForm\">\n  <input type=\"text\" id=\"username\" placeholder=\"Username\">\n  <input type=\"email\" id=\"email\" placeholder=\"Email\">\n  <button type=\"submit\">Sign Up</button>\n  <p id=\"message\"></p>\n</form>\n\nWrite JavaScript that:\n1. When the form is submitted, prevent default behavior\n2. Get the username and email values\n3. If username is empty, show error message\n4. If email doesn't contain '@', show error message\n5. If both valid, show success message",
        "starterCode": "let form = document.querySelector('#signupForm');\nlet message = document.querySelector('#message');\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();\n  \n  let username = document.querySelector('#username').value;\n  let email = document.querySelector('#email').value;\n  \n  // YOUR CODE HERE\n  // Check if username is empty\n  // Check if email contains '@'\n  // Show appropriate message\n});",
        "testCases": [
          {
            "description": "Validates empty username",
            "input": "let message = {textContent: ''}; let username = ''; let email = 'test@test.com'; if (username === '') { message.textContent = 'Username required'; } else if (!email.includes('@')) { message.textContent = 'Invalid email'; } else { message.textContent = 'Success!'; } console.log(message.textContent);",
            "expectedOutput": "Username required"
          }
        ],
        "hint": "Use if/else to check: username === '' and !email.includes('@')"
      },
      "solution": "let form = document.querySelector('#signupForm');\nlet message = document.querySelector('#message');\n\nform.addEventListener('submit', function(event) {\n  event.preventDefault();\n  \n  let username = document.querySelector('#username').value;\n  let email = document.querySelector('#email').value;\n  \n  if (username === '') {\n    message.textContent = 'Username is required';\n    message.style.color = 'red';\n  } else if (!email.includes('@')) {\n    message.textContent = 'Please enter a valid email';\n    message.style.color = 'red';\n  } else {\n    message.textContent = 'Sign up successful!';\n    message.style.color = 'green';\n  }\n});",
      "commonStickingPoints": "Common mistakes:\n\n1. Calling the function immediately:\n   button.addEventListener('click', myFunction());  // WRONG - runs now!\n   button.addEventListener('click', myFunction);  // CORRECT - runs on click\n\n2. Forgetting event.preventDefault() for forms:\n   form.addEventListener('submit', function(event) {\n     // Form submits and page reloads before your code runs!\n   });\n   \n   Must prevent default:\n   form.addEventListener('submit', function(event) {\n     event.preventDefault();  // Now your code can run\n   });\n\n3. Confusing input vs change:\n   'input' - Fires on every keystroke (real-time)\n   'change' - Fires when field loses focus (final value)\n\n4. Not getting input values correctly:\n   let value = input;  // WRONG - this is the element!\n   let value = input.value;  // CORRECT - this is the text\n\n5. Trying to remove anonymous function:\n   element.addEventListener('click', function() { });\n   element.removeEventListener('click', function() { });  // Doesn't work!\n   \n   Must use named function:\n   function handleClick() { }\n   element.addEventListener('click', handleClick);\n   element.removeEventListener('click', handleClick);  // Works!\n\n6. Forgetting 'this' context in arrow functions:\n   // Traditional function: 'this' is the element\n   button.addEventListener('click', function() {\n     console.log(this);  // The button\n   });\n   \n   // Arrow function: 'this' is lexical scope\n   button.addEventListener('click', () => {\n     console.log(this);  // NOT the button!\n   });"
    }
  ]
}
