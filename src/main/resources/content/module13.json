{
  "id": "13",
  "title": "Module 13: Full-Stack Integration - Connecting Front-End & Back-End",
  "description": "Build complete full-stack applications by connecting React front-ends with Node.js/Express backends and Prisma databases",
  "goal": "Create production-ready full-stack applications with authentication, data persistence, and modern architecture",
  "lessons": [
    {
      "id": "13.1",
      "title": "Full-Stack Architecture (The Restaurant Analogy)",
      "conceptAnalogy": "A restaurant has three main areas:\n\nDining Room (Front-End - React):\n- Where customers sit and interact\n- Beautiful presentation, easy to use\n- Menus, ordering interface, displays\n\nKitchen (Back-End - Node.js/Express):\n- Where the real work happens\n- Receives orders, processes them\n- Business logic, data processing\n\nStorage Room (Database - Prisma/PostgreSQL):\n- Where ingredients are stored\n- Organized, persistent, reliable\n- Data that survives shutdowns\n\nWaiter (API):\n- Carries messages between dining room and kitchen\n- Takes orders from customers to chefs\n- Brings food from kitchen to customers\n\nFull-stack development means building ALL THREE parts and making them work together seamlessly!",
      "codeExample": "// Full-Stack Architecture Overview (MERN/PERN Stack)\n\n// FRONTEND (React) - What users see\nlet frontEnd = {\n  technology: 'React 19',\n  responsibilities: [\n    'User interface (buttons, forms, displays)',\n    'User interactions (clicks, typing)',\n    'API calls to backend',\n    'Display data from backend'\n  ],\n  example: 'Login form, dashboard, user profile page'\n};\n\nconsole.log('Frontend:', frontEnd);\n\n// BACKEND (Node.js + Express) - Business logic\nlet backEnd = {\n  technology: 'Node.js 24 + Express 5.1',\n  responsibilities: [\n    'API endpoints (routes)',\n    'Authentication & authorization',\n    'Business logic (validation, calculations)',\n    'Database operations',\n    'Security'\n  ],\n  example: 'POST /api/login, GET /api/users, PUT /api/profile'\n};\n\nconsole.log('\\nBackend:', backEnd);\n\n// DATABASE (PostgreSQL + Prisma) - Data storage\nlet database = {\n  technology: 'PostgreSQL + Prisma ORM',\n  responsibilities: [\n    'Store data persistently',\n    'Relationships between data',\n    'Query optimization',\n    'Data integrity'\n  ],\n  example: 'Users table, Posts table, Comments table'\n};\n\nconsole.log('\\nDatabase:', database);\n\n// HOW THEY COMMUNICATE (Example flow)\nconsole.log('\\n=== Full-Stack Data Flow ===\\n');\n\nfunction simulateFullStackFlow() {\n  console.log('1. USER ACTION: User clicks \"Login\" button in React');\n  console.log('   Frontend: <button onClick={handleLogin}>Login</button>');\n  \n  console.log('\\n2. FRONTEND: React sends HTTP request to backend');\n  console.log('   fetch(\"/api/login\", { method: \"POST\", body: { email, password } })');\n  \n  console.log('\\n3. BACKEND: Express receives request at route');\n  console.log('   app.post(\"/api/login\", async (req, res) => { ... })');\n  \n  console.log('\\n4. BACKEND: Queries database via Prisma');\n  console.log('   const user = await prisma.user.findUnique({ where: { email } });');\n  \n  console.log('\\n5. DATABASE: Returns user data to backend');\n  console.log('   { id: 1, email: \"user@example.com\", name: \"Alice\" }');\n  \n  console.log('\\n6. BACKEND: Sends JSON response to frontend');\n  console.log('   res.json({ success: true, user: { id: 1, name: \"Alice\" } });');\n  \n  console.log('\\n7. FRONTEND: React receives data and updates UI');\n  console.log('   setUser(data.user); // State update triggers re-render');\n  \n  console.log('\\n8. USER SEES: Dashboard with their name displayed');\n  console.log('   <h1>Welcome, {user.name}!</h1>');\n}\n\nsimulateFullStackFlow();\n\n// TECH STACK OPTIONS\nlet stacks = {\n  MERN: 'MongoDB + Express + React + Node.js',\n  PERN: 'PostgreSQL + Express + React + Node.js (recommended)',\n  MEAN: 'MongoDB + Express + Angular + Node.js',\n  'T3 Stack': 'TypeScript + tRPC + Tailwind + Prisma + Next.js'\n};\n\nconsole.log('\\nPopular Full-Stack Combinations:');\nfor (let [name, stack] of Object.entries(stacks)) {\n  console.log(`${name}: ${stack}`);\n}\n\nconsole.log('\\nWe\\'ll use: PERN + TypeScript + Prisma (modern, type-safe)');",
      "syntaxBreakdown": "Full-Stack architecture explained:\n\n1. **Frontend (Client-Side)**:\n   - Runs in user's browser\n   - React components, HTML, CSS, JavaScript\n   - Makes HTTP requests to backend\n   - Port 3000 (development)\n\n2. **Backend (Server-Side)**:\n   - Runs on server (Node.js)\n   - Express routes handle requests\n   - Connects to database\n   - Port 4000 or 5000 (development)\n\n3. **Database**:\n   - PostgreSQL server\n   - Stores all application data\n   - Accessed via Prisma ORM\n   - Port 5432 (default)\n\n4. **Communication (HTTP/REST)**:\n   ```javascript\n   // Frontend makes request\n   fetch('http://localhost:4000/api/users')\n     .then(res => res.json())\n     .then(users => setUsers(users));\n   \n   // Backend handles request\n   app.get('/api/users', async (req, res) => {\n     const users = await prisma.user.findMany();\n     res.json(users);\n   });\n   ```\n\n5. **CORS** (Cross-Origin Resource Sharing):\n   - Frontend and backend on different ports = different origins\n   - Need to enable CORS on backend:\n   ```javascript\n   import cors from 'cors';\n   app.use(cors());\n   ```\n\n6. **Environment Variables**:\n   - Frontend: VITE_API_URL=http://localhost:4000\n   - Backend: DATABASE_URL=postgresql://...\n   - Never commit secrets to Git!",
      "challenge": {
        "instructions": "Simulate a full-stack data flow:\n\n1. Create a `frontend` object with a method `fetchUsers()` that:\n   - Logs \"Sending GET request to /api/users\"\n   - Calls backend.handleGetUsers()\n   - Logs the result\n\n2. Create a `backend` object with method `handleGetUsers()` that:\n   - Logs \"Backend received request\"\n   - Calls database.getUsers()\n   - Returns the result\n\n3. Create a `database` object with method `getUsers()` that:\n   - Returns array of mock users\n\nTest the complete flow.",
        "starterCode": "// Database layer\nlet database = {\n  users: [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' }\n  ],\n  \n  getUsers() {\n    console.log('[Database] Querying users table');\n    return this.users;\n  }\n};\n\n// Backend layer\nlet backend = {\n  handleGetUsers() {\n    console.log('[Backend] Received GET /api/users');\n    let users = database.getUsers();\n    console.log('[Backend] Sending response:', users.length, 'users');\n    return users;\n  }\n};\n\n// Frontend layer  \nlet frontend = {\n  fetchUsers() {\n    console.log('[Frontend] Fetching users from API');\n    let users = backend.handleGetUsers();\n    console.log('[Frontend] Received users:', users);\n    return users;\n  }\n};\n\n// Test the full stack\nconsole.log('=== Full-Stack Simulation ===\\n');\nfrontend.fetchUsers();",
        "testCases": [
          {
            "description": "Should simulate complete flow",
            "input": "let users = [{ id: 1, name: 'Test' }]; users.length",
            "expectedOutput": "1"
          }
        ],
        "hint": "Chain the method calls: frontend → backend → database → backend → frontend"
      },
      "solution": "// Complete full-stack simulation\n\n// Database layer\nlet database = {\n  users: [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' },\n    { id: 3, name: 'Charlie', email: 'charlie@example.com' }\n  ],\n  \n  getUsers() {\n    console.log('[Database] Executing: SELECT * FROM users');\n    return this.users;\n  },\n  \n  getUserById(id) {\n    console.log(`[Database] Executing: SELECT * FROM users WHERE id = ${id}`);\n    return this.users.find(u => u.id === id);\n  },\n  \n  createUser(name, email) {\n    console.log(`[Database] Executing: INSERT INTO users (name, email) VALUES ('${name}', '${email}')`);\n    let newUser = { id: this.users.length + 1, name, email };\n    this.users.push(newUser);\n    return newUser;\n  }\n};\n\n// Backend layer\nlet backend = {\n  handleGetUsers() {\n    console.log('[Backend] GET /api/users');\n    let users = database.getUsers();\n    console.log(`[Backend] Response: 200 OK (${users.length} users)`);\n    return { status: 200, data: users };\n  },\n  \n  handleGetUser(id) {\n    console.log(`[Backend] GET /api/users/${id}`);\n    let user = database.getUserById(id);\n    if (user) {\n      console.log('[Backend] Response: 200 OK');\n      return { status: 200, data: user };\n    } else {\n      console.log('[Backend] Response: 404 Not Found');\n      return { status: 404, error: 'User not found' };\n    }\n  },\n  \n  handleCreateUser(name, email) {\n    console.log(`[Backend] POST /api/users`);\n    let newUser = database.createUser(name, email);\n    console.log('[Backend] Response: 201 Created');\n    return { status: 201, data: newUser };\n  }\n};\n\n// Frontend layer\nlet frontend = {\n  state: { users: [], currentUser: null },\n  \n  async fetchUsers() {\n    console.log('[Frontend] User clicked \"View Users\" button');\n    console.log('[Frontend] fetch(\"http://localhost:4000/api/users\")');\n    \n    let response = backend.handleGetUsers();\n    \n    if (response.status === 200) {\n      this.state.users = response.data;\n      console.log('[Frontend] State updated, re-rendering UI');\n      console.log('[Frontend] Displaying:', this.state.users.length, 'users');\n    }\n    \n    return this.state.users;\n  },\n  \n  async fetchUser(id) {\n    console.log(`[Frontend] User clicked on user ${id}`);\n    console.log(`[Frontend] fetch(\"http://localhost:4000/api/users/${id}\")`);\n    \n    let response = backend.handleGetUser(id);\n    \n    if (response.status === 200) {\n      this.state.currentUser = response.data;\n      console.log('[Frontend] Displaying user profile:', response.data.name);\n    } else {\n      console.log('[Frontend] Showing error: User not found');\n    }\n  },\n  \n  async createUser(name, email) {\n    console.log('[Frontend] User submitted \"Create User\" form');\n    console.log(`[Frontend] fetch(\"http://localhost:4000/api/users\", { method: \"POST\", body: { name, email } })`);\n    \n    let response = backend.handleCreateUser(name, email);\n    \n    if (response.status === 201) {\n      console.log('[Frontend] Success! Refreshing user list...');\n      this.fetchUsers();\n    }\n  }\n};\n\n// Simulate full-stack application\nconsole.log('=== Full-Stack Application Flow ===\\n');\n\nconsole.log('--- Scenario 1: List all users ---');\nfrontend.fetchUsers();\n\nconsole.log('\\n--- Scenario 2: View specific user ---');\nfrontend.fetchUser(1);\n\nconsole.log('\\n--- Scenario 3: Create new user ---');\nfrontend.createUser('Diana', 'diana@example.com');\n\nconsole.log('\\n--- Final database state ---');\nconsole.log('Total users:', database.users.length);\nconsole.log('Users:', database.users.map(u => u.name).join(', '));",
      "commonStickingPoints": "Common full-stack mistakes:\n\n1. **CORS errors**:\n   ```\n   Error: Access to fetch at 'http://localhost:4000/api/users' from origin 'http://localhost:3000' \n   has been blocked by CORS policy\n   ```\n   Solution: Enable CORS on backend:\n   ```javascript\n   import cors from 'cors';\n   app.use(cors());\n   ```\n\n2. **Wrong API URLs**:\n   ```javascript\n   // Wrong! (missing http://)\n   fetch('localhost:4000/api/users')\n   \n   // Correct!\n   fetch('http://localhost:4000/api/users')\n   \n   // Better! (use environment variable)\n   fetch(`${import.meta.env.VITE_API_URL}/api/users`)\n   ```\n\n3. **Frontend and backend not running**:\n   - Need TWO terminal windows:\n     * Terminal 1: `cd frontend && npm run dev` (port 3000)\n     * Terminal 2: `cd backend && npm run dev` (port 4000)\n\n4. **Not handling async properly**:\n   ```javascript\n   // Wrong!\n   let users = fetch('/api/users'); // Returns Promise!\n   console.log(users); // Promise, not data\n   \n   // Correct!\n   let response = await fetch('/api/users');\n   let users = await response.json();\n   console.log(users); // Actual data\n   ```\n\n5. **Hardcoded URLs**:\n   - Don't hardcode: `http://localhost:4000`\n   - Use env variables: `process.env.API_URL`\n   - Different in dev vs production!\n\n6. **Not validating data**:\n   - Validate on frontend (UX)\n   - ALSO validate on backend (security)\n   - Never trust client data!\n\n7. **Mixing up req.body, req.params, req.query**:\n   ```javascript\n   // Backend route\n   app.post('/api/users/:id', (req, res) => {\n     req.params.id   // From URL: /api/users/123\n     req.query.name  // From query: ?name=alice\n     req.body.email  // From POST body: { email: '...' }\n   });\n   ```"
    }
  ]
}
