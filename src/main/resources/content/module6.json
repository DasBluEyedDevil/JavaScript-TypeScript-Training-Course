{
  "id": 6,
  "title": "Module 6: Creating Reusable Tools (The 'Recipes')",
  "description": "Write code once and reuse it many times with functions",
  "goal": "Master functions to create modular, reusable code",
  "lessons": [
    {
      "id": "6.1",
      "title": "What Is a Function? (The Recipe Analogy)",
      "conceptAnalogy": "A recipe is a list of instructions for making a specific dish. Once you write the recipe down, you can use it over and over without rewriting the steps each time.\n\nA function in programming is exactly like a recipe:\n- It has a NAME (e.g., 'Make Pancakes')\n- It has INGREDIENTS (inputs, called 'parameters')\n- It has INSTRUCTIONS (the code inside)\n- It produces a RESULT (output, called a 'return value')\n\nJust like you can call out 'Make Pancakes!' and the recipe executes, in code you can 'call' a function and it executes its instructions. Functions let you avoid repeating the same code - write once, use many times!",
      "codeExample": "// Defining a function\nfunction sayHello() {\n  console.log('Hello, World!');\n}\n\n// Calling (using) the function\nsayHello();  // Hello, World!\nsayHello();  // Hello, World!\n// Can call as many times as you want!\n\n// Function with a parameter (ingredient)\nfunction greet(name) {\n  console.log('Hello, ' + name + '!');\n}\n\ngreet('Alice');   // Hello, Alice!\ngreet('Bob');     // Hello, Bob!\ngreet('Charlie'); // Hello, Charlie!\n\n// Function that returns a value\nfunction add(a, b) {\n  return a + b;\n}\n\nlet sum = add(5, 3);\nconsole.log(sum);  // 8\n\nlet result = add(10, 20);\nconsole.log(result);  // 30",
      "syntaxBreakdown": "Function anatomy:\n\nfunction functionName(parameter1, parameter2) {\n│        │            │                      │\n│        │            └──────────────────────┴─ Parameters (inputs)\n│        └──────────────────────────────────── Name (you choose)\n└───────────────────────────────────────────── 'function' keyword\n  // Code to run\n  return result;  // Optional: send back a value\n}\n\nKey parts:\n\n1. **function keyword** - Tells JavaScript you're creating a function\n\n2. **Name** - What you call the function (use camelCase)\n   - Should describe what it does: calculateTotal, getUserName, etc.\n\n3. **Parameters** - Inputs the function needs (inside parentheses)\n   - Can have 0, 1, 2, or many parameters\n   - Separated by commas\n   - Like variables that exist only inside the function\n\n4. **Function body** - The code inside { }\n   - The instructions to execute\n\n5. **return statement** - Sends a value back (optional)\n   - Function stops executing when it hits return\n   - If no return, function returns undefined\n\nCalling a function:\nfunctionName(argument1, argument2);\n\n- Use the function name\n- Add parentheses ()\n- Pass arguments (values) for parameters\n\nWithout () it's just a reference:\ngreet     // The function itself (reference)\ngreet()   // Calling the function (execution)",
      "challenge": {
        "instructions": "Create a function that converts Celsius to Fahrenheit:\n1. Name it celsiusToFahrenheit\n2. It should take one parameter: celsius\n3. Formula: (celsius * 9/5) + 32\n4. Return the result\n5. Test by calling it with 0, 100, and 37",
        "starterCode": "// Define your function here\n\n// Test it\nconsole.log(celsiusToFahrenheit(0));    // Should be 32\nconsole.log(celsiusToFahrenheit(100));  // Should be 212\nconsole.log(celsiusToFahrenheit(37));   // Should be 98.6",
        "testCases": [
          {
            "description": "Converts 0°C correctly",
            "input": "function celsiusToFahrenheit(celsius) { return (celsius * 9/5) + 32; } console.log(celsiusToFahrenheit(0));",
            "expectedOutput": "32"
          }
        ],
        "hint": "function celsiusToFahrenheit(celsius) { return (celsius * 9/5) + 32; }"
      },
      "solution": "function celsiusToFahrenheit(celsius) {\n  return (celsius * 9/5) + 32;\n}\n\nconsole.log(celsiusToFahrenheit(0));    // 32\nconsole.log(celsiusToFahrenheit(100));  // 212\nconsole.log(celsiusToFahrenheit(37));   // 98.6",
      "commonStickingPoints": "Common mistakes:\n\n1. Forgetting parentheses when calling:\n   greet  // Doesn't execute - just references the function\n   greet()  // Executes the function\n\n2. Confusing parameters and arguments:\n   function greet(name) { }  // 'name' is a parameter (placeholder)\n   greet('Alice');  // 'Alice' is an argument (actual value)\n\n3. Not returning a value when you need one:\n   function add(a, b) {\n     a + b;  // WRONG - doesn't return anything!\n   }\n   function add(a, b) {\n     return a + b;  // CORRECT\n   }\n\n4. Code after return never runs:\n   function test() {\n     return 5;\n     console.log('This never runs!');  // Unreachable\n   }\n\n5. Wrong number of arguments:\n   function add(a, b) { return a + b; }\n   add(5);  // b is undefined, returns NaN\n   add(5, 3, 7);  // Extra argument ignored, returns 8"
    },
    {
      "id": "6.2",
      "title": "The Modern Shorthand (Arrow Functions =>)",
      "conceptAnalogy": "Imagine you have two ways to give someone your address:\n\n**Long form**: 'My address is 123 Main Street, New York, NY 10001'\n\n**Short form**: '123 Main St, NYC'\n\nBoth give the same information, but the short form is quicker for simple cases. Arrow functions (=>) are the 'short form' for writing functions in modern JavaScript. They do the same thing as regular functions, but with less typing for simple cases.",
      "codeExample": "// Traditional function\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow function (same thing, shorter)\nconst add = (a, b) => {\n  return a + b;\n};\n\n// Even shorter (implicit return for one-liners)\nconst add = (a, b) => a + b;\n\n// Examples of different arrow function forms\n\n// No parameters\nconst sayHello = () => console.log('Hello!');\nsayHello();  // Hello!\n\n// One parameter (parentheses optional)\nconst double = num => num * 2;\nconsole.log(double(5));  // 10\n\n// Multiple parameters (need parentheses)\nconst multiply = (a, b) => a * b;\nconsole.log(multiply(3, 4));  // 12\n\n// Multiple lines (need curly braces and explicit return)\nconst greetPerson = (name) => {\n  let greeting = 'Hello, ' + name;\n  return greeting + '!';\n};\nconsole.log(greetPerson('Alice'));  // Hello, Alice!\n\n// Using with array methods\nlet numbers = [1, 2, 3, 4, 5];\nlet doubled = numbers.map(n => n * 2);\nconsole.log(doubled);  // [2, 4, 6, 8, 10]",
      "syntaxBreakdown": "Arrow function syntax:\n\nconst functionName = (parameters) => { body };\n│     │              │            │  │      │\n│     │              │            │  │      └─ Function body\n│     │              │            │  └──────── Arrow\n│     │              └────────────┴─────────── Parameters\n│     └──────────────────────────────────────── Name\n└────────────────────────────────────────────── const (or let)\n\nShorthand rules:\n\n1. **No parameters**: Use empty ()\n   const greet = () => 'Hello';\n\n2. **One parameter**: Parentheses optional\n   const double = x => x * 2;\n   const double = (x) => x * 2;  // Also valid\n\n3. **Multiple parameters**: Need parentheses\n   const add = (a, b) => a + b;\n\n4. **One-line body**: Can omit { } and return\n   const add = (a, b) => a + b;  // Implicit return\n\n5. **Multi-line body**: Need { } and explicit return\n   const greet = (name) => {\n     let msg = 'Hello, ' + name;\n     return msg;\n   };\n\nComparing to traditional functions:\n\n// Traditional\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow (full form)\nconst add = (a, b) => {\n  return a + b;\n};\n\n// Arrow (short form)\nconst add = (a, b) => a + b;\n\nWhen to use arrow functions:\n✓ Short, simple functions\n✓ Callback functions (map, filter, etc.)\n✓ Modern JavaScript style\n\nWhen to use traditional functions:\n✓ Methods in objects/classes\n✓ Need 'this' keyword (advanced)\n✓ Personal preference for readability",
      "challenge": {
        "instructions": "Convert these traditional functions to arrow functions:\n\n1. function square(x) { return x * x; }\n2. function isEven(num) { return num % 2 === 0; }\n3. function getFullName(first, last) { return first + ' ' + last; }\n\nUse the shortest form possible!",
        "starterCode": "// Convert to arrow functions\nconst square = // YOUR CODE HERE\n\nconst isEven = // YOUR CODE HERE\n\nconst getFullName = // YOUR CODE HERE\n\n// Test them\nconsole.log(square(5));  // 25\nconsole.log(isEven(4));  // true\nconsole.log(getFullName('John', 'Doe'));  // John Doe",
        "testCases": [
          {
            "description": "Square function works",
            "input": "const square = x => x * x; console.log(square(5));",
            "expectedOutput": "25"
          }
        ],
        "hint": "Use: const name = params => expression"
      },
      "solution": "const square = x => x * x;\n\nconst isEven = num => num % 2 === 0;\n\nconst getFullName = (first, last) => first + ' ' + last;\n\n// Test them\nconsole.log(square(5));  // 25\nconsole.log(isEven(4));  // true\nconsole.log(getFullName('John', 'Doe'));  // John Doe",
      "commonStickingPoints": "Common mistakes:\n\n1. Forgetting parentheses with multiple parameters:\n   const add = a, b => a + b;  // WRONG\n   const add = (a, b) => a + b;  // CORRECT\n\n2. Forgetting curly braces for multi-line:\n   const greet = name =>\n     let msg = 'Hello';\n     return msg;  // WRONG - syntax error\n   \n   const greet = name => {\n     let msg = 'Hello';\n     return msg;  // CORRECT\n   };\n\n3. Trying to return an object without parentheses:\n   const getUser = () => {name: 'Alice'};  // WRONG - thinks { } is function body\n   const getUser = () => ({name: 'Alice'});  // CORRECT - wrapped in ()\n\n4. Using arrow function as method:\n   const person = {\n     name: 'Alice',\n     greet: () => console.log(this.name)  // WRONG - 'this' doesn't work as expected\n   };\n   Use traditional function for object methods\n\n5. Mixing up = and =>:\n   const add = (a, b) = a + b;  // WRONG - single =\n   const add = (a, b) => a + b;  // CORRECT - arrow =>"
    },
    {
      "id": "6.3",
      "title": "Ingredients and Results (Parameters and Return Values)",
      "conceptAnalogy": "A coffee machine is a perfect analogy for functions with parameters and return values:\n\n**Inputs (Parameters)**: You put in coffee beans, water, and select a size\n**Process**: The machine does its work inside (you don't see this)\n**Output (Return Value)**: You get a cup of coffee\n\nSimilarly, a function:\n- Takes INPUTS (parameters)\n- Does some PROCESSING (the function body)\n- Gives back an OUTPUT (return value)\n\nJust like you can put different beans in the coffee machine and get different coffee, you can pass different parameters to a function and get different results.",
      "codeExample": "// Function with one parameter\nfunction greet(name) {\n  return 'Hello, ' + name + '!';\n}\n\nlet message = greet('Alice');\nconsole.log(message);  // Hello, Alice!\n\n// Function with multiple parameters\nfunction calculateArea(width, height) {\n  return width * height;\n}\n\nlet area = calculateArea(5, 10);\nconsole.log(area);  // 50\n\n// Parameters with default values (ES2015+)\nfunction greet(name = 'Guest') {\n  return 'Hello, ' + name + '!';\n}\n\nconsole.log(greet());        // Hello, Guest!\nconsole.log(greet('Bob'));   // Hello, Bob!\n\n// Function that doesn't return (returns undefined)\nfunction logMessage(msg) {\n  console.log(msg);\n  // No return statement\n}\n\nlet result = logMessage('Test');\nconsole.log(result);  // undefined\n\n// Returning early\nfunction divide(a, b) {\n  if (b === 0) {\n    return 'Cannot divide by zero';\n  }\n  return a / b;\n}\n\nconsole.log(divide(10, 2));  // 5\nconsole.log(divide(10, 0));  // Cannot divide by zero\n\n// Returning objects\nfunction createUser(name, age) {\n  return {\n    name: name,\n    age: age,\n    isAdult: age >= 18\n  };\n}\n\nlet user = createUser('Alice', 25);\nconsole.log(user);  // {name: 'Alice', age: 25, isAdult: true}",
      "syntaxBreakdown": "Understanding parameters and returns:\n\n**Parameters** (Function Definition):\nfunction doSomething(param1, param2, param3) {\n                     │      │      │\n                     └──────┴──────┴─ Placeholders for values\n}\n\n**Arguments** (Function Call):\ndoSomething(value1, value2, value3);\n            │       │       │\n            └───────┴───────┴─ Actual values passed in\n\nParameter patterns:\n\n1. **No parameters**:\n   function sayHello() {\n     return 'Hello!';\n   }\n\n2. **One parameter**:\n   function double(x) {\n     return x * 2;\n   }\n\n3. **Multiple parameters**:\n   function add(a, b) {\n     return a + b;\n   }\n\n4. **Default parameters** (ES2015):\n   function greet(name = 'Guest', greeting = 'Hello') {\n     return greeting + ', ' + name;\n   }\n   greet();  // Hello, Guest\n   greet('Alice');  // Hello, Alice\n   greet('Bob', 'Hi');  // Hi, Bob\n\n5. **Rest parameters** (collect all remaining args):\n   function sum(...numbers) {\n     return numbers.reduce((total, n) => total + n, 0);\n   }\n   sum(1, 2, 3, 4);  // 10\n\nReturn value patterns:\n\n1. **Return a value**:\n   return 42;\n   return 'text';\n   return true;\n\n2. **Return early** (exit function immediately):\n   if (error) {\n     return 'Error';\n   }\n   // Rest of function\n\n3. **No return** (implicitly returns undefined):\n   function doSomething() {\n     console.log('Done');\n   }\n\n4. **Return object** (use parentheses with arrow functions):\n   const getUser = () => ({name: 'Alice', age: 25});\n\n5. **Return another function**:\n   function outer() {\n     return function inner() {\n       return 'Hello';\n     };\n   }",
      "challenge": {
        "instructions": "Create a function called calculateGrade that:\n1. Takes one parameter: score (a number 0-100)\n2. Returns a letter grade based on:\n   - 90+ = 'A'\n   - 80-89 = 'B'\n   - 70-79 = 'C'\n   - 60-69 = 'D'\n   - Below 60 = 'F'\n3. Test with scores: 95, 87, 72, 65, 45",
        "starterCode": "function calculateGrade(score) {\n  // YOUR CODE HERE\n}\n\n// Test\nconsole.log(calculateGrade(95));  // Should be 'A'\nconsole.log(calculateGrade(87));  // Should be 'B'\nconsole.log(calculateGrade(72));  // Should be 'C'",
        "testCases": [
          {
            "description": "Returns 'A' for 95",
            "input": "function calculateGrade(score) { if (score >= 90) return 'A'; if (score >= 80) return 'B'; if (score >= 70) return 'C'; if (score >= 60) return 'D'; return 'F'; } console.log(calculateGrade(95));",
            "expectedOutput": "A"
          }
        ],
        "hint": "Use if/else if/else with return statements"
      },
      "solution": "function calculateGrade(score) {\n  if (score >= 90) {\n    return 'A';\n  } else if (score >= 80) {\n    return 'B';\n  } else if (score >= 70) {\n    return 'C';\n  } else if (score >= 60) {\n    return 'D';\n  } else {\n    return 'F';\n  }\n}\n\nconsole.log(calculateGrade(95));  // A\nconsole.log(calculateGrade(87));  // B\nconsole.log(calculateGrade(72));  // C\nconsole.log(calculateGrade(65));  // D\nconsole.log(calculateGrade(45));  // F",
      "commonStickingPoints": "Common mistakes:\n\n1. Wrong number of arguments:\n   function add(a, b) { return a + b; }\n   add(5);  // b is undefined, returns NaN\n   add(5, 3, 7);  // 7 is ignored\n\n2. Not returning the value:\n   function add(a, b) {\n     a + b;  // Calculated but not returned!\n   }\n   let result = add(5, 3);  // undefined\n\n3. Trying to use parameters outside function:\n   function greet(name) {\n     return 'Hello, ' + name;\n   }\n   console.log(name);  // ERROR - name only exists inside function\n\n4. Forgetting to call the function:\n   let result = add;  // result is the function itself\n   let result = add(5, 3);  // result is 8\n\n5. Returning in wrong place:\n   function test() {\n     if (true) {\n       let x = 5;\n       return x;  // WRONG - x might not be accessible\n     }\n   }\n   Better: calculate first, then return"
    },
    {
      "id": "6.4",
      "title": "What's 'In the Kitchen'? (Scope and Variable Visibility)",
      "conceptAnalogy": "Imagine a restaurant with different areas:\n\n**The Kitchen** (Function Scope): Chefs can use all the kitchen tools and ingredients. But customers in the dining room can't reach into the kitchen and grab a spatula.\n\n**The Dining Room** (Global Scope): Everyone can see and use things here - tables, chairs, menus.\n\n**A Chef's Personal Station** (Block Scope): Each chef has their own station. Their tools are theirs - other chefs can't use them.\n\nThis is SCOPE in programming - which parts of your code can 'see' and use which variables. Variables declared inside a function are like kitchen tools - only accessible inside that function. Variables declared outside are like the dining room - everyone can access them.",
      "codeExample": "// Global scope - accessible everywhere\nlet globalVar = 'I am global';\n\nfunction testScope() {\n  // Function scope - only accessible inside this function\n  let localVar = 'I am local';\n  \n  console.log(globalVar);  // Works - can access global\n  console.log(localVar);   // Works - we're inside the function\n}\n\ntestScope();\nconsole.log(globalVar);  // Works - global is accessible\n// console.log(localVar);   // ERROR - localVar doesn't exist here!\n\n// Block scope (let and const)\nif (true) {\n  let blockVar = 'I am in a block';\n  const alsoBlock = 'Me too';\n  var notBlock = 'I escape!';\n  \n  console.log(blockVar);  // Works\n}\n\n// console.log(blockVar);  // ERROR - blockVar is block-scoped\nconsole.log(notBlock);   // Works - var ignores block scope (bad!)\n\n// Nested scopes\nlet outer = 'outer';\n\nfunction outerFunc() {\n  let middle = 'middle';\n  \n  function innerFunc() {\n    let inner = 'inner';\n    \n    console.log(outer);   // Works - can see outer\n    console.log(middle);  // Works - can see parent\n    console.log(inner);   // Works - own scope\n  }\n  \n  innerFunc();\n  // console.log(inner);  // ERROR - can't see child scope\n}\n\nouterFunc();\n\n// Shadowing (be careful!)\nlet name = 'Global Alice';\n\nfunction greet() {\n  let name = 'Local Bob';  // Different variable!\n  console.log(name);  // Local Bob\n}\n\ngreet();\nconsole.log(name);  // Global Alice",
      "syntaxBreakdown": "Understanding scope:\n\n**1. Global Scope**\n- Variables declared outside any function\n- Accessible everywhere in your code\n- Use sparingly - can cause naming conflicts\n\nlet globalVar = 'accessible everywhere';\n\nfunction anywhere() {\n  console.log(globalVar);  // Can access\n}\n\n**2. Function Scope**\n- Variables declared inside a function\n- Only accessible inside that function\n- Includes parameters\n\nfunction myFunc(param) {  // param has function scope\n  let localVar = 'only here';  // localVar has function scope\n}\n\n**3. Block Scope** (let and const only)\n- Variables declared inside { }\n- Only accessible inside that block\n- if, for, while, etc. create blocks\n\nif (true) {\n  let x = 5;  // Block scoped\n  const y = 10;  // Block scoped\n  var z = 15;  // Function scoped (escapes block!)\n}\n\n**Scope Chain** (looking up variables):\n\nlet a = 'global';\n\nfunction outer() {\n  let b = 'outer';\n  \n  function inner() {\n    let c = 'inner';\n    \n    // JavaScript looks for variables in this order:\n    // 1. Current scope (inner) - c\n    // 2. Parent scope (outer) - b\n    // 3. Grandparent scope (global) - a\n  }\n}\n\n**Best Practices**:\n\n1. Use let and const (not var)\n   - They respect block scope\n   - Prevent accidental global variables\n\n2. Keep variables in smallest scope needed\n   - Declare inside functions/blocks when possible\n   - Reduces naming conflicts\n\n3. Avoid global variables\n   - Hard to track who modifies them\n   - Can cause bugs\n\n4. Don't shadow variables (same name in nested scopes)\n   - Confusing to read\n   - Use different names",
      "challenge": {
        "instructions": "Debug this code - it has scope issues:\n\nfunction calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  \n  if (price > 50) {\n    let discount = 10;\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nFix it so discount is accessible. Then calculate the total correctly.",
        "starterCode": "function calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  \n  if (price > 50) {\n    let discount = 10;\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nconsole.log(calculateTotal());",
        "testCases": [
          {
            "description": "Calculates total correctly",
            "input": "function calculateTotal() { let price = 100; let tax = 0.08; let discount = 0; if (price > 50) { discount = 10; } let total = price - discount + (price * tax); return total; } console.log(calculateTotal());",
            "expectedOutput": "98"
          }
        ],
        "hint": "Declare discount outside the if block, or move the calculation inside"
      },
      "solution": "function calculateTotal() {\n  let price = 100;\n  let tax = 0.08;\n  let discount = 0;  // Declare in function scope\n  \n  if (price > 50) {\n    discount = 10;  // Assign (no let)\n  }\n  \n  let total = price - discount + (price * tax);\n  return total;\n}\n\nconsole.log(calculateTotal());  // 98",
      "commonStickingPoints": "Common mistakes:\n\n1. Using variables outside their scope:\n   function test() {\n     let x = 5;\n   }\n   console.log(x);  // ERROR - x only exists inside test()\n\n2. Forgetting var escapes block scope:\n   if (true) {\n     var x = 5;  // Function scoped, not block scoped!\n   }\n   console.log(x);  // 5 - var leaks out\n   \n   Always use let/const, never var!\n\n3. Shadowing by accident:\n   let name = 'Alice';\n   function greet() {\n     let name = 'Bob';  // Different variable!\n   }\n   Confusing - use different names\n\n4. Trying to access parameters outside function:\n   function add(a, b) {\n     return a + b;\n   }\n   console.log(a);  // ERROR - parameters are function-scoped\n\n5. Not understanding hoisting:\n   console.log(x);  // undefined (not error with var)\n   var x = 5;\n   \n   vs\n   \n   console.log(x);  // ERROR - cannot access before initialization\n   let x = 5;\n   \n   Another reason to use let/const!"
    }
  ]
}
