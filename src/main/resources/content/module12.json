{
  "id": "12",
  "title": "Module 12: Building Modern Front-End with React 19",
  "description": "Learn React 19's latest features including JSX, components, hooks (useState, useEffect), and the new React 19 hooks",
  "goal": "Build interactive, performant user interfaces with React 19's cutting-edge features",
  "lessons": [
    {
      "id": "12.1",
      "title": "JSX - JavaScript Meets HTML (But It's NOT HTML!)",
      "conceptAnalogy": "Imagine writing a recipe:\n\nPlain text recipe:\n- Hard to read\n- No structure\n- Easy to mess up\n\nFormatted recipe with sections:\n- Ingredients (like HTML tags)\n- Instructions (like JavaScript logic)\n- Combined in one document\n\nJSX is like having ingredients AND instructions in one file:\n- Looks like HTML (familiar and readable)\n- But it's actually JavaScript (gets compiled)\n- Can use JavaScript expressions inside {}\n\nJSX = JavaScript XML. It's JavaScript that LOOKS like HTML!",
      "codeExample": "// JSX - The Syntax That Powers React\n\n// IMPORTANT: JSX compiles to JavaScript!\n// This JSX:\n// <h1>Hello World</h1>\n//\n// Becomes this JavaScript:\n// React.createElement('h1', null, 'Hello World')\n\nconsole.log('=== JSX Fundamentals ===\\n');\n\n// 1. JSX LOOKS LIKE HTML (but isn't!)\nlet jsxElement = '<h1>Hello, React!</h1>'; // This is just a string\nconsole.log('String:', jsxElement);\n\n// Real JSX (conceptual - won't run in plain JavaScript):\n// let jsxElement = <h1>Hello, React!</h1>;\n// This compiles to: React.createElement('h1', null, 'Hello, React!');\n\n// 2. EMBEDDING JAVASCRIPT WITH {}\nlet name = 'Alice';\nlet age = 25;\n\n// JSX allows JavaScript expressions inside curly braces\nlet greeting = `<h1>Hello, ${name}!</h1>`;  // Template literal (similar concept)\nconsole.log('\\nGreeting:', greeting);\n\n// In real JSX:\n// <h1>Hello, {name}!</h1>\n// <p>You are {age} years old</p>\n// <p>Next year: {age + 1}</p>\n\n// 3. JSX VS HTML - KEY DIFFERENCES\nconsole.log('\\n=== JSX vs HTML Differences ===\\n');\n\nlet differences = {\n  'class': {\n    html: '<div class=\"card\">',\n    jsx: '<div className=\"card\">',\n    reason: 'class is a JavaScript keyword'\n  },\n  'for': {\n    html: '<label for=\"name\">',\n    jsx: '<label htmlFor=\"name\">',\n    reason: 'for is a JavaScript keyword'\n  },\n  'style': {\n    html: '<div style=\"color: red; font-size: 16px\">',\n    jsx: '<div style={{ color: \"red\", fontSize: \"16px\" }}>',\n    reason: 'JSX style is a JavaScript object'\n  },\n  'onclick': {\n    html: '<button onclick=\"handleClick()\">',\n    jsx: '<button onClick={handleClick}>',\n    reason: 'camelCase in JSX, function reference not string'\n  },\n  'self-closing': {\n    html: '<img src=\"pic.jpg\">',\n    jsx: '<img src=\"pic.jpg\" />',\n    reason: 'JSX requires closing slash for void elements'\n  }\n};\n\nfor (let [feature, diff] of Object.entries(differences)) {\n  console.log(`${feature.toUpperCase()}:`);\n  console.log(`  HTML: ${diff.html}`);\n  console.log(`  JSX:  ${diff.jsx}`);\n  console.log(`  Why:  ${diff.reason}\\n`);\n}\n\n// 4. JAVASCRIPT EXPRESSIONS IN JSX\nconsole.log('=== JavaScript in JSX ===\\n');\n\nlet user = {\n  firstName: 'Bob',\n  lastName: 'Smith',\n  age: 30\n};\n\n// You can use ANY JavaScript expression inside {}\nlet examples = [\n  `{user.firstName}           → ${user.firstName}`,\n  `{user.firstName + ' ' + user.lastName} → ${user.firstName + ' ' + user.lastName}`,\n  `{age > 18 ? 'Adult' : 'Minor'} → ${user.age > 18 ? 'Adult' : 'Minor'}`,\n  `{[1,2,3].map(n => n * 2)}  → ${[1,2,3].map(n => n * 2).join(', ')}`\n];\n\nexamples.forEach(ex => console.log(ex));\n\n// 5. MUST RETURN SINGLE ROOT ELEMENT\nconsole.log('\\n=== JSX Rules ===\\n');\n\n// WRONG (in JSX - multiple roots):\n// return (\n//   <h1>Title</h1>\n//   <p>Text</p>\n// );\n\n// CORRECT - Wrapped in div:\n// return (\n//   <div>\n//     <h1>Title</h1>\n//     <p>Text</p>\n//   </div>\n// );\n\n// BETTER - React Fragment (no extra DOM node):\n// return (\n//   <>\n//     <h1>Title</h1>\n//     <p>Text</p>\n//   </>\n// );\n\nconsole.log('✓ JSX must have ONE root element');\nconsole.log('✓ Use <> </> (Fragment) to avoid extra divs');\nconsole.log('✓ All tags must be closed (including <img />, <br />)');\nconsole.log('✓ Use className not class');\nconsole.log('✓ Use camelCase for attributes (onClick, onChange)');\n\n// 6. WHY JSX?\nlet benefits = [\n  'Familiar HTML-like syntax',\n  'JavaScript power with {} expressions',\n  'Type checking and autocomplete',\n  'Prevents injection attacks (auto-escapes)',\n  'Easier to visualize component structure',\n  'Not required but highly recommended'\n];\n\nconsole.log('\\nWhy use JSX:');\nbenefits.forEach(b => console.log(`  ✓ ${b}`));",
      "syntaxBreakdown": "JSX syntax guide:\n\n1. **JSX is JavaScript, not HTML**:\n   ```jsx\n   // This JSX:\n   const element = <h1>Hello</h1>;\n   \n   // Compiles to:\n   const element = React.createElement('h1', null, 'Hello');\n   ```\n\n2. **Embedding Expressions** with {}:\n   ```jsx\n   const name = 'Alice';\n   const element = <h1>Hello, {name}!</h1>;\n   \n   // Any JavaScript expression works:\n   <p>{2 + 2}</p>                    // 4\n   <p>{user.name.toUpperCase()}</p>  // ALICE\n   <p>{isLoggedIn ? 'Hi' : 'Please login'}</p>\n   ```\n\n3. **Attributes in JSX**:\n   ```jsx\n   // className not class\n   <div className=\"container\"></div>\n   \n   // htmlFor not for\n   <label htmlFor=\"email\">Email:</label>\n   \n   // camelCase event handlers\n   <button onClick={handleClick}>Click</button>\n   \n   // Style as object\n   <div style={{ color: 'red', fontSize: 16 }}></div>\n   ```\n\n4. **Self-Closing Tags**:\n   ```jsx\n   // Must include /\n   <img src=\"logo.png\" />\n   <br />\n   <input type=\"text\" />\n   ```\n\n5. **Children**:\n   ```jsx\n   // String children\n   <h1>Title</h1>\n   \n   // Expression children\n   <p>{user.name}</p>\n   \n   // Component children\n   <div>\n     <Header />\n     <Main />\n     <Footer />\n   </div>\n   ```\n\n6. **Fragments** (avoid extra divs):\n   ```jsx\n   // Shorthand\n   return (\n     <>\n       <h1>Title</h1>\n       <p>Text</p>\n     </>\n   );\n   \n   // Full syntax (needed for keys)\n   return (\n     <React.Fragment>\n       <h1>Title</h1>\n       <p>Text</p>\n     </React.Fragment>\n   );\n   ```\n\n7. **Comments in JSX**:\n   ```jsx\n   return (\n     <div>\n       {/* This is a comment */}\n       <h1>Title</h1>\n     </div>\n   );\n   ```",
      "challenge": {
        "instructions": "Practice JSX concepts:\n\n1. Create variables for:\n   - `firstName` = your first name\n   - `lastName` = your last name\n   - `age` = your age\n\n2. Create a `getFullName()` function that returns first + last name\n\n3. Create a simulated JSX structure (as a string) that includes:\n   - An h1 with full name\n   - A p showing age\n   - A p showing if adult (age >= 18)\n\n4. Log the result\n\nNote: Since we're in plain JavaScript, use template literals to simulate JSX.",
        "starterCode": "// Simulate JSX with template literals\n\nlet firstName = 'Alice';\nlet lastName = 'Johnson';\nlet age = 25;\n\nfunction getFullName() {\n  return firstName + ' ' + lastName;\n}\n\n// Simulate JSX structure\nlet jsxOutput = `\n<div className=\"user-card\">\n  <h1>Name: ${getFullName()}</h1>\n  <p>Age: ${age}</p>\n  <p>Status: ${age >= 18 ? 'Adult' : 'Minor'}</p>\n</div>\n`;\n\nconsole.log('Simulated JSX:');\nconsole.log(jsxOutput);",
        "testCases": [
          {
            "description": "Should concatenate names",
            "input": "let first = 'John'; let last = 'Doe'; first + ' ' + last",
            "expectedOutput": "John Doe"
          },
          {
            "description": "Should check adult status",
            "input": "let age = 20; age >= 18 ? 'Adult' : 'Minor'",
            "expectedOutput": "Adult"
          }
        ],
        "hint": "Use template literals with ${} to embed JavaScript expressions."
      },
      "solution": "// Complete JSX simulation\n\nlet firstName = 'Alice';\nlet lastName = 'Johnson';\nlet age = 25;\nlet isStudent = true;\n\nfunction getFullName() {\n  return `${firstName} ${lastName}`;\n}\n\nfunction getStatus() {\n  if (age < 18) return 'Minor';\n  if (isStudent) return 'Adult Student';\n  return 'Adult';\n}\n\n// Simulated JSX with all features\nlet jsxOutput = `\n<div className=\"user-card\">\n  <h1>Welcome, ${getFullName()}!</h1>\n  <div className=\"user-info\">\n    <p>First Name: ${firstName}</p>\n    <p>Last Name: ${lastName}</p>\n    <p>Age: ${age}</p>\n    <p>Status: ${getStatus()}</p>\n    <p>Can Vote: ${age >= 18 ? 'Yes' : 'No'}</p>\n  </div>\n  ${isStudent ? '<p className=\"badge\">Student Discount Available!</p>' : ''}\n</div>\n`;\n\nconsole.log('=== Simulated JSX Output ===');\nconsole.log(jsxOutput);\n\n// Demonstrate JavaScript expressions\nconsole.log('\\n=== Expression Examples ===');\nconsole.log('Full name:', getFullName());\nconsole.log('Next year age:', age + 1);\nconsole.log('Name length:', getFullName().length);\nconsole.log('Uppercase:', getFullName().toUpperCase());\nconsole.log('Adult?', age >= 18);\n\n// Array mapping (common in JSX)\nlet hobbies = ['Reading', 'Coding', 'Gaming'];\nlet hobbiesList = hobbies.map(hobby => `<li>${hobby}</li>`).join('\\n');\nconsole.log('\\nHobbies list:');\nconsole.log('<ul>');\nconsole.log(hobbiesList);\nconsole.log('</ul>');",
      "commonStickingPoints": "Common JSX mistakes:\n\n1. **Using `class` instead of `className`**:\n   ```jsx\n   // Wrong!\n   <div class=\"container\">  // Error in JSX\n   \n   // Correct!\n   <div className=\"container\">\n   ```\n\n2. **Forgetting to close tags**:\n   ```jsx\n   // Wrong!\n   <img src=\"logo.png\">     // Error!\n   <br>                     // Error!\n   \n   // Correct!\n   <img src=\"logo.png\" />\n   <br />\n   ```\n\n3. **Quotes around JavaScript expressions**:\n   ```jsx\n   // Wrong!\n   <p>{\"userName\"}</p>       // Renders the string \"userName\"\n   <p>{age + 1}</p>         // Wrong quotes\n   \n   // Correct!\n   <p>{userName}</p>        // Uses the variable\n   <p>{age + 1}</p>         // No quotes for expressions\n   ```\n\n4. **Multiple root elements**:\n   ```jsx\n   // Wrong!\n   return (\n     <h1>Title</h1>\n     <p>Text</p>            // Error: Adjacent JSX elements\n   );\n   \n   // Correct!\n   return (\n     <>\n       <h1>Title</h1>\n       <p>Text</p>\n     </>\n   );\n   ```\n\n5. **Inline style as string**:\n   ```jsx\n   // Wrong! (HTML syntax)\n   <div style=\"color: red; font-size: 16px\">\n   \n   // Correct! (JSX object syntax)\n   <div style={{ color: 'red', fontSize: 16 }}>\n   //          ^^^^ object  ^^^^^ camelCase\n   ```\n\n6. **Event handler called immediately**:\n   ```jsx\n   // Wrong!\n   <button onClick={handleClick()}>  // Calls immediately!\n   \n   // Correct!\n   <button onClick={handleClick}>    // Passes function reference\n   <button onClick={() => handleClick()}>  // Arrow function wrapper\n   ```\n\n7. **Conditional rendering syntax**:\n   ```jsx\n   // Wrong!\n   <div>\n     if (isLoggedIn) {      // Can't use if in JSX!\n       <p>Welcome</p>\n     }\n   </div>\n   \n   // Correct!\n   <div>\n     {isLoggedIn && <p>Welcome</p>}           // && operator\n     {isLoggedIn ? <p>Hi</p> : <p>Login</p>}  // Ternary\n   </div>\n   ```"
    },
    {
      "id": "12.2",
      "title": "Components and Props (The LEGO Blocks Analogy)",
      "conceptAnalogy": "Think of React components like LEGO blocks:\n\nBasic LEGO block:\n- Standard shape and size\n- Can connect to other blocks\n- Reusable - use the same piece many times\n- Different colors (props) make each one unique\n\nCustom LEGO creation (component):\n- Build a car from blocks\n- Want 5 cars? Use the same design 5 times\n- Each car can be different color (props)\n- Change the design once → All cars update\n\nReact components are reusable building blocks:\n- Define once, use many times\n- Pass props to customize each instance\n- Compose small components into bigger ones!",
      "codeExample": "// React Components and Props\n\nconsole.log('=== React Components ===\\n');\n\n// COMPONENT = Reusable UI function\n// Props = Data passed to component (like function parameters)\n\n// 1. FUNCTION COMPONENT (modern React)\nfunction Greeting(props) {\n  return `<h1>Hello, ${props.name}!</h1>`;\n}\n\n// Use it multiple times with different props\nlet greeting1 = Greeting({ name: 'Alice' });\nlet greeting2 = Greeting({ name: 'Bob' });\nlet greeting3 = Greeting({ name: 'Charlie' });\n\nconsole.log('Same component, different props:');\nconsole.log(greeting1);  // Hello, Alice!\nconsole.log(greeting2);  // Hello, Bob!\nconsole.log(greeting3);  // Hello, Charlie!\n\n// 2. PROPS ARE READ-ONLY\nfunction UserCard(props) {\n  // props.name = 'Different'; // ERROR! Can't modify props!\n  \n  return `\n    <div className=\"user-card\">\n      <h2>${props.name}</h2>\n      <p>Email: ${props.email}</p>\n      <p>Role: ${props.role || 'User'}</p>\n    </div>\n  `;\n}\n\nlet user1 = UserCard({\n  name: 'Alice Johnson',\n  email: 'alice@example.com',\n  role: 'Admin'\n});\n\nlet user2 = UserCard({\n  name: 'Bob Smith',\n  email: 'bob@example.com'\n  // No role = uses default 'User'\n});\n\nconsole.log('\\nUser Cards:');\nconsole.log(user1);\nconsole.log(user2);\n\n// 3. DESTRUCTURING PROPS (cleaner syntax)\nfunction Button({ label, color, onClick }) {\n  // Instead of props.label, props.color, etc.\n  return `<button style=\"background: ${color}\" onClick=\"${onClick}\">${label}</button>`;\n}\n\nlet submitBtn = Button({\n  label: 'Submit',\n  color: 'blue',\n  onClick: 'handleSubmit()'\n});\n\nconsole.log('\\nButton:', submitBtn);\n\n// 4. PROPS WITH CHILDREN\nfunction Card({ title, children }) {\n  return `\n    <div className=\"card\">\n      <h3>${title}</h3>\n      <div className=\"card-body\">\n        ${children}\n      </div>\n    </div>\n  `;\n}\n\nlet card = Card({\n  title: 'My Card',\n  children: '<p>This is the card content</p><p>Multiple children!</p>'\n});\n\nconsole.log('\\nCard with children:');\nconsole.log(card);\n\n// 5. COMPONENT COMPOSITION\nfunction Header({ logo, title }) {\n  return `<header><img src=\"${logo}\" /><h1>${title}</h1></header>`;\n}\n\nfunction Footer({ year, company }) {\n  return `<footer><p>© ${year} ${company}</p></footer>`;\n}\n\nfunction App() {\n  return `\n    <div className=\"app\">\n      ${Header({ logo: 'logo.png', title: 'My App' })}\n      <main>\n        ${Card({ title: 'Welcome', children: '<p>Welcome to my app!</p>' })}\n      </main>\n      ${Footer({ year: 2025, company: 'My Company' })}\n    </div>\n  `;\n}\n\nconsole.log('\\nComplete App (composed of smaller components):');\nconsole.log(App());\n\n// 6. PROPS BEST PRACTICES\nconsole.log('\\n=== Props Best Practices ===\\n');\n\nlet practices = [\n  '✓ Props are read-only (immutable)',\n  '✓ Destructure props for cleaner code',\n  '✓ Provide default values: role || \"User\"',\n  '✓ Use clear, descriptive prop names',\n  '✓ Pass only what component needs',\n  '✓ Children prop for nested content',\n  '✓ Keep components focused and reusable'\n];\n\npractices.forEach(p => console.log(p));",
      "syntaxBreakdown": "Components and Props explained:\n\n1. **Function Component** (modern standard):\n   ```jsx\n   function Welcome(props) {\n     return <h1>Hello, {props.name}!</h1>;\n   }\n   \n   // Use it:\n   <Welcome name=\"Alice\" />\n   ```\n\n2. **Props Object**:\n   ```jsx\n   function UserCard(props) {\n     // props = { name: 'Alice', age: 25, email: 'alice@...' }\n     return (\n       <div>\n         <h2>{props.name}</h2>\n         <p>Age: {props.age}</p>\n         <p>Email: {props.email}</p>\n       </div>\n     );\n   }\n   ```\n\n3. **Destructuring Props** (recommended):\n   ```jsx\n   // Instead of props.name, props.age...\n   function UserCard({ name, age, email }) {\n     return (\n       <div>\n         <h2>{name}</h2>\n         <p>Age: {age}</p>\n         <p>Email: {email}</p>\n       </div>\n     );\n   }\n   ```\n\n4. **Default Props**:\n   ```jsx\n   function Button({ label, color = 'blue', size = 'medium' }) {\n     return <button style={{ backgroundColor: color }}>{label}</button>;\n   }\n   \n   // Uses defaults:\n   <Button label=\"Click\" />  // blue, medium\n   \n   // Override defaults:\n   <Button label=\"Submit\" color=\"green\" size=\"large\" />\n   ```\n\n5. **Children Prop** (special):\n   ```jsx\n   function Card({ title, children }) {\n     return (\n       <div className=\"card\">\n         <h3>{title}</h3>\n         <div className=\"card-body\">\n           {children}\n         </div>\n       </div>\n     );\n   }\n   \n   // Use with children:\n   <Card title=\"My Card\">\n     <p>This is the content</p>\n     <button>Action</button>\n   </Card>\n   ```\n\n6. **Passing Functions as Props**:\n   ```jsx\n   function Button({ label, onClick }) {\n     return <button onClick={onClick}>{label}</button>;\n   }\n   \n   // Parent passes function:\n   function App() {\n     function handleClick() {\n       console.log('Clicked!');\n     }\n     \n     return <Button label=\"Click Me\" onClick={handleClick} />;\n   }\n   ```\n\n7. **Component Composition**:\n   ```jsx\n   function App() {\n     return (\n       <div>\n         <Header />\n         <Sidebar />\n         <MainContent>\n           <Article title=\"Hello\" />\n           <Article title=\"World\" />\n         </MainContent>\n         <Footer />\n       </div>\n     );\n   }\n   ```",
      "challenge": {
        "instructions": "Create reusable components with props:\n\n1. Create a `BlogPost` function that takes props:\n   - title\n   - author\n   - content\n   - Returns formatted HTML string\n\n2. Create an `AuthorBio` function that takes:\n   - name\n   - bio\n   - Returns formatted HTML string\n\n3. Create a `Blog` function that:\n   - Uses BlogPost twice with different data\n   - Uses AuthorBio once\n   - Returns complete blog page\n\nTest by calling Blog() and logging result.",
        "starterCode": "// Component functions\n\nfunction BlogPost({ title, author, content }) {\n  return `\n    <article className=\"blog-post\">\n      <h2>${title}</h2>\n      <p className=\"author\">By ${author}</p>\n      <p>${content}</p>\n    </article>\n  `;\n}\n\nfunction AuthorBio({ name, bio }) {\n  return `\n    <div className=\"author-bio\">\n      <h3>About ${name}</h3>\n      <p>${bio}</p>\n    </div>\n  `;\n}\n\nfunction Blog() {\n  return `\n    <div className=\"blog\">\n      <h1>My Blog</h1>\n      ${BlogPost({\n        title: 'Learning React',\n        author: 'Alice',\n        content: 'React is amazing for building UIs!'\n      })}\n      ${BlogPost({\n        title: 'Understanding Props',\n        author: 'Alice',\n        content: 'Props make components reusable.'\n      })}\n      ${AuthorBio({\n        name: 'Alice',\n        bio: 'Web developer and React enthusiast.'\n      })}\n    </div>\n  `;\n}\n\nconsole.log(Blog());",
        "testCases": [
          {
            "description": "Should use props in template",
            "input": "let post = { title: 'Test', author: 'Bob' }; `<h2>${post.title}</h2><p>By ${post.author}</p>`",
            "expectedOutput": "<h2>Test</h2><p>By Bob</p>"
          }
        ],
        "hint": "Use destructuring in function parameters and template literals for HTML."
      },
      "solution": "// Complete component system with props\n\nfunction BlogPost({ title, author, content, date = 'Today' }) {\n  return `\n    <article className=\"blog-post\">\n      <h2>${title}</h2>\n      <div className=\"meta\">\n        <span className=\"author\">By ${author}</span>\n        <span className=\"date\">${date}</span>\n      </div>\n      <p className=\"content\">${content}</p>\n    </article>\n  `;\n}\n\nfunction AuthorBio({ name, bio, avatar = 'default-avatar.png' }) {\n  return `\n    <div className=\"author-bio\">\n      <img src=\"${avatar}\" alt=\"${name}\" className=\"avatar\" />\n      <h3>About ${name}</h3>\n      <p>${bio}</p>\n    </div>\n  `;\n}\n\nfunction CommentSection({ comments = [] }) {\n  if (comments.length === 0) {\n    return '<p>No comments yet.</p>';\n  }\n  \n  return `\n    <div className=\"comments\">\n      <h3>${comments.length} Comment${comments.length !== 1 ? 's' : ''}</h3>\n      ${comments.map(c => `\n        <div className=\"comment\">\n          <strong>${c.author}:</strong> ${c.text}\n        </div>\n      `).join('')}\n    </div>\n  `;\n}\n\nfunction Blog() {\n  let posts = [\n    {\n      title: 'Getting Started with React',\n      author: 'Alice Johnson',\n      content: 'React makes building user interfaces simple and enjoyable!',\n      date: 'Jan 15, 2025'\n    },\n    {\n      title: 'Understanding Props and Components',\n      author: 'Alice Johnson',\n      content: 'Props are the way we pass data between components.',\n      date: 'Jan 16, 2025'\n    }\n  ];\n  \n  let comments = [\n    { author: 'Bob', text: 'Great article!' },\n    { author: 'Charlie', text: 'Very helpful, thanks!' }\n  ];\n  \n  return `\n    <div className=\"blog\">\n      <header>\n        <h1>My React Blog</h1>\n      </header>\n      \n      <main>\n        ${posts.map(post => BlogPost(post)).join('\\n')}\n      </main>\n      \n      <aside>\n        ${AuthorBio({\n          name: 'Alice Johnson',\n          bio: 'Full-stack developer passionate about React and modern web development.',\n          avatar: 'alice-avatar.jpg'\n        })}\n      </aside>\n      \n      ${CommentSection({ comments })}\n    </div>\n  `;\n}\n\nconsole.log('=== Complete Blog Application ===\\n');\nconsole.log(Blog());\n\n// Demonstrate component reusability\nconsole.log('\\n=== Reusability Demo ===\\n');\nconsole.log('Creating 3 blog posts with same component:');\n\nfor (let i = 1; i <= 3; i++) {\n  console.log(BlogPost({\n    title: `Post ${i}`,\n    author: 'Demo Author',\n    content: `Content for post number ${i}`\n  }));\n}",
      "commonStickingPoints": "Common component/props mistakes:\n\n1. **Modifying props (forbidden!)**:\n   ```jsx\n   function UserCard(props) {\n     props.name = 'Different';  // ERROR! Props are read-only!\n     return <h1>{props.name}</h1>;\n   }\n   ```\n   Props flow down (parent → child) and cannot be changed by child.\n\n2. **Forgetting to pass props**:\n   ```jsx\n   function Greeting({ name }) {\n     return <h1>Hello, {name}!</h1>;\n   }\n   \n   // Wrong!\n   <Greeting />  // name is undefined!\n   \n   // Correct!\n   <Greeting name=\"Alice\" />\n   ```\n\n3. **Component name not capitalized**:\n   ```jsx\n   // Wrong!\n   function greeting() {  // lowercase!\n     return <h1>Hello</h1>;\n   }\n   \n   // Correct!\n   function Greeting() {  // PascalCase!\n     return <h1>Hello</h1>;\n   }\n   ```\n   React treats lowercase as HTML tags, uppercase as components.\n\n4. **Not destructuring (verbose)**:\n   ```jsx\n   // Works but verbose:\n   function UserCard(props) {\n     return <div>{props.name} - {props.email} - {props.age}</div>;\n   }\n   \n   // Better (destructured):\n   function UserCard({ name, email, age }) {\n     return <div>{name} - {email} - {age}</div>;\n   }\n   ```\n\n5. **Missing key in lists**:\n   ```jsx\n   // Wrong!\n   {users.map(user => <UserCard {...user} />)}\n   \n   // Correct!\n   {users.map(user => <UserCard key={user.id} {...user} />)}\n   ```\n   React needs keys to track which items changed.\n\n6. **Passing strings incorrectly**:\n   ```jsx\n   // Wrong!\n   <UserCard age=\"25\" />     // age is string \"25\", not number!\n   \n   // Correct!\n   <UserCard age={25} />     // age is number 25\n   \n   // Strings don't need braces:\n   <UserCard name=\"Alice\" /> // OK\n   <UserCard name={'Alice'} /> // Also OK but unnecessary\n   ```\n\n7. **Inline object props (causes re-renders)**:\n   ```jsx\n   // Avoid (creates new object every render):\n   <UserCard style={{ color: 'red' }} />\n   \n   // Better (define outside):\n   const cardStyle = { color: 'red' };\n   <UserCard style={cardStyle} />\n   ```"
    },
    {
      "id": "12.3",
      "title": "useState Hook - Giving Components Memory (The Light Switch Analogy)",
      "conceptAnalogy": "Think of a light switch in your house:\n\nWithout state (broken switch):\n- You flip the switch up\n- Light turns on for a moment\n- Switch immediately resets to off\n- Light goes back off\n- Can't remember if it was on or off!\n\nWith state (working switch):\n- You flip switch up → light turns ON\n- Switch REMEMBERS it's on\n- Stays on until you flip it down\n- Switch REMEMBERS it's off\n- State = Current position of the switch\n\nReact useState is like giving your component a working switch:\n- Component can remember values between renders\n- When state changes → component re-renders\n- UI updates automatically to show new state\n- Perfect for: counters, form inputs, toggles, user data!",
      "codeExample": "// useState Hook - Component Memory\n\nconsole.log('=== React useState Hook ===\\n');\n\n// WHY WE NEED STATE\nconsole.log('--- Without State (Doesn\\'t Work!) ---\\n');\n\nfunction simulateComponentWithoutState() {\n  let count = 0;  // Regular variable\n  \n  console.log('[Component] Initial render: count =', count);\n  \n  // User clicks button\n  console.log('[User] Clicks +1 button');\n  count = count + 1;\n  console.log('[Component] count =', count, '(but component doesn\\'t re-render!)');\n  \n  // Component renders again (for some reason)\n  count = 0;  // RESETS! Regular variables don't persist\n  console.log('[Component] Re-render: count =', count, '(LOST the value!)');\n}\n\nsimulateComponentWithoutState();\n\n// WITH STATE (Works!)\nconsole.log('\\n--- With useState (Works!) ---\\n');\n\nfunction simulateComponentWithState() {\n  // useState hook - PERSISTS between renders\n  let state = {\n    count: 0,\n    setCount: function(newValue) {\n      this.count = newValue;\n      console.log('[State Update] count changed to:', newValue);\n      console.log('[React] Re-rendering component...');\n    }\n  };\n  \n  console.log('[Component] Initial render: count =', state.count);\n  \n  // User clicks button\n  console.log('\\n[User] Clicks +1 button');\n  state.setCount(state.count + 1);\n  console.log('[Component] Re-render: count =', state.count, '(PERSISTED!)');\n  \n  // User clicks again\n  console.log('\\n[User] Clicks +1 button again');\n  state.setCount(state.count + 1);\n  console.log('[Component] Re-render: count =', state.count);\n}\n\nsimulateComponentWithState();\n\n// REAL useState SYNTAX\nconsole.log('\\n\\n=== useState Syntax ===\\n');\n\nconsole.log('// Import from React');\nconsole.log('import { useState } from \"react\";\\n');\n\nconsole.log('function Counter() {');\nconsole.log('  // useState returns [currentValue, setterFunction]');\nconsole.log('  const [count, setCount] = useState(0);');\nconsole.log('  //      ^^^^^  ^^^^^^^^          ^^^');\nconsole.log('  //      value  updater          initial value\\n');\n\nconsole.log('  function increment() {');\nconsole.log('    setCount(count + 1);  // Update state');\nconsole.log('  }\\n');\n\nconsole.log('  return (');\nconsole.log('    <div>');\nconsole.log('      <p>Count: {count}</p>');\nconsole.log('      <button onClick={increment}>+1</button>');\nconsole.log('    </div>');\nconsole.log('  );');\nconsole.log('}\\n');\n\n// MULTIPLE STATE VARIABLES\nconsole.log('=== Multiple State Variables ===\\n');\n\nconsole.log('function UserProfile() {');\nconsole.log('  const [name, setName] = useState(\"Alice\");');\nconsole.log('  const [age, setAge] = useState(25);');\nconsole.log('  const [isLoggedIn, setIsLoggedIn] = useState(false);\\n');\n\nconsole.log('  // Each state is independent!');\nconsole.log('  setName(\"Bob\");        // Only updates name');\nconsole.log('  setAge(30);           // Only updates age');\nconsole.log('  setIsLoggedIn(true);  // Only updates isLoggedIn');\nconsole.log('}\\n');\n\n// STATE WITH OBJECTS\nconsole.log('=== State with Objects ===\\n');\n\nlet userState = {\n  user: { name: 'Alice', age: 25, email: 'alice@example.com' },\n  setUser: function(newUser) {\n    // MUST create new object (don't mutate!)\n    this.user = { ...this.user, ...newUser };\n    console.log('[State] Updated user:', this.user);\n  }\n};\n\nconsole.log('Initial user:', userState.user);\n\nconsole.log('\\nUpdating age:');\nuserState.setUser({ age: 26 });  // Spread syntax preserves other fields\n\nconsole.log('\\n// WRONG way (mutation):');\nconsole.log('user.age = 26;        // ✗ Don\\'t mutate directly!');\nconsole.log('setUser(user);       // ✗ React won\\'t detect change!\\n');\n\nconsole.log('// CORRECT way (new object):');\nconsole.log('setUser({ ...user, age: 26 });  // ✓ Creates new object');\n\n// STATE WITH ARRAYS\nconsole.log('\\n\\n=== State with Arrays ===\\n');\n\nlet todosState = {\n  todos: ['Learn React', 'Build app'],\n  setTodos: function(newTodos) {\n    this.todos = newTodos;\n    console.log('[State] Updated todos:', this.todos);\n  }\n};\n\nconsole.log('Initial todos:', todosState.todos);\n\nconsole.log('\\nAdding todo:');\ntodosState.setTodos([...todosState.todos, 'Deploy app']);\n\nconsole.log('\\nRemoving first todo:');\ntodosState.setTodos(todosState.todos.slice(1));\n\nconsole.log('\\n--- Array State Patterns ---');\nconsole.log('Add item:    setTodos([...todos, newItem])');\nconsole.log('Remove item: setTodos(todos.filter(t => t.id !== id))');\nconsole.log('Update item: setTodos(todos.map(t => t.id === id ? updated : t))');",
      "syntaxBreakdown": "useState Hook explained:\n\n1. **Basic useState**:\n   ```jsx\n   import { useState } from 'react';\n   \n   function Counter() {\n     const [count, setCount] = useState(0);\n     //      ^^^^^  ^^^^^^^^          ^^^\n     //      state  setter           initial value\n     \n     return (\n       <div>\n         <p>{count}</p>\n         <button onClick={() => setCount(count + 1)}>+1</button>\n       </div>\n     );\n   }\n   ```\n\n2. **Array Destructuring** (what [count, setCount] means):\n   ```jsx\n   // useState returns an array: [value, setter]\n   const stateArray = useState(0);  // [0, function]\n   const count = stateArray[0];     // Get value\n   const setCount = stateArray[1];  // Get setter\n   \n   // Shorthand (array destructuring):\n   const [count, setCount] = useState(0);  // Same thing!\n   ```\n\n3. **Initial Value**:\n   ```jsx\n   const [count, setCount] = useState(0);      // Number\n   const [name, setName] = useState('Alice');  // String\n   const [isOpen, setIsOpen] = useState(false); // Boolean\n   const [items, setItems] = useState([]);     // Array\n   const [user, setUser] = useState({ name: 'Alice' }); // Object\n   ```\n\n4. **Updating State**:\n   ```jsx\n   // Simple value\n   setCount(5);           // Set to 5\n   setCount(count + 1);   // Increment\n   \n   // Using previous value (safer)\n   setCount(prevCount => prevCount + 1);\n   ```\n\n5. **Multiple State Variables**:\n   ```jsx\n   function Form() {\n     const [name, setName] = useState('');\n     const [email, setEmail] = useState('');\n     const [age, setAge] = useState(0);\n     \n     // Each is independent\n   }\n   ```\n\n6. **State with Objects** (must spread!):\n   ```jsx\n   const [user, setUser] = useState({ name: 'Alice', age: 25 });\n   \n   // WRONG!\n   user.age = 26;         // Don't mutate!\n   setUser(user);         // React won't detect change\n   \n   // CORRECT!\n   setUser({ ...user, age: 26 });  // Create new object\n   ```\n\n7. **State with Arrays**:\n   ```jsx\n   const [items, setItems] = useState([1, 2, 3]);\n   \n   // Add item\n   setItems([...items, 4]);\n   setItems([newItem, ...items]);  // Add to beginning\n   \n   // Remove item\n   setItems(items.filter((item, index) => index !== 0));\n   \n   // Update item\n   setItems(items.map((item, i) => i === 1 ? newValue : item));\n   ```\n\n8. **Lazy Initial State** (expensive calculation):\n   ```jsx\n   // WRONG! (runs every render)\n   const [data, setData] = useState(expensiveCalculation());\n   \n   // CORRECT! (runs once)\n   const [data, setData] = useState(() => expensiveCalculation());\n   ```",
      "challenge": {
        "instructions": "Simulate a counter component with state:\n\n1. Create a `Counter` object with:\n   - state: { count: 0 }\n   - setCount(newValue) method that updates count and logs it\n   - increment() method that calls setCount with count + 1\n   - decrement() method that calls setCount with count - 1\n   - reset() method that calls setCount with 0\n\n2. Test all methods and log the count after each operation",
        "starterCode": "// Counter with state\n\nlet Counter = {\n  state: { count: 0 },\n  \n  setCount(newValue) {\n    this.state.count = newValue;\n    console.log('[State] count =', this.state.count);\n  },\n  \n  increment() {\n    this.setCount(this.state.count + 1);\n  },\n  \n  decrement() {\n    this.setCount(this.state.count - 1);\n  },\n  \n  reset() {\n    this.setCount(0);\n  },\n  \n  getCount() {\n    return this.state.count;\n  }\n};\n\n// Test\nconsole.log('Initial count:', Counter.getCount());\n\nCounter.increment();\nCounter.increment();\nCounter.increment();\nCounter.decrement();\nCounter.reset();\n\nconsole.log('Final count:', Counter.getCount());",
        "testCases": [
          {
            "description": "Should increment count",
            "input": "let count = 0; count = count + 1; count",
            "expectedOutput": "1"
          },
          {
            "description": "Should decrement count",
            "input": "let count = 5; count = count - 1; count",
            "expectedOutput": "4"
          }
        ],
        "hint": "Use this.state.count to access current count, and this.setCount() to update it"
      },
      "solution": "// Complete state management simulation\n\nlet Counter = {\n  state: { count: 0 },\n  listeners: [],\n  \n  setCount(newValue) {\n    let oldValue = this.state.count;\n    this.state.count = newValue;\n    console.log(`[State Update] count: ${oldValue} → ${newValue}`);\n    console.log('[React] Re-rendering component...');\n    this.notifyListeners();\n  },\n  \n  increment() {\n    console.log('[Action] Increment');\n    this.setCount(this.state.count + 1);\n  },\n  \n  decrement() {\n    console.log('[Action] Decrement');\n    this.setCount(this.state.count - 1);\n  },\n  \n  incrementBy(amount) {\n    console.log(`[Action] Increment by ${amount}`);\n    this.setCount(this.state.count + amount);\n  },\n  \n  reset() {\n    console.log('[Action] Reset');\n    this.setCount(0);\n  },\n  \n  getCount() {\n    return this.state.count;\n  },\n  \n  // Subscribe to changes\n  onChange(callback) {\n    this.listeners.push(callback);\n  },\n  \n  notifyListeners() {\n    this.listeners.forEach(fn => fn(this.state.count));\n  },\n  \n  render() {\n    console.log('\\n[Render] Counter UI:');\n    console.log(`┌─────────────────┐`);\n    console.log(`│  Count: ${String(this.state.count).padEnd(6)} │`);\n    console.log(`├─────────────────┤`);\n    console.log(`│  [ - ] [ + ]    │`);\n    console.log(`│  [ Reset ]      │`);\n    console.log(`└─────────────────┘\\n`);\n  }\n};\n\n// Advanced: TodoList with state\nlet TodoList = {\n  state: {\n    todos: [],\n    nextId: 1\n  },\n  \n  setTodos(newTodos) {\n    this.state.todos = newTodos;\n    console.log('[State] todos updated:', newTodos.length, 'items');\n  },\n  \n  addTodo(text) {\n    console.log(`[Action] Add todo: \"${text}\"`);\n    let newTodo = {\n      id: this.state.nextId++,\n      text: text,\n      completed: false\n    };\n    // Must create NEW array (don't mutate!)\n    this.setTodos([...this.state.todos, newTodo]);\n  },\n  \n  toggleTodo(id) {\n    console.log(`[Action] Toggle todo ${id}`);\n    this.setTodos(\n      this.state.todos.map(todo =>\n        todo.id === id\n          ? { ...todo, completed: !todo.completed }  // New object\n          : todo\n      )\n    );\n  },\n  \n  deleteTodo(id) {\n    console.log(`[Action] Delete todo ${id}`);\n    this.setTodos(\n      this.state.todos.filter(todo => todo.id !== id)\n    );\n  },\n  \n  render() {\n    console.log('\\n[Render] Todo List:');\n    if (this.state.todos.length === 0) {\n      console.log('  No todos yet!');\n    } else {\n      this.state.todos.forEach(todo => {\n        let checkbox = todo.completed ? '[✓]' : '[ ]';\n        let text = todo.completed ? `(${todo.text})` : todo.text;\n        console.log(`  ${checkbox} ${text}`);\n      });\n    }\n    console.log('');\n  }\n};\n\n// Run simulations\nconsole.log('=== Counter Simulation ===\\n');\n\nCounter.render();\n\nconsole.log('User clicks +1 three times:');\nCounter.increment();\nCounter.increment();\nCounter.increment();\nCounter.render();\n\nconsole.log('User clicks -1:');\nCounter.decrement();\nCounter.render();\n\nconsole.log('User clicks reset:');\nCounter.reset();\nCounter.render();\n\nconsole.log('\\n=== TodoList Simulation ===\\n');\n\nTodoList.render();\n\nTodoList.addTodo('Learn useState');\nTodoList.addTodo('Build a counter app');\nTodoList.addTodo('Master React');\nTodoList.render();\n\nconsole.log('User completes first todo:');\nTodoList.toggleTodo(1);\nTodoList.render();\n\nconsole.log('User deletes second todo:');\nTodoList.deleteTodo(2);\nTodoList.render();\n\nconsole.log('=== Key Takeaways ===\\n');\nlet takeaways = [\n  '✓ useState gives components memory',\n  '✓ State updates trigger re-renders',\n  '✓ Never mutate state directly',\n  '✓ Always create new objects/arrays',\n  '✓ Use setCount(prev => prev + 1) for updates based on previous',\n  '✓ Can have multiple state variables',\n  '✓ Each state is independent'\n];\ntakeaways.forEach(t => console.log(t));",
      "commonStickingPoints": "Common useState mistakes:\n\n1. **Mutating state directly**:\n   ```jsx\n   // WRONG!\n   const [user, setUser] = useState({ name: 'Alice' });\n   user.name = 'Bob';     // Don't mutate!\n   setUser(user);         // React won't re-render\n   \n   // CORRECT!\n   setUser({ ...user, name: 'Bob' });  // New object\n   ```\n\n2. **Forgetting to use setter**:\n   ```jsx\n   const [count, setCount] = useState(0);\n   \n   // WRONG!\n   count = count + 1;     // Won't work!\n   \n   // CORRECT!\n   setCount(count + 1);   // Use setter\n   ```\n\n3. **Using state immediately after setting**:\n   ```jsx\n   const [count, setCount] = useState(0);\n   \n   function increment() {\n     setCount(count + 1);\n     console.log(count);    // Still 0! (state updates are async)\n   }\n   \n   // Use useEffect or callback to see new value:\n   setCount(prevCount => {\n     console.log('Will be:', prevCount + 1);\n     return prevCount + 1;\n   });\n   ```\n\n4. **Multiple setStates based on current state**:\n   ```jsx\n   // WRONG! (race condition)\n   setCount(count + 1);\n   setCount(count + 1);\n   setCount(count + 1);\n   // Count only increases by 1!\n   \n   // CORRECT!\n   setCount(c => c + 1);\n   setCount(c => c + 1);\n   setCount(c => c + 1);\n   // Count increases by 3!\n   ```\n\n5. **Mutating arrays**:\n   ```jsx\n   const [items, setItems] = useState([1, 2, 3]);\n   \n   // WRONG!\n   items.push(4);         // Mutates!\n   setItems(items);       // Won't re-render\n   \n   // CORRECT!\n   setItems([...items, 4]);  // New array\n   \n   // Other array operations:\n   setItems(items.filter(i => i !== 2));    // Remove\n   setItems(items.map(i => i === 2 ? 5 : i)); // Update\n   ```\n\n6. **Forgetting initial value**:\n   ```jsx\n   // WRONG!\n   const [count, setCount] = useState();  // undefined!\n   \n   // CORRECT!\n   const [count, setCount] = useState(0);  // Start at 0\n   ```\n\n7. **Using if/loops in component body with useState**:\n   ```jsx\n   // WRONG! (hooks must be at top level)\n   function MyComponent({ condition }) {\n     if (condition) {\n       const [state, setState] = useState(0);  // Error!\n     }\n   }\n   \n   // CORRECT!\n   function MyComponent({ condition }) {\n     const [state, setState] = useState(0);  // Always call\n     \n     if (condition) {\n       // Use state here\n     }\n   }\n   ```"
    },
    {
      "id": "12.4",
      "title": "Event Handling - Responding to User Actions (The Doorbell Analogy)",
      "conceptAnalogy": "Imagine your house has a doorbell:\n\nPassive House (no doorbell):\n- Visitors knock\n- You don't hear them\n- Nothing happens\n- Frustrating for visitors!\n\nActive House (with doorbell):\n- Doorbell LISTENS for button press\n- Visitor presses button\n- Doorbell RESPONDS by ringing\n- You REACT by answering the door\n\nReact events work the same way:\n- Components LISTEN for events (onClick, onChange, etc.)\n- User performs action (click, type, submit)\n- Event handler RESPONDS\n- Component state updates → UI re-renders\n\nWithout event listeners → Your UI can't respond to users!",
      "codeExample": "// React Event Handling\n\nconsole.log('=== Event Handling in React ===\\n');\n\n// CONCEPT: Event Listeners\nlet button = {\n  label: 'Click Me',\n  clickCount: 0,\n  \n  // Event handler function\n  handleClick: function() {\n    this.clickCount++;\n    console.log(`[Event] Button clicked! Total clicks: ${this.clickCount}`);\n  }\n};\n\n// Simulate user clicking button\nconsole.log('Button label:', button.label);\nconsole.log('\\nUser clicks button 3 times:\\n');\nbutton.handleClick();\nbutton.handleClick();\nbutton.handleClick();\n\n// COMMON EVENT TYPES\nconsole.log('\\n=== Common React Events ===\\n');\n\nlet events = {\n  'onClick': 'Button clicks, div clicks, any element click',\n  'onChange': 'Input field changes (text input, checkbox, select)',\n  'onSubmit': 'Form submission',\n  'onMouseEnter': 'Mouse cursor enters element',\n  'onMouseLeave': 'Mouse cursor leaves element',\n  'onKeyDown': 'Key pressed down',\n  'onKeyUp': 'Key released',\n  'onFocus': 'Element receives focus (clicked or tabbed to)',\n  'onBlur': 'Element loses focus'\n};\n\nfor (let [event, description] of Object.entries(events)) {\n  console.log(`${event.padEnd(15)} - ${description}`);\n}\n\n// REACT SYNTAX\nconsole.log('\\n\\n=== Event Handler Syntax ===\\n');\n\nconsole.log('// Method 1: Inline arrow function');\nconsole.log('<button onClick={() => console.log(\"Clicked!\")}>Click</button>\\n');\n\nconsole.log('// Method 2: Named function reference');\nconsole.log('function handleClick() {');\nconsole.log('  console.log(\"Clicked!\");');\nconsole.log('}');\nconsole.log('<button onClick={handleClick}>Click</button>\\n');\n\nconsole.log('// Method 3: With event object');\nconsole.log('function handleClick(event) {');\nconsole.log('  console.log(\"Button:\", event.target);');\nconsole.log('}');\nconsole.log('<button onClick={handleClick}>Click</button>\\n');\n\n// EVENT OBJECT\nconsole.log('=== The Event Object ===\\n');\n\nlet simulatedEvent = {\n  target: { tagName: 'BUTTON', textContent: 'Click Me', value: '' },\n  type: 'click',\n  preventDefault: function() {\n    console.log('[Event] Default action prevented');\n  },\n  stopPropagation: function() {\n    console.log('[Event] Event propagation stopped');\n  }\n};\n\nfunction handleEvent(event) {\n  console.log('Event type:', event.type);\n  console.log('Target element:', event.target.tagName);\n  console.log('Button text:', event.target.textContent);\n}\n\nconsole.log('Simulating click event:\\n');\nhandleEvent(simulatedEvent);\n\n// FORM HANDLING\nconsole.log('\\n\\n=== Form Event Handling ===\\n');\n\nlet form = {\n  state: { name: '', email: '' },\n  \n  handleNameChange: function(event) {\n    this.state.name = event.target.value;\n    console.log('[Input] Name:', this.state.name);\n  },\n  \n  handleEmailChange: function(event) {\n    this.state.email = event.target.value;\n    console.log('[Input] Email:', this.state.email);\n  },\n  \n  handleSubmit: function(event) {\n    event.preventDefault();\n    console.log('[Submit] Form data:', this.state);\n  }\n};\n\nconsole.log('User types in name field:');\nform.handleNameChange({ target: { value: 'Alice' } });\nform.handleNameChange({ target: { value: 'Alice J' } });\nform.handleNameChange({ target: { value: 'Alice Johnson' } });\n\nconsole.log('\\nUser types in email field:');\nform.handleEmailChange({ target: { value: 'alice@example.com' } });\n\nconsole.log('\\nUser submits form:');\nform.handleSubmit({ preventDefault: () => console.log('[Browser] Default submit prevented') });\n\n// REAL REACT EXAMPLE\nconsole.log('\\n\\n=== Complete React Example ===\\n');\n\nconsole.log('import { useState } from \"react\";\\n');\n\nconsole.log('function LoginForm() {');\nconsole.log('  const [email, setEmail] = useState(\"\");');\nconsole.log('  const [password, setPassword] = useState(\"\");\\n');\n\nconsole.log('  function handleSubmit(event) {');\nconsole.log('    event.preventDefault();  // Don\\'t reload page');\nconsole.log('    console.log(\"Login:\", email, password);');\nconsole.log('  }\\n');\n\nconsole.log('  return (');\nconsole.log('    <form onSubmit={handleSubmit}>');\nconsole.log('      <input');\nconsole.log('        type=\"email\"');\nconsole.log('        value={email}');\nconsole.log('        onChange={(e) => setEmail(e.target.value)}');\nconsole.log('      />');\nconsole.log('      <input');\nconsole.log('        type=\"password\"');\nconsole.log('        value={password}');\nconsole.log('        onChange={(e) => setPassword(e.target.value)}');\nconsole.log('      />');\nconsole.log('      <button type=\"submit\">Login</button>');\nconsole.log('    </form>');\nconsole.log('  );');\nconsole.log('}');\n\n// EVENT PATTERNS\nconsole.log('\\n\\n=== Common Event Patterns ===\\n');\n\nlet patterns = [\n  {    pattern: 'Button Click',\n    code: '<button onClick={handleClick}>Click</button>'\n  },\n  {\n    pattern: 'Input Change',\n    code: '<input onChange={(e) => setValue(e.target.value)} />'\n  },\n  {\n    pattern: 'Form Submit',\n    code: '<form onSubmit={handleSubmit}>...</form>'\n  },\n  {\n    pattern: 'Checkbox Toggle',\n    code: '<input type=\"checkbox\" onChange={(e) => setChecked(e.target.checked)} />'\n  },\n  {\n    pattern: 'Keyboard Event',\n    code: '<input onKeyDown={(e) => e.key === \"Enter\" && submit()} />'\n  },\n  {\n    pattern: 'Mouse Hover',\n    code: '<div onMouseEnter={handleEnter} onMouseLeave={handleLeave}>'\n  }\n];\n\npatterns.forEach(p => {\n  console.log(`${p.pattern}:`);\n  console.log(`  ${p.code}\\n`);\n});",
      "syntaxBreakdown": "Event handling explained:\n\n1. **Basic onClick**:\n   ```jsx\n   function MyButton() {\n     function handleClick() {\n       console.log('Clicked!');\n     }\n     \n     return <button onClick={handleClick}>Click Me</button>;\n     //                      ^^^^^^^^^^^^\n     //                      Function REFERENCE (no parentheses!)\n   }\n   ```\n\n2. **Inline Arrow Function**:\n   ```jsx\n   <button onClick={() => console.log('Clicked!')}>Click</button>\n   \n   // With state update:\n   <button onClick={() => setCount(count + 1)}>+1</button>\n   ```\n\n3. **Event Object** (e or event):\n   ```jsx\n   function handleClick(event) {\n     console.log('Clicked element:', event.target);\n     console.log('Click position:', event.clientX, event.clientY);\n   }\n   \n   <button onClick={handleClick}>Click</button>\n   ```\n\n4. **Form Events** (onChange, onSubmit):\n   ```jsx\n   function Form() {\n     const [name, setName] = useState('');\n     \n     function handleSubmit(e) {\n       e.preventDefault();  // DON'T reload page!\n       console.log('Submitted:', name);\n     }\n     \n     return (\n       <form onSubmit={handleSubmit}>\n         <input\n           value={name}\n           onChange={(e) => setName(e.target.value)}\n           //                        ^^^^^^^^^^^^^\n           //                        Get input value\n         />\n         <button type=\"submit\">Submit</button>\n       </form>\n     );\n   }\n   ```\n\n5. **Passing Arguments** to event handlers:\n   ```jsx\n   // WRONG!\n   <button onClick={handleClick(id)}>  // Calls immediately!\n   \n   // CORRECT!\n   <button onClick={() => handleClick(id)}>  // Calls when clicked\n   <button onClick={handleClick.bind(null, id)}>  // Alternative\n   ```\n\n6. **Multiple Events**:\n   ```jsx\n   <div\n     onClick={handleClick}\n     onMouseEnter={handleEnter}\n     onMouseLeave={handleLeave}\n   >\n     Hover and click me!\n   </div>\n   ```\n\n7. **Controlled Inputs** (input value tied to state):\n   ```jsx\n   const [text, setText] = useState('');\n   \n   <input\n     value={text}              // Controlled by state\n     onChange={(e) => setText(e.target.value)}\n   />\n   ```\n\n8. **Checkbox Events**:\n   ```jsx\n   const [checked, setChecked] = useState(false);\n   \n   <input\n     type=\"checkbox\"\n     checked={checked}\n     onChange={(e) => setChecked(e.target.checked)}\n     //                            ^^^^^^^^^^^^^\n     //                            For checkboxes!\n   />\n   ```\n\n9. **Keyboard Events**:\n   ```jsx\n   function handleKeyDown(e) {\n     if (e.key === 'Enter') {\n       submit();\n     }\n     if (e.key === 'Escape') {\n       cancel();\n     }\n   }\n   \n   <input onKeyDown={handleKeyDown} />\n   ```\n\n10. **Prevent Default & Stop Propagation**:\n   ```jsx\n   function handleSubmit(e) {\n     e.preventDefault();     // Don't submit form\n     e.stopPropagation();    // Don't bubble up to parent\n     // Your code here\n   }\n   ```",
      "challenge": {
        "instructions": "Create an interactive counter with event handling:\n\n1. Create a `CounterApp` object with:\n   - state: { count: 0, history: [] }\n   - handleIncrement() - increases count, adds to history\n   - handleDecrement() - decreases count, adds to history\n   - handleReset() - resets count to 0, clears history\n   - render() - displays current count and history\n\n2. Simulate user interactions and show the results",
        "starterCode": "// Interactive Counter App\n\nlet CounterApp = {\n  state: {\n    count: 0,\n    history: []\n  },\n  \n  handleIncrement() {\n    this.state.count++;\n    this.state.history.push('+1');\n    console.log('[Event] Increment → count:', this.state.count);\n  },\n  \n  handleDecrement() {\n    this.state.count--;\n    this.state.history.push('-1');\n    console.log('[Event] Decrement → count:', this.state.count);\n  },\n  \n  handleReset() {\n    this.state.count = 0;\n    this.state.history = [];\n    console.log('[Event] Reset → count:', this.state.count);\n  },\n  \n  render() {\n    console.log('\\n[Render]');\n    console.log('  Current Count:', this.state.count);\n    console.log('  History:', this.state.history.join(', ') || 'none');\n    console.log('');\n  }\n};\n\n// Simulate user interactions\nconsole.log('=== Counter App ===\\n');\n\nCounterApp.render();\n\nconsole.log('User clicks +1 button:');\nCounterApp.handleIncrement();\nCounterApp.render();\n\nconsole.log('User clicks +1 button again:');\nCounterApp.handleIncrement();\nCounterApp.render();\n\nconsole.log('User clicks -1 button:');\nCounterApp.handleDecrement();\nCounterApp.render();\n\nconsole.log('User clicks reset button:');\nCounterApp.handleReset();\nCounterApp.render();",
        "testCases": [
          {
            "description": "Should handle increment",
            "input": "let count = 0; count++; count",
            "expectedOutput": "1"
          },
          {
            "description": "Should track history",
            "input": "let history = []; history.push('+1'); history.length",
            "expectedOutput": "1"
          }
        ],
        "hint": "Update state in event handlers, then call render() to show changes"
      },
      "solution": "// Complete interactive app with event handling\n\nlet CounterApp = {\n  state: {\n    count: 0,\n    history: [],\n    lastAction: null\n  },\n  \n  handleIncrement() {\n    console.log('[Event] onClick={handleIncrement}');\n    this.state.count++;\n    this.state.history.push({ action: '+1', timestamp: Date.now() });\n    this.state.lastAction = 'increment';\n    this.render();\n  },\n  \n  handleDecrement() {\n    console.log('[Event] onClick={handleDecrement}');\n    this.state.count--;\n    this.state.history.push({ action: '-1', timestamp: Date.now() });\n    this.state.lastAction = 'decrement';\n    this.render();\n  },\n  \n  handleReset() {\n    console.log('[Event] onClick={handleReset}');\n    this.state.count = 0;\n    this.state.history = [];\n    this.state.lastAction = 'reset';\n    this.render();\n  },\n  \n  handleIncrementBy(amount) {\n    console.log(`[Event] onClick={() => handleIncrementBy(${amount})}`);\n    this.state.count += amount;\n    this.state.history.push({ action: `+${amount}`, timestamp: Date.now() });\n    this.render();\n  },\n  \n  render() {\n    console.log('\\n[React] Re-rendering component...');\n    console.log('┌────────────────────────────┐');\n    console.log(`│ Count: ${String(this.state.count).padEnd(19)} │`);\n    console.log('├────────────────────────────┤');\n    console.log('│ [ -1 ]  [ +1 ]  [ +5 ]     │');\n    console.log('│         [Reset]            │');\n    console.log('├────────────────────────────┤');\n    console.log(`│ Actions: ${String(this.state.history.length).padEnd(17)} │`);\n    if (this.state.history.length > 0) {\n      let recent = this.state.history.slice(-3).map(h => h.action).join(', ');\n      console.log(`│ Recent: ${recent.padEnd(18)} │`);\n    }\n    console.log('└────────────────────────────┘\\n');\n  }\n};\n\n// Form with event handling\nlet LoginForm = {\n  state: {\n    email: '',\n    password: '',\n    submitted: false,\n    errors: []\n  },\n  \n  handleEmailChange(event) {\n    console.log(`[Event] onChange={handleEmailChange}`);\n    this.state.email = event.target.value;\n    console.log(`  Email: \"${this.state.email}\"`);\n  },\n  \n  handlePasswordChange(event) {\n    console.log(`[Event] onChange={handlePasswordChange}`);\n    this.state.password = event.target.value;\n    console.log(`  Password: \"${'*'.repeat(this.state.password.length)}\"`);\n  },\n  \n  handleSubmit(event) {\n    console.log(`[Event] onSubmit={handleSubmit}`);\n    event.preventDefault();\n    \n    // Validation\n    this.state.errors = [];\n    if (!this.state.email.includes('@')) {\n      this.state.errors.push('Invalid email');\n    }\n    if (this.state.password.length < 6) {\n      this.state.errors.push('Password too short');\n    }\n    \n    if (this.state.errors.length === 0) {\n      this.state.submitted = true;\n      console.log('  ✓ Form valid! Logging in...');\n    } else {\n      console.log('  ✗ Form errors:', this.state.errors.join(', '));\n    }\n  },\n  \n  render() {\n    console.log('\\n[Render] Login Form');\n    console.log('  Email:', this.state.email || '(empty)');\n    console.log('  Password:', '*'.repeat(this.state.password.length) || '(empty)');\n    if (this.state.errors.length > 0) {\n      console.log('  Errors:', this.state.errors.join(', '));\n    }\n    if (this.state.submitted) {\n      console.log('  Status: ✓ Logged in!');\n    }\n    console.log('');\n  }\n};\n\n// Run simulations\nconsole.log('=== Counter App Simulation ===\\n');\n\nCounterApp.render();\n\nconsole.log('User clicks +1:');\nCounterApp.handleIncrement();\n\nconsole.log('User clicks +1 again:');\nCounterApp.handleIncrement();\n\nconsole.log('User clicks +5:');\nCounterApp.handleIncrementBy(5);\n\nconsole.log('User clicks -1:');\nCounterApp.handleDecrement();\n\nconsole.log('User clicks reset:');\nCounterApp.handleReset();\n\nconsole.log('\\n=== Login Form Simulation ===\\n');\n\nLoginForm.render();\n\nconsole.log('User types email:');\nLoginForm.handleEmailChange({ target: { value: 'a' } });\nLoginForm.handleEmailChange({ target: { value: 'al' } });\nLoginForm.handleEmailChange({ target: { value: 'alice@example.com' } });\nLoginForm.render();\n\nconsole.log('User types password:');\nLoginForm.handlePasswordChange({ target: { value: 'pass' } });\nLoginForm.render();\n\nconsole.log('User clicks submit (invalid):');\nLoginForm.handleSubmit({ preventDefault: () => {} });\nLoginForm.render();\n\nconsole.log('User fixes password:');\nLoginForm.handlePasswordChange({ target: { value: 'password123' } });\nLoginForm.render();\n\nconsole.log('User clicks submit (valid):');\nLoginForm.handleSubmit({ preventDefault: () => {} });\nLoginForm.render();\n\nconsole.log('=== Key Takeaways ===\\n');\nlet takeaways = [\n  '✓ Event handlers respond to user actions',\n  '✓ Use onClick, onChange, onSubmit, etc.',\n  '✓ Pass function reference, not call: onClick={handleClick}',\n  '✓ Access event with parameter: (e) => ...',\n  '✓ Use e.preventDefault() to prevent default behavior',\n  '✓ Controlled inputs: value={state} onChange={setState}',\n  '✓ Event updates state → state update triggers re-render'\n];\ntakeaways.forEach(t => console.log(t));",
      "commonStickingPoints": "Common event handling mistakes:\n\n1. **Calling function immediately instead of passing reference**:\n   ```jsx\n   // WRONG! (calls immediately on render)\n   <button onClick={handleClick()}>Click</button>\n   \n   // CORRECT! (passes function reference)\n   <button onClick={handleClick}>Click</button>\n   \n   // Or use arrow function:\n   <button onClick={() => handleClick()}>Click</button>\n   ```\n\n2. **Forgetting e.preventDefault() on forms**:\n   ```jsx\n   function handleSubmit(e) {\n     // WRONG! (page reloads)\n     console.log('Submitted');\n     \n     // CORRECT!\n     e.preventDefault();  // Stop page reload\n     console.log('Submitted');\n   }\n   ```\n\n3. **Wrong event property for inputs**:\n   ```jsx\n   // Text input\n   <input onChange={(e) => setValue(e.target.value)} />\n   //                                   ^^^^^ value for text\n   \n   // Checkbox\n   <input type=\"checkbox\" onChange={(e) => setChecked(e.target.checked)} />\n   //                                                   ^^^^^^^ checked for checkbox\n   ```\n\n4. **Not binding 'this' in class components**:\n   ```jsx\n   // Old class component issue (not relevant for function components)\n   class MyComponent extends React.Component {\n     handleClick() {\n       this.setState(...);  // 'this' is undefined!\n     }\n     \n     // Fix 1: Bind in constructor\n     constructor() {\n       this.handleClick = this.handleClick.bind(this);\n     }\n     \n     // Fix 2: Arrow function\n     handleClick = () => {\n       this.setState(...);\n     }\n   }\n   ```\n\n5. **Trying to pass arguments incorrectly**:\n   ```jsx\n   // WRONG!\n   <button onClick={handleClick(id)}>  // Calls immediately!\n   \n   // CORRECT!\n   <button onClick={() => handleClick(id)}>Delete</button>\n   \n   // Or:\n   <button onClick={handleClick.bind(null, id)}>Delete</button>\n   ```\n\n6. **Uncontrolled vs controlled inputs confusion**:\n   ```jsx\n   // Uncontrolled (React doesn't control value)\n   <input defaultValue=\"Initial\" />\n   \n   // Controlled (React controls value via state)\n   const [text, setText] = useState('Initial');\n   <input\n     value={text}                          // Must have value\n     onChange={(e) => setText(e.target.value)}  // Must have onChange\n   />\n   ```\n\n7. **Multiple handlers without arrow functions**:\n   ```jsx\n   // WRONG! (both call immediately)\n   <div\n     onMouseEnter={handleEnter()}\n     onMouseLeave={handleLeave()}\n   >\n   \n   // CORRECT!\n   <div\n     onMouseEnter={handleEnter}\n     onMouseLeave={handleLeave}\n   >\n   \n   // Or with arguments:\n   <div\n     onMouseEnter={() => handleEnter(id)}\n     onMouseLeave={() => handleLeave(id)}\n   >\n   ```"
    },
    {
      "id": "12.5",
      "title": "Conditional Rendering - Showing Different UI Based on State (The Traffic Light Analogy)",
      "conceptAnalogy": "Think of a traffic light at an intersection:\n\nStatic Display (no conditions):\n- Always shows green light\n- Never changes\n- Dangerous! Cars and pedestrians confused\n\nConditional Display (based on state):\n- If state = 'stop' → Show RED light\n- If state = 'caution' → Show YELLOW light\n- If state = 'go' → Show GREEN light\n- Changes based on current condition\n\nReact conditional rendering works the same:\n- Different UI based on state/props\n- Show login button if NOT logged in\n- Show profile if logged in\n- Show loading spinner while fetching\n- Show error message if failed\n\nOne component, many possible displays!",
      "codeExample": "// Conditional Rendering in React\n\nconsole.log('=== Conditional Rendering ===\\n');\n\n// METHOD 1: if/else (outside JSX)\nfunction renderGreeting(isLoggedIn) {\n  if (isLoggedIn) {\n    return '<h1>Welcome back!</h1>';\n  } else {\n    return '<h1>Please log in.</h1>';\n  }\n}\n\nconsole.log('User logged in:');\nconsole.log(renderGreeting(true));\nconsole.log('\\nUser NOT logged in:');\nconsole.log(renderGreeting(false));\n\n// METHOD 2: Ternary operator (? :)\nfunction renderStatus(isOnline) {\n  return `<p>Status: ${isOnline ? 'Online' : 'Offline'}</p>`;\n}\n\nconsole.log('\\nTernary operator:');\nconsole.log(renderStatus(true));\nconsole.log(renderStatus(false));\n\n// METHOD 3: Logical AND (&&)\nfunction renderNotifications(hasNotifications, count) {\n  return `\n    <div>\n      <h2>Dashboard</h2>\n      ${hasNotifications && `<p>You have ${count} new notifications!</p>` || ''}\n    </div>\n  `;\n}\n\nconsole.log('\\nLogical AND (&&):');\nconsole.log(renderNotifications(true, 5));\nconsole.log(renderNotifications(false, 0));\n\n// REAL-WORLD EXAMPLE: Login/Logout Button\nlet app = {\n  state: { isLoggedIn: false, username: null },\n  \n  render() {\n    console.log('\\n[Render] App UI:\\n');\n    \n    if (this.state.isLoggedIn) {\n      console.log(`Welcome, ${this.state.username}!`);\n      console.log('[Logout Button]');\n    } else {\n      console.log('Welcome, Guest!');\n      console.log('[Login Button]');\n    }\n  },\n  \n  login(username) {\n    this.state.isLoggedIn = true;\n    this.state.username = username;\n    this.render();\n  },\n  \n  logout() {\n    this.state.isLoggedIn = false;\n    this.state.username = null;\n    this.render();\n  }\n};\n\nconsole.log('\\n=== Login/Logout Example ===');\napp.render();\n\nconsole.log('\\nUser clicks login:');\napp.login('Alice');\n\nconsole.log('\\nUser clicks logout:');\napp.logout();\n\n// LOADING STATES\nlet dataFetcher = {\n  state: { loading: true, data: null, error: null },\n  \n  render() {\n    console.log('\\n[Render] Data View:\\n');\n    \n    if (this.state.loading) {\n      console.log('⏳ Loading...');\n    } else if (this.state.error) {\n      console.log(`❌ Error: ${this.state.error}`);\n    } else if (this.state.data) {\n      console.log('✓ Data:', this.state.data);\n    } else {\n      console.log('No data yet.');\n    }\n  },\n  \n  async simulateFetch(shouldFail = false) {\n    this.state.loading = true;\n    this.state.error = null;\n    this.state.data = null;\n    this.render();\n    \n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    if (shouldFail) {\n      this.state.loading = false;\n      this.state.error = 'Network error';\n    } else {\n      this.state.loading = false;\n      this.state.data = { users: ['Alice', 'Bob', 'Charlie'] };\n    }\n    this.render();\n  }\n};\n\nconsole.log('\\n=== Loading State Example ===');\nsetTimeout(async () => {\n  dataFetcher.render();\n  \n  console.log('\\nFetching data (success):');\n  await dataFetcher.simulateFetch(false);\n  \n  console.log('\\nFetching data (failure):');\n  await dataFetcher.simulateFetch(true);\n}, 100);\n\n// CONDITIONAL CSS CLASSES\nsetTimeout(() => {\n  console.log('\\n\\n=== Conditional Styling ===\\n');\n  \n  function renderButton(isActive) {\n    let className = isActive ? 'btn-active' : 'btn-inactive';\n    let text = isActive ? 'Active' : 'Inactive';\n    return `<button class=\"${className}\">${text}</button>`;\n  }\n  \n  console.log('Active button:');\n  console.log(renderButton(true));\n  console.log('\\nInactive button:');\n  console.log(renderButton(false));\n  \n  // Multiple conditions\n  function renderAlert(type, message) {\n    let className = type === 'success' ? 'alert-success' :\n                    type === 'error' ? 'alert-error' :\n                    type === 'warning' ? 'alert-warning' :\n                    'alert-info';\n    \n    let icon = type === 'success' ? '✓' :\n               type === 'error' ? '✗' :\n               type === 'warning' ? '⚠' :\n               'ℹ';\n    \n    return `<div class=\"${className}\">${icon} ${message}</div>`;\n  }\n  \n  console.log('\\nConditional alerts:');\n  console.log(renderAlert('success', 'Saved successfully!'));\n  console.log(renderAlert('error', 'Failed to save!'));\n  console.log(renderAlert('warning', 'Are you sure?'));\n  console.log(renderAlert('info', 'New update available'));\n}, 1200);\n\n// LIST RENDERING WITH CONDITIONS\nsetTimeout(() => {\n  console.log('\\n\\n=== Conditional List Rendering ===\\n');\n  \n  let todos = [\n    { id: 1, text: 'Learn React', completed: true },\n    { id: 2, text: 'Build app', completed: false },\n    { id: 3, text: 'Deploy', completed: false }\n  ];\n  \n  console.log('All todos:');\n  todos.forEach(todo => {\n    let checkbox = todo.completed ? '[✓]' : '[ ]';\n    let style = todo.completed ? '(completed)' : '';\n    console.log(`${checkbox} ${todo.text} ${style}`);\n  });\n  \n  console.log('\\nCompleted only:');\n  todos.filter(todo => todo.completed).forEach(todo => {\n    console.log(`[✓] ${todo.text}`);\n  });\n  \n  console.log('\\nIncomplete only:');\n  todos.filter(todo => !todo.completed).forEach(todo => {\n    console.log(`[ ] ${todo.text}`);\n  });\n}, 1300);\n\n// REACT SYNTAX PATTERNS\nsetTimeout(() => {\n  console.log('\\n\\n=== React Conditional Rendering Patterns ===\\n');\n  \n  console.log('// Pattern 1: Ternary operator');\n  console.log('{isLoggedIn ? <Dashboard /> : <Login />}\\n');\n  \n  console.log('// Pattern 2: Logical AND (show/hide)');\n  console.log('{hasError && <ErrorMessage />}');\n  console.log('{count > 0 && <p>You have {count} items</p>}\\n');\n  \n  console.log('// Pattern 3: If/else (before return)');\n  console.log('if (loading) return <Spinner />;');\n  console.log('if (error) return <Error message={error} />;');\n  console.log('return <Data data={data} />;\\n');\n  \n  console.log('// Pattern 4: Switch for multiple conditions');\n  console.log('switch(status) {');\n  console.log('  case \"loading\": return <Spinner />;');\n  console.log('  case \"error\": return <Error />;');\n  console.log('  case \"success\": return <Data />;');\n  console.log('  default: return null;');\n  console.log('}\\n');\n  \n  console.log('// Pattern 5: Null for hiding');\n  console.log('{!shouldShow && null}  // Renders nothing');\n  console.log('{shouldShow ? <Component /> : null}');\n}, 1400);",
      "syntaxBreakdown": "Conditional rendering patterns:\n\n1. **Ternary Operator** (? :):\n   ```jsx\n   function Greeting({ isLoggedIn }) {\n     return (\n       <div>\n         {isLoggedIn ? (\n           <h1>Welcome back!</h1>\n         ) : (\n           <h1>Please log in</h1>\n         )}\n       </div>\n     );\n   }\n   ```\n\n2. **Logical AND** (&&):\n   ```jsx\n   function Notifications({ count }) {\n     return (\n       <div>\n         <h2>Dashboard</h2>\n         {count > 0 && <p>You have {count} notifications</p>}\n       </div>\n     );\n   }\n   // Shows paragraph ONLY if count > 0\n   ```\n\n3. **Early Return**:\n   ```jsx\n   function UserProfile({ user }) {\n     if (!user) {\n       return <p>Loading...</p>;\n     }\n     \n     if (user.error) {\n       return <p>Error: {user.error}</p>;\n     }\n     \n     return (\n       <div>\n         <h1>{user.name}</h1>\n         <p>{user.email}</p>\n       </div>\n     );\n   }\n   ```\n\n4. **Variable Assignment**:\n   ```jsx\n   function Dashboard({ isLoggedIn }) {\n     let content;\n     \n     if (isLoggedIn) {\n       content = <UserDashboard />;\n     } else {\n       content = <LoginPrompt />;\n     }\n     \n     return <div>{content}</div>;\n   }\n   ```\n\n5. **Null for Hiding**:\n   ```jsx\n   function Alert({ message, show }) {\n     if (!show) return null;  // Render nothing\n     \n     return <div className=\"alert\">{message}</div>;\n   }\n   ```\n\n6. **Conditional CSS Classes**:\n   ```jsx\n   function Button({ isActive }) {\n     return (\n       <button className={isActive ? 'btn-active' : 'btn-inactive'}>\n         {isActive ? 'Active' : 'Inactive'}\n       </button>\n     );\n   }\n   ```\n\n7. **Multiple Conditions (Switch)**:\n   ```jsx\n   function StatusDisplay({ status }) {\n     switch(status) {\n       case 'loading':\n         return <Spinner />;\n       case 'error':\n         return <ErrorMessage />;\n       case 'success':\n         return <SuccessMessage />;\n       default:\n         return null;\n     }\n   }\n   ```\n\n8. **Conditional Props**:\n   ```jsx\n   <button\n     className={isActive ? 'active' : 'inactive'}\n     disabled={isLoading}\n     style={{ color: hasError ? 'red' : 'black' }}\n   >\n     {isLoading ? 'Loading...' : 'Submit'}\n   </button>\n   ```\n\n9. **List Filtering**:\n   ```jsx\n   function TodoList({ todos, filter }) {\n     const filteredTodos = filter === 'completed'\n       ? todos.filter(t => t.completed)\n       : filter === 'active'\n       ? todos.filter(t => !t.completed)\n       : todos;\n     \n     return (\n       <ul>\n         {filteredTodos.map(todo => <li key={todo.id}>{todo.text}</li>)}\n       </ul>\n     );\n   }\n   ```",
      "challenge": {
        "instructions": "Create a user authentication UI with conditional rendering:\n\n1. Create an `AuthApp` object with:\n   - state: { isLoggedIn: false, user: null, loading: false }\n   - login(username) method\n   - logout() method\n   - render() method that shows different UI based on state\n\n2. Show:\n   - Loading message when loading = true\n   - Login button when not logged in\n   - Welcome message + Logout button when logged in\n\n3. Test all states",
        "starterCode": "// Authentication App with Conditional Rendering\n\nlet AuthApp = {\n  state: {\n    isLoggedIn: false,\n    user: null,\n    loading: false\n  },\n  \n  render() {\n    console.log('\\n[Render] Auth UI:');\n    console.log('─'.repeat(40));\n    \n    if (this.state.loading) {\n      console.log('⏳ Loading...');\n    } else if (this.state.isLoggedIn) {\n      console.log(`Welcome, ${this.state.user}!`);\n      console.log('[Logout Button]');\n    } else {\n      console.log('Please log in to continue');\n      console.log('[Login Button]');\n    }\n    \n    console.log('─'.repeat(40) + '\\n');\n  },\n  \n  async login(username) {\n    console.log(`[Action] Login as ${username}`);\n    this.state.loading = true;\n    this.render();\n    \n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    this.state.loading = false;\n    this.state.isLoggedIn = true;\n    this.state.user = username;\n    this.render();\n  },\n  \n  logout() {\n    console.log('[Action] Logout');\n    this.state.isLoggedIn = false;\n    this.state.user = null;\n    this.render();\n  }\n};\n\n// Test all states\nasync function testAuthApp() {\n  console.log('=== Auth App Test ===');\n  \n  AuthApp.render();\n  \n  await AuthApp.login('Alice');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  AuthApp.logout();\n}\n\ntestAuthApp();",
        "testCases": [
          {
            "description": "Should show different UI when logged in",
            "input": "let isLoggedIn = true; isLoggedIn ? 'Welcome' : 'Login'",
            "expectedOutput": "Welcome"
          },
          {
            "description": "Should show login when logged out",
            "input": "let isLoggedIn = false; isLoggedIn ? 'Welcome' : 'Login'",
            "expectedOutput": "Login"
          }
        ],
        "hint": "Use if/else in render() to show different UI based on state"
      },
      "solution": "// Complete solution with all conditional rendering patterns\n\nlet AuthApp = {\n  state: {\n    isLoggedIn: false,\n    user: null,\n    loading: false,\n    error: null\n  },\n  \n  render() {\n    console.log('\\n┌────────────────────────────────────────┐');\n    console.log('│          Authentication App            │');\n    console.log('├────────────────────────────────────────┤');\n    \n    // Loading state\n    if (this.state.loading) {\n      console.log('│  ⏳ Loading...                         │');\n      console.log('└────────────────────────────────────────┘\\n');\n      return;\n    }\n    \n    // Error state\n    if (this.state.error) {\n      console.log(`│  ❌ Error: ${this.state.error.padEnd(25)} │`);\n      console.log('│  [Try Again]                           │');\n      console.log('└────────────────────────────────────────┘\\n');\n      return;\n    }\n    \n    // Logged in state\n    if (this.state.isLoggedIn) {\n      console.log(`│  Welcome, ${this.state.user}! ${' '.repeat(26 - this.state.user.length)} │`);\n      console.log('│  ─────────────────────────────────────│');\n      console.log('│  Dashboard                             │');\n      console.log('│  Profile                               │');\n      console.log('│  Settings                              │');\n      console.log('│  ─────────────────────────────────────│');\n      console.log('│  [Logout]                              │');\n    } else {\n      // Logged out state\n      console.log('│  Please log in to continue            │');\n      console.log('│  ─────────────────────────────────────│');\n      console.log('│  [Login]                               │');\n      console.log('│  [Sign Up]                             │');\n    }\n    \n    console.log('└────────────────────────────────────────┘\\n');\n  },\n  \n  async login(username, password) {\n    console.log(`[Action] Login as \"${username}\"`);\n    this.state.loading = true;\n    this.state.error = null;\n    this.render();\n    \n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 800));\n    \n    // Simulate authentication\n    if (password === 'wrong') {\n      this.state.loading = false;\n      this.state.error = 'Invalid credentials';\n      this.render();\n      return;\n    }\n    \n    this.state.loading = false;\n    this.state.isLoggedIn = true;\n    this.state.user = username;\n    this.render();\n  },\n  \n  logout() {\n    console.log('[Action] Logout');\n    this.state.isLoggedIn = false;\n    this.state.user = null;\n    this.state.error = null;\n    this.render();\n  }\n};\n\n// Todo List with conditional rendering\nlet TodoApp = {\n  state: {\n    todos: [\n      { id: 1, text: 'Learn conditional rendering', completed: true },\n      { id: 2, text: 'Build a todo app', completed: false },\n      { id: 3, text: 'Master React', completed: false }\n    ],\n    filter: 'all'  // 'all', 'active', 'completed'\n  },\n  \n  render() {\n    console.log('\\n┌────────────────────────────────────────┐');\n    console.log('│             Todo List                  │');\n    console.log('├────────────────────────────────────────┤');\n    \n    // Filter todos based on current filter\n    let filteredTodos;\n    if (this.state.filter === 'completed') {\n      filteredTodos = this.state.todos.filter(t => t.completed);\n    } else if (this.state.filter === 'active') {\n      filteredTodos = this.state.todos.filter(t => !t.completed);\n    } else {\n      filteredTodos = this.state.todos;\n    }\n    \n    // Empty state\n    if (filteredTodos.length === 0) {\n      console.log('│  No todos to show                      │');\n    } else {\n      filteredTodos.forEach(todo => {\n        let checkbox = todo.completed ? '[✓]' : '[ ]';\n        let text = todo.completed ? `${todo.text} (done)` : todo.text;\n        let line = `│  ${checkbox} ${text}`.padEnd(41) + '│';\n        console.log(line);\n      });\n    }\n    \n    console.log('├────────────────────────────────────────┤');\n    \n    // Filter buttons with active state\n    let allActive = this.state.filter === 'all' ? '*' : ' ';\n    let activeActive = this.state.filter === 'active' ? '*' : ' ';\n    let completedActive = this.state.filter === 'completed' ? '*' : ' ';\n    \n    console.log(`│  [${allActive}]All [${activeActive}]Active [${completedActive}]Completed      │`);\n    console.log('└────────────────────────────────────────┘\\n');\n  },\n  \n  setFilter(filter) {\n    console.log(`[Action] Set filter: ${filter}`);\n    this.state.filter = filter;\n    this.render();\n  }\n};\n\n// Run demonstrations\nasync function runDemo() {\n  console.log('=== Authentication Demo ===\\n');\n  \n  AuthApp.render();\n  \n  console.log('User attempts login with wrong password:');\n  await AuthApp.login('Alice', 'wrong');\n  \n  await new Promise(resolve => setTimeout(resolve, 1000));\n  \n  console.log('User attempts login with correct password:');\n  await AuthApp.login('Alice', 'correct');\n  \n  await new Promise(resolve => setTimeout(resolve, 1000));\n  \n  console.log('User logs out:');\n  AuthApp.logout();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  console.log('\\n=== Todo List Demo ===\\n');\n  \n  TodoApp.render();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  console.log('Show only active todos:');\n  TodoApp.setFilter('active');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  console.log('Show only completed todos:');\n  TodoApp.setFilter('completed');\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  console.log('Show all todos:');\n  TodoApp.setFilter('all');\n}\n\nrunDemo();",
      "commonStickingPoints": "Common conditional rendering mistakes:\n\n1. **Using if statement inside JSX**:\n   ```jsx\n   // WRONG! Can't use if in JSX\n   return (\n     <div>\n       {if (isLoggedIn) { <p>Welcome</p> }}  // Syntax error!\n     </div>\n   );\n   \n   // CORRECT! Use ternary\n   return (\n     <div>\n       {isLoggedIn ? <p>Welcome</p> : <p>Login</p>}\n     </div>\n   );\n   \n   // Or if/else before return:\n   if (isLoggedIn) {\n     return <div><p>Welcome</p></div>;\n   }\n   return <div><p>Login</p></div>;\n   ```\n\n2. **Wrong use of && operator**:\n   ```jsx\n   // WRONG! Renders \"0\" when count is 0\n   {count && <p>You have {count} items</p>}\n   \n   // CORRECT! Use explicit boolean\n   {count > 0 && <p>You have {count} items</p>}\n   ```\n\n3. **Forgetting the else in ternary**:\n   ```jsx\n   // WRONG!\n   {isLoggedIn ? <Dashboard /> }  // Syntax error!\n   \n   // CORRECT!\n   {isLoggedIn ? <Dashboard /> : null}\n   {isLoggedIn ? <Dashboard /> : <Login />}\n   \n   // Or use &&:\n   {isLoggedIn && <Dashboard />}\n   ```\n\n4. **Nested ternaries (hard to read)**:\n   ```jsx\n   // WRONG! (too complex)\n   {isLoading ? <Spinner /> : hasError ? <Error /> : hasData ? <Data /> : <Empty />}\n   \n   // BETTER! Use if/else before return\n   if (isLoading) return <Spinner />;\n   if (hasError) return <Error />;\n   if (hasData) return <Data />;\n   return <Empty />;\n   ```\n\n5. **Rendering undefined or false**:\n   ```jsx\n   // WRONG! Renders \"false\" or \"undefined\" as text\n   <div>{isLoggedIn}</div>  // Renders \"true\" or \"false\"\n   <div>{userData}</div>    // Might render \"undefined\"\n   \n   // CORRECT!\n   <div>{isLoggedIn ? 'Yes' : 'No'}</div>\n   <div>{userData?.name || 'N/A'}</div>\n   ```\n\n6. **String conditions** (always truthy!):\n   ```jsx\n   // WRONG! String \"false\" is truthy!\n   const showBanner = \"false\";  // String, not boolean\n   {showBanner && <Banner />}   // Always shows!\n   \n   // CORRECT!\n   const showBanner = false;    // Boolean\n   {showBanner && <Banner />}   // Works correctly\n   ```\n\n7. **Not handling all states** (loading, error, data):\n   ```jsx\n   // WRONG! Missing loading and error states\n   function UserProfile({ user }) {\n     return <div>{user.name}</div>;  // Crashes if user is null!\n   }\n   \n   // CORRECT!\n   function UserProfile({ user, loading, error }) {\n     if (loading) return <Spinner />;\n     if (error) return <Error message={error} />;\n     if (!user) return <p>No user found</p>;\n     return <div>{user.name}</div>;\n   }\n   ```"
    },
    {
      "id": "12.6",
      "title": "useEffect Hook - Side Effects & Component Lifecycle (The Security Guard Analogy)",
      "conceptAnalogy": "Imagine a security guard at a building entrance:\n\nWithout security guard:\n- People come and go\n- No one tracks entrances/exits\n- No one locks doors at night\n- No cleanup when building closes\n\nWith security guard (useEffect):\n- WHEN people arrive (component mounts) → Check them in\n- WHEN visitor badge expires (dependency changes) → Issue new badge\n- WHEN building closes (component unmounts) → Lock doors, cleanup\n- Guard watches specific things (dependencies)\n- Guard performs actions automatically\n\nReact useEffect is your component's security guard:\n- Runs code AFTER render (side effects)\n- Runs when component mounts\n- Runs when specific values change\n- Cleanup when component unmounts\n- Perfect for: API calls, timers, subscriptions, document title changes!",
      "codeExample": "// useEffect Hook - Side Effects\n\nconsole.log('=== useEffect Hook ===\\n');\n\n// SIDE EFFECT = Code that affects something outside the component\n// Examples: API calls, timers, DOM manipulation, subscriptions\n\n// Simulating component lifecycle\nclass Component {\n  constructor(name) {\n    this.name = name;\n    this.effects = [];\n    this.mounted = false;\n  }\n  \n  useEffect(effect, dependencies) {\n    this.effects.push({ effect, dependencies });\n  }\n  \n  mount() {\n    console.log(`[${this.name}] Mounting...`);\n    this.mounted = true;\n    \n    // Run all effects\n    this.effects.forEach(({ effect, dependencies }) => {\n      console.log(`[${this.name}] Running effect (dependencies: ${dependencies || 'none'})`);\n      let cleanup = effect();\n      if (cleanup) {\n        console.log(`[${this.name}] Effect registered cleanup function`);\n      }\n    });\n  }\n  \n  unmount() {\n    console.log(`\\n[${this.name}] Unmounting...`);\n    console.log(`[${this.name}] Running cleanup functions`);\n    this.mounted = false;\n  }\n}\n\n// Example 1: Effect runs once on mount\nlet TitleComponent = new Component('TitleComponent');\n\nTitleComponent.useEffect(() => {\n  console.log('  Setting document title to: \"My React App\"');\n  // In real React: document.title = 'My React App';\n}, []); // Empty array = run once on mount\n\nTitleComponent.mount();\n\n// Example 2: Effect with cleanup\nconsole.log('\\n--- Timer Component ---');\nlet TimerComponent = new Component('TimerComponent');\n\nTimerComponent.useEffect(() => {\n  console.log('  Starting timer (setInterval)');\n  let intervalId = 123;\n  \n  // Cleanup function (returned)\n  return () => {\n    console.log('  Stopping timer (clearInterval)');\n  };\n}, []);\n\nTimerComponent.mount();\nsetTimeout(() => TimerComponent.unmount(), 1000);\n\n// Example 3: Effect runs when dependency changes\nsetTimeout(() => {\n  console.log('\\n--- User Profile Component ---');\n  \n  let ProfileComponent = new Component('ProfileComponent');\n  let userId = 1;\n  \n  ProfileComponent.useEffect(() => {\n    console.log(`  Fetching data for user ${userId}...`);\n    console.log(`  fetch('/api/users/${userId}')`);\n  }, [userId]); // Re-run when userId changes\n  \n  ProfileComponent.mount();\n  \n  // Simulate prop change\n  setTimeout(() => {\n    console.log('\\n[Props Changed] userId: 1 → 2');\n    userId = 2;\n    console.log('[ProfileComponent] Re-running effects with new userId');\n    console.log(`  Fetching data for user ${userId}...`);\n  }, 500);\n}, 1500);\n\n// DEPENDENCY ARRAY PATTERNS\nsetTimeout(() => {\n  console.log('\\n\\n=== useEffect Dependency Patterns ===\\n');\n  \n  let patterns = [\n    {\n      code: 'useEffect(() => { ... });',\n      deps: 'NO array',\n      runs: 'Every render (usually a mistake!)'\n    },\n    {\n      code: 'useEffect(() => { ... }, []);',\n      deps: 'Empty []',\n      runs: 'Once on mount only'\n    },\n    {\n      code: 'useEffect(() => { ... }, [count]);',\n      deps: '[count]',\n      runs: 'On mount + when count changes'\n    },\n    {\n      code: 'useEffect(() => { ... }, [a, b, c]);',\n      deps: '[a, b, c]',\n      runs: 'On mount + when a, b, OR c changes'\n    }\n  ];\n  \n  patterns.forEach(p => {\n    console.log(`${p.code}`);\n    console.log(`  Dependencies: ${p.deps}`);\n    console.log(`  Runs: ${p.runs}\\n`);\n  });\n}, 2500);\n\n// COMMON USE CASES\nsetTimeout(() => {\n  console.log('=== Common useEffect Use Cases ===\\n');\n  \n  console.log('1. FETCHING DATA:');\n  console.log('useEffect(() => {');\n  console.log('  fetch(\"/api/users\")');\n  console.log('    .then(res => res.json())');\n  console.log('    .then(data => setUsers(data));');\n  console.log('}, []); // Fetch once on mount\\n');\n  \n  console.log('2. SETTING DOCUMENT TITLE:');\n  console.log('useEffect(() => {');\n  console.log('  document.title = `Count: ${count}`;');\n  console.log('}, [count]); // Update when count changes\\n');\n  \n  console.log('3. SUBSCRIBING TO EVENTS:');\n  console.log('useEffect(() => {');\n  console.log('  function handleResize() {');\n  console.log('    setWidth(window.innerWidth);');\n  console.log('  }');\n  console.log('  ');\n  console.log('  window.addEventListener(\"resize\", handleResize);');\n  console.log('  ');\n  console.log('  return () => {  // Cleanup!');\n  console.log('    window.removeEventListener(\"resize\", handleResize);');\n  console.log('  };');\n  console.log('}, []); // Set up once\\n');\n  \n  console.log('4. TIMERS:');\n  console.log('useEffect(() => {');\n  console.log('  const timer = setInterval(() => {');\n  console.log('    setCount(c => c + 1);');\n  console.log('  }, 1000);');\n  console.log('  ');\n  console.log('  return () => clearInterval(timer); // Cleanup!');\n  console.log('}, []); // Start timer once\\n');\n  \n  console.log('5. LOCAL STORAGE:');\n  console.log('useEffect(() => {');\n  console.log('  localStorage.setItem(\"theme\", theme);');\n  console.log('}, [theme]); // Save when theme changes');\n}, 2600);",
      "syntaxBreakdown": "useEffect Hook explained:\n\n1. **Basic useEffect** (runs after every render):\n   ```jsx\n   import { useEffect } from 'react';\n   \n   function MyComponent() {\n     useEffect(() => {\n       console.log('Component rendered!');\n     });\n     // NO dependency array = runs after EVERY render\n   }\n   ```\n\n2. **Run once on mount** (empty dependency array):\n   ```jsx\n   useEffect(() => {\n     console.log('Component mounted!');\n   }, []);  // Empty array = run ONCE on mount\n   ```\n\n3. **Run when specific values change**:\n   ```jsx\n   useEffect(() => {\n     console.log('Count changed:', count);\n   }, [count]);  // Runs when count changes\n   ```\n\n4. **Cleanup function** (returned from effect):\n   ```jsx\n   useEffect(() => {\n     // Setup\n     const timer = setInterval(() => {\n       console.log('Tick');\n     }, 1000);\n     \n     // Cleanup (runs before next effect OR on unmount)\n     return () => {\n       clearInterval(timer);\n       console.log('Timer cleaned up');\n     };\n   }, []);\n   ```\n\n5. **Fetching data**:\n   ```jsx\n   useEffect(() => {\n     async function fetchData() {\n       const res = await fetch('/api/users');\n       const data = await res.json();\n       setUsers(data);\n     }\n     \n     fetchData();\n   }, []);  // Fetch once on mount\n   ```\n\n6. **Multiple dependencies**:\n   ```jsx\n   useEffect(() => {\n     // Runs when userId OR filter changes\n     fetchUserPosts(userId, filter);\n   }, [userId, filter]);\n   ```\n\n7. **Event listeners**:\n   ```jsx\n   useEffect(() => {\n     function handleScroll() {\n       setScrollY(window.scrollY);\n     }\n     \n     window.addEventListener('scroll', handleScroll);\n     \n     return () => {\n       window.removeEventListener('scroll', handleScroll);\n     };\n   }, []);\n   ```\n\n8. **Local Storage**:\n   ```jsx\n   useEffect(() => {\n     localStorage.setItem('user', JSON.stringify(user));\n   }, [user]);  // Save when user changes\n   ```\n\n9. **Document Title**:\n   ```jsx\n   useEffect(() => {\n     document.title = `Messages (${unreadCount})`;\n   }, [unreadCount]);\n   ```\n\n10. **Conditional Effect**:\n   ```jsx\n   useEffect(() => {\n     if (isLoggedIn) {\n       // Only run if logged in\n       connectToChat();\n       \n       return () => disconnectFromChat();\n     }\n   }, [isLoggedIn]);\n   ```",
      "challenge": {
        "instructions": "Create a clock component with useEffect:\n\n1. Create a `ClockComponent` object with:\n   - state: { time: current time string }\n   - mount() - simulates component mounting\n   - unmount() - simulates component unmounting\n   - Use effect to update time every second\n   - Cleanup timer on unmount\n\n2. Test by mounting, waiting 3 seconds, then unmounting",
        "starterCode": "// Clock Component with useEffect\n\nlet ClockComponent = {\n  state: { time: new Date().toLocaleTimeString() },\n  timerId: null,\n  \n  mount() {\n    console.log('[Clock] Mounting...');\n    console.log('[Clock] useEffect(() => { ... }, [])');\n    \n    // Effect: Start timer\n    this.timerId = setInterval(() => {\n      this.state.time = new Date().toLocaleTimeString();\n      console.log('[Clock] Tick:', this.state.time);\n    }, 1000);\n    \n    console.log('[Clock] Timer started (ID:', this.timerId, ')');\n    console.log('[Clock] Registered cleanup function\\n');\n  },\n  \n  unmount() {\n    console.log('\\n[Clock] Unmounting...');\n    console.log('[Clock] Running cleanup function');\n    \n    // Cleanup: Stop timer\n    if (this.timerId) {\n      clearInterval(this.timerId);\n      console.log('[Clock] Timer stopped');\n    }\n  }\n};\n\n// Test\nasync function testClock() {\n  console.log('=== Clock Component Test ===\\n');\n  \n  ClockComponent.mount();\n  \n  // Wait 3 seconds\n  await new Promise(resolve => setTimeout(resolve, 3000));\n  \n  ClockComponent.unmount();\n}\n\ntestClock();",
        "testCases": [
          {
            "description": "Should set up interval",
            "input": "let id = setInterval(() => {}, 1000); typeof id",
            "expectedOutput": "number"
          },
          {
            "description": "Should clean up interval",
            "input": "let id = setInterval(() => {}, 1000); clearInterval(id); 'cleaned'",
            "expectedOutput": "cleaned"
          }
        ],
        "hint": "Use setInterval in mount(), clearInterval in unmount()"
      },
      "solution": "// Complete useEffect simulation\n\nlet ClockComponent = {\n  state: { time: new Date().toLocaleTimeString(), ticks: 0 },\n  timerId: null,\n  mounted: false,\n  \n  mount() {\n    console.log('┌────────────────────────────────┐');\n    console.log('│     Clock Component Mount      │');\n    console.log('└────────────────────────────────┘\\n');\n    \n    this.mounted = true;\n    \n    console.log('[useEffect] Starting side effects...');\n    console.log('[Effect 1] Setting document title');\n    // document.title = 'Clock App';\n    \n    console.log('[Effect 2] Starting interval timer\\n');\n    this.timerId = setInterval(() => {\n      if (this.mounted) {\n        this.state.time = new Date().toLocaleTimeString();\n        this.state.ticks++;\n        console.log(`⏰ ${this.state.time} (tick #${this.state.ticks})`);\n      }\n    }, 1000);\n    \n    console.log(`✓ Timer ID: ${this.timerId}`);\n    console.log('✓ Cleanup function registered\\n');\n  },\n  \n  unmount() {\n    console.log('\\n┌────────────────────────────────┐');\n    console.log('│    Clock Component Unmount     │');\n    console.log('└────────────────────────────────┘\\n');\n    \n    this.mounted = false;\n    \n    console.log('[Cleanup] Running effect cleanup...');\n    \n    if (this.timerId) {\n      clearInterval(this.timerId);\n      console.log(`✓ Timer ${this.timerId} cleared`);\n      this.timerId = null;\n    }\n    \n    console.log(`✓ Total ticks: ${this.state.ticks}`);\n    console.log('✓ Component unmounted cleanly\\n');\n  }\n};\n\n// Fetch component with cleanup\nlet DataFetcher = {\n  state: { data: null, loading: false },\n  controller: null,\n  \n  async mount(userId) {\n    console.log('┌────────────────────────────────┐');\n    console.log('│   DataFetcher Mount (user:${userId})   │'.replace('${userId}', userId));\n    console.log('└────────────────────────────────┘\\n');\n    \n    console.log('[useEffect] Running with [userId] dependency');\n    console.log(`  userId = ${userId}\\n`);\n    \n    // Simulate AbortController for fetch cancellation\n    this.controller = { aborted: false };\n    \n    this.state.loading = true;\n    console.log('[Fetch] Starting request...');\n    \n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    if (!this.controller.aborted) {\n      this.state.data = { id: userId, name: `User ${userId}` };\n      this.state.loading = false;\n      console.log('[Fetch] Success:', this.state.data);\n    } else {\n      console.log('[Fetch] Aborted');\n    }\n    \n    console.log('\\n✓ Cleanup function registered');\n  },\n  \n  unmount() {\n    console.log('\\n[Cleanup] Aborting fetch if in progress...');\n    if (this.controller) {\n      this.controller.aborted = true;\n      console.log('✓ Fetch aborted');\n    }\n  }\n};\n\n// Run demonstrations\nasync function runDemo() {\n  console.log('═══ useEffect Demo ═══\\n');\n  \n  // Demo 1: Clock\n  console.log('DEMO 1: Clock with Timer\\n');\n  ClockComponent.mount();\n  \n  await new Promise(resolve => setTimeout(resolve, 3500));\n  \n  ClockComponent.unmount();\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  // Demo 2: Data fetching\n  console.log('\\nDEMO 2: Data Fetching with Cleanup\\n');\n  console.log('Fetching user 1...');\n  let fetch1 = DataFetcher.mount(1);\n  \n  await new Promise(resolve => setTimeout(resolve, 500));\n  \n  console.log('\\n[Props Change] userId: 1 → 2');\n  console.log('Cleaning up old effect...');\n  DataFetcher.unmount();\n  \n  console.log('\\nFetching user 2...');\n  await DataFetcher.mount(2);\n  \n  console.log('\\n\\n=== useEffect Best Practices ===\\n');\n  let practices = [\n    '✓ Always include dependency array ([], [dep], etc.)',\n    '✓ Return cleanup function when needed',\n    '✓ Don\\'t call async functions directly in useEffect',\n    '✓ Clean up timers, subscriptions, event listeners',\n    '✓ Use separate useEffect for unrelated logic',\n    '✓ Put all dependencies in the array',\n    '✓ Cleanup prevents memory leaks'\n  ];\n  \n  practices.forEach(p => console.log(p));\n}\n\nrunDemo();",
      "commonStickingPoints": "Common useEffect mistakes:\n\n1. **Forgetting dependency array**:\n   ```jsx\n   // WRONG! Runs after EVERY render\n   useEffect(() => {\n     fetchData();  // Infinite loop if it updates state!\n   });\n   \n   // CORRECT!\n   useEffect(() => {\n     fetchData();\n   }, []);  // Run once on mount\n   ```\n\n2. **Using async directly in useEffect**:\n   ```jsx\n   // WRONG!\n   useEffect(async () => {  // Can't make effect async!\n     const data = await fetch('/api/users');\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     async function fetchData() {\n       const data = await fetch('/api/users');\n     }\n     fetchData();\n   }, []);\n   ```\n\n3. **Missing dependencies**:\n   ```jsx\n   // WRONG! (missing 'count' in dependencies)\n   useEffect(() => {\n     console.log('Count is:', count);\n   }, []);  // Should include [count]!\n   \n   // CORRECT!\n   useEffect(() => {\n     console.log('Count is:', count);\n   }, [count]);  // Re-run when count changes\n   ```\n\n4. **Not cleaning up**:\n   ```jsx\n   // WRONG! (memory leak)\n   useEffect(() => {\n     const timer = setInterval(() => setCount(c => c + 1), 1000);\n     // No cleanup!\n   }, []);\n   \n   // CORRECT!\n   useEffect(() => {\n     const timer = setInterval(() => setCount(c => c + 1), 1000);\n     return () => clearInterval(timer);  // Cleanup!\n   }, []);\n   ```\n\n5. **Infinite loops**:\n   ```jsx\n   // WRONG! Infinite loop\n   useEffect(() => {\n     setCount(count + 1);  // Updates state → re-render → effect runs → updates state...\n   }, [count]);  // Depends on count!\n   \n   // CORRECT! (if you really need this pattern)\n   useEffect(() => {\n     if (count < 10) {  // Add condition\n       setCount(count + 1);\n     }\n   }, [count]);\n   ```\n\n6. **Stale closures**:\n   ```jsx\n   // WRONG! (captures old 'count')\n   useEffect(() => {\n     const timer = setInterval(() => {\n       setCount(count + 1);  // Always uses initial count!\n     }, 1000);\n     return () => clearInterval(timer);\n   }, []);  // Empty deps = count never updates\n   \n   // CORRECT!\n   useEffect(() => {\n     const timer = setInterval(() => {\n       setCount(c => c + 1);  // Use functional update\n     }, 1000);\n     return () => clearInterval(timer);\n   }, []);  // No dependency on count needed\n   ```\n\n7. **Multiple effects for unrelated logic** (good practice!):\n   ```jsx\n   // WRONG! (mixing concerns)\n   useEffect(() => {\n     fetchUsers();  // Unrelated\n     document.title = 'Users';  // to\n     window.addEventListener('resize', handleResize);  // each other\n   }, []);\n   \n   // CORRECT! (separate effects)\n   useEffect(() => {\n     fetchUsers();\n   }, []);\n   \n   useEffect(() => {\n     document.title = 'Users';\n   }, []);\n   \n   useEffect(() => {\n     window.addEventListener('resize', handleResize);\n     return () => window.removeEventListener('resize', handleResize);\n   }, []);\n   ```"
    }
  ]
}
