{
  "id": "14",
  "title": "Module 14: Deployment & Professional Tools",
  "description": "Deploy your applications to production, use Git for version control, and adopt professional development practices",
  "goal": "Launch your full-stack applications to the internet and work like a professional developer",
  "lessons": [
    {
      "id": "14.1",
      "title": "Version Control with Git (The Time Machine Analogy)",
      "conceptAnalogy": "Imagine writing a book:\n\nWithout version control:\n- Save as: book_final.docx\n- Save as: book_final_v2.docx\n- Save as: book_final_v2_ACTUALLY_FINAL.docx\n- Save as: book_final_v2_ACTUALLY_FINAL_fixed.docx\n- Which one is the real final version?!\n- Want to go back to Tuesday's version? Good luck finding it!\n- Working with co-author? Email files back and forth (nightmare!)\n\nWith Git (version control):\n- One file: book.docx\n- Every save creates a snapshot (commit)\n- Can jump to ANY previous version instantly\n- See exactly what changed and when\n- Multiple authors work simultaneously\n- Automatic merging of changes\n- Complete history preserved forever\n\nGit is like a time machine for your code. It tracks every change, lets you experiment safely, and makes collaboration seamless!",
      "codeExample": "// Git Concepts (Simulated)\n// Git is a command-line tool, not JavaScript, but let's understand the concepts!\n\nconsole.log('=== Git Version Control ===\\n');\n\n// CONCEPT 1: REPOSITORY - Project history\nlet repository = {\n  name: 'my-awesome-app',\n  commits: [],\n  currentBranch: 'main',\n  branches: ['main']\n};\n\nconsole.log('Repository:', repository.name);\n\n// CONCEPT 2: COMMIT - Snapshot of your code\nfunction commit(message, files) {\n  let snapshot = {\n    id: Math.random().toString(36).substr(2, 7),\n    message: message,\n    files: files,\n    timestamp: new Date().toISOString(),\n    author: 'You'\n  };\n  \n  repository.commits.push(snapshot);\n  console.log(`âœ“ Committed: \"${message}\" (${snapshot.id})`);\n  return snapshot;\n}\n\n// CONCEPT 3: BRANCH - Parallel version of code\nfunction createBranch(name) {\n  repository.branches.push(name);\n  console.log(`âœ“ Created branch: ${name}`);\n}\n\nfunction switchBranch(name) {\n  if (repository.branches.includes(name)) {\n    repository.currentBranch = name;\n    console.log(`âœ“ Switched to branch: ${name}`);\n  }\n}\n\n// SIMULATE GIT WORKFLOW\nconsole.log('\\n--- Simulating Git Workflow ---\\n');\n\n// 1. Initial commit\ncommit('Initial commit', ['index.html', 'app.js', 'styles.css']);\n\n// 2. Add feature\ncommit('Add user authentication', ['auth.js', 'login.html']);\n\n// 3. Fix bug\ncommit('Fix login button styling', ['styles.css']);\n\n// 4. Create feature branch\ncreate Branch('feature/dark-mode');\nswitchBranch('feature/dark-mode');\n\n// 5. Work on feature\ncommit('Add dark mode toggle', ['darkMode.js', 'styles.css']);\n\n// 6. Switch back to main\nswitchBranch('main');\n\nconsole.log('\\n--- Repository State ---');\nconsole.log('Total commits:', repository.commits.length);\nconsole.log('Branches:', repository.branches.join(', '));\nconsole.log('Current branch:', repository.currentBranch);\n\nconsole.log('\\n--- Commit History ---');\nrepository.commits.forEach((c, i) => {\n  console.log(`${i + 1}. [${c.id}] ${c.message}`);\n});\n\n// GIT COMMANDS REFERENCE\nconsole.log('\\n=== Essential Git Commands ===\\n');\n\nlet gitCommands = {\n  'git init': 'Create new Git repository',\n  'git clone <url>': 'Download existing repository',\n  'git status': 'See which files changed',\n  'git add <file>': 'Stage file for commit',\n  'git add .': 'Stage all changed files',\n  'git commit -m \"message\"': 'Save snapshot with message',\n  'git log': 'View commit history',\n  'git branch <name>': 'Create new branch',\n  'git checkout <branch>': 'Switch to branch',\n  'git merge <branch>': 'Merge branch into current',\n  'git pull': 'Download latest changes from remote',\n  'git push': 'Upload your commits to remote',\n  'git diff': 'See what changed in files'\n};\n\nfor (let [command, description] of Object.entries(gitCommands)) {\n  console.log(`${command.padEnd(30)} - ${description}`);\n}\n\n// TYPICAL WORKFLOW\nconsole.log('\\n=== Typical Git Workflow ===\\n');\n\nlet workflow = [\n  '1. Make changes to your code',\n  '2. git status               (see what changed)',\n  '3. git add .                (stage all changes)',\n  '4. git commit -m \"Add feature X\"  (save snapshot)',\n  '5. git push                 (upload to GitHub)',\n  '',\n  'Repeat for every feature/fix!'\n];\n\nworkflow.forEach(step => console.log(step));\n\nconsole.log('\\n--- Why Use Git? ---');\nlet benefits = [\n  'âœ“ Never lose code (complete history)',\n  'âœ“ Experiment safely (branches)',\n  'âœ“ Collaborate easily (merge changes)',\n  'âœ“ See who changed what and when',\n  'âœ“ Revert mistakes instantly',\n  'âœ“ Required by all professional teams',\n  'âœ“ Works with GitHub (code hosting)'\n];\n\nbenefits.forEach(b => console.log(b));",
      "syntaxBreakdown": "Git fundamentals:\n\n1. **Setting Up Git**:\n   ```bash\n   # Configure Git (one time)\n   git config --global user.name \"Your Name\"\n   git config --global user.email \"you@example.com\"\n   \n   # Create new repository\n   git init\n   \n   # Or clone existing\n   git clone https://github.com/username/repo.git\n   ```\n\n2. **Basic Workflow**:\n   ```bash\n   # 1. Check status\n   git status\n   \n   # 2. Stage changes\n   git add filename.js      # Single file\n   git add .                # All files\n   \n   # 3. Commit\n   git commit -m \"Add user login feature\"\n   \n   # 4. Push to remote (GitHub)\n   git push\n   ```\n\n3. **Branches**:\n   ```bash\n   # Create and switch to new branch\n   git checkout -b feature/new-feature\n   \n   # Switch between branches\n   git checkout main\n   git checkout feature/new-feature\n   \n   # Merge branch into current\n   git checkout main\n   git merge feature/new-feature\n   \n   # Delete branch\n   git branch -d feature/new-feature\n   ```\n\n4. **Viewing History**:\n   ```bash\n   # See commits\n   git log\n   git log --oneline    # Compact view\n   \n   # See changes\n   git diff             # Unstaged changes\n   git diff --staged    # Staged changes\n   ```\n\n5. **.gitignore** - Files to never commit:\n   ```\n   node_modules/\n   .env\n   .DS_Store\n   dist/\n   build/\n   *.log\n   ```\n\n6. **GitHub Workflow**:\n   ```bash\n   # First time setup\n   git remote add origin https://github.com/username/repo.git\n   git push -u origin main\n   \n   # Regular updates\n   git pull    # Download changes\n   git push    # Upload changes\n   ```\n\n7. **Commit Messages** (best practices):\n   - Start with verb: \"Add\", \"Fix\", \"Update\", \"Remove\"\n   - Be specific: \"Fix login button alignment\"\n   - Not vague: \"Fixed stuff\" or \"Changes\"\n   - Present tense: \"Add feature\" not \"Added feature\"",
      "challenge": {
        "instructions": "Simulate a Git repository:\n\n1. Create a `repo` object with:\n   - commits array\n   - branches array (start with 'main')\n   - currentBranch property\n\n2. Create function `makeCommit(message)` that:\n   - Adds commit to commits array\n   - Returns commit object with: id, message, timestamp\n\n3. Create function `createBranch(name)` that:\n   - Adds branch to branches array\n\n4. Test by making 3 commits and creating 1 branch",
        "starterCode": "// Git repository simulation\nlet repo = {\n  commits: [],\n  branches: ['main'],\n  currentBranch: 'main'\n};\n\nfunction makeCommit(message) {\n  let commit = {\n    id: Math.random().toString(36).substr(2, 7),\n    message: message,\n    timestamp: new Date().toISOString()\n  };\n  repo.commits.push(commit);\n  console.log(`Committed: ${message} (${commit.id})`);\n  return commit;\n}\n\nfunction createBranch(name) {\n  repo.branches.push(name);\n  console.log(`Created branch: ${name}`);\n}\n\n// Test\nmakeCommit('Initial commit');\nmakeCommit('Add homepage');\nmakeCommit('Fix CSS');\ncreateBranch('feature/login');\n\nconsole.log('\\nRepository state:');\nconsole.log('Commits:', repo.commits.length);\nconsole.log('Branches:', repo.branches);",
        "testCases": [
          {
            "description": "Should track commits",
            "input": "let commits = []; commits.push({ id: 1, msg: 'Test' }); commits.length",
            "expectedOutput": "1"
          }
        ],
        "hint": "Use array push() to add commits and branches."
      },
      "solution": "// Complete Git simulation\nlet repo = {\n  commits: [],\n  branches: ['main'],\n  currentBranch: 'main',\n  files: {}\n};\n\nfunction makeCommit(message, files = []) {\n  let commit = {\n    id: Math.random().toString(36).substr(2, 7),\n    message: message,\n    branch: repo.currentBranch,\n    files: files,\n    timestamp: new Date().toISOString(),\n    author: 'Developer'\n  };\n  \n  repo.commits.push(commit);\n  console.log(`âœ“ [${commit.id}] ${message}`);\n  return commit;\n}\n\nfunction createBranch(name) {\n  if (repo.branches.includes(name)) {\n    console.log(`âœ— Branch ${name} already exists`);\n    return false;\n  }\n  repo.branches.push(name);\n  console.log(`âœ“ Created branch: ${name}`);\n  return true;\n}\n\nfunction switchBranch(name) {\n  if (!repo.branches.includes(name)) {\n    console.log(`âœ— Branch ${name} does not exist`);\n    return false;\n  }\n  repo.currentBranch = name;\n  console.log(`âœ“ Switched to branch: ${name}`);\n  return true;\n}\n\nfunction showLog() {\n  console.log('\\n=== Commit History ===');\n  repo.commits.forEach((c, i) => {\n    console.log(`${i + 1}. [${c.id}] (${c.branch}) ${c.message}`);\n    if (c.files.length > 0) {\n      console.log(`   Files: ${c.files.join(', ')}`);\n    }\n  });\n}\n\nfunction showStatus() {\n  console.log('\\n=== Repository Status ===');\n  console.log(`Current branch: ${repo.currentBranch}`);\n  console.log(`Total branches: ${repo.branches.join(', ')}`);\n  console.log(`Total commits: ${repo.commits.length}`);\n}\n\n// Simulate development workflow\nconsole.log('=== Git Workflow Simulation ===\\n');\n\nmakeCommit('Initial commit', ['README.md', 'package.json']);\nmakeCommit('Add Express server', ['server.js']);\nmakeCommit('Add database connection', ['db.js', 'prisma/schema.prisma']);\n\ncreateBranch('feature/authentication');\nswitchBranch('feature/authentication');\n\nmakeCommit('Add login route', ['routes/auth.js']);\nmakeCommit('Add JWT middleware', ['middleware/auth.js']);\n\nswitchBranch('main');\nmakeCommit('Update README', ['README.md']);\n\nshowLog();\nshowStatus();\n\nconsole.log('\\n--- Git Best Practices ---');\nlet practices = [\n  'âœ“ Commit often (small, focused commits)',\n  'âœ“ Write clear commit messages',\n  'âœ“ Use branches for features',\n  'âœ“ Never commit secrets (.env files)',\n  'âœ“ Pull before you push',\n  'âœ“ Review changes before committing (git diff)',\n  'âœ“ Use .gitignore for node_modules, etc.'\n];\npractices.forEach(p => console.log(p));",
      "commonStickingPoints": "Common Git mistakes:\n\n1. **Forgetting to commit**:\n   ```bash\n   # Made lots of changes, forgot to commit\n   # Now have 50 files changed\n   # Hard to write one commit message!\n   \n   # Better: Commit after each feature\n   git add .\n   git commit -m \"Add user login\"\n   # Then continue coding\n   ```\n\n2. **Committing secrets**:\n   ```bash\n   # NEVER commit .env files!\n   # Add to .gitignore:\n   .env\n   .env.local\n   config/secrets.js\n   ```\n\n3. **Not using .gitignore**:\n   ```bash\n   # Don't commit node_modules!\n   # Create .gitignore file:\n   node_modules/\n   .DS_Store\n   dist/\n   *.log\n   ```\n\n4. **Merge conflicts** (scary but normal!):\n   ```\n   <<<<<<< HEAD\n   const API_URL = 'http://localhost:3000';\n   =======\n   const API_URL = 'https://api.production.com';\n   >>>>>>> feature-branch\n   ```\n   - Choose which version to keep\n   - Delete conflict markers (<<<<, ====, >>>>)\n   - Commit the resolved file\n\n5. **Wrong branch**:\n   ```bash\n   # Check current branch BEFORE committing!\n   git branch        # Shows all branches\n   git status        # Shows current branch\n   \n   # If on wrong branch:\n   git stash         # Save changes temporarily\n   git checkout correct-branch\n   git stash pop     # Apply changes here\n   ```\n\n6. **Push without pull**:\n   ```bash\n   # Error: Updates were rejected\n   # Someone else pushed while you were working\n   \n   # Fix:\n   git pull          # Get their changes\n   # Resolve conflicts if any\n   git push          # Now it works\n   ```\n\n7. **Vague commit messages**:\n   ```bash\n   # Bad:\n   git commit -m \"fixes\"\n   git commit -m \"stuff\"\n   git commit -m \"asdf\"\n   \n   # Good:\n   git commit -m \"Fix login button alignment on mobile\"\n   git commit -m \"Add password reset functionality\"\n   git commit -m \"Update dependencies to latest versions\"\n   ```"
    },
    {
      "id": "14.2",
      "title": "Deploying Express Backend to Render (The Restaurant Going Live Analogy)",
      "conceptAnalogy": "Imagine opening a restaurant:\n\nDevelopment (your kitchen at home):\n- Cook and test recipes\n- Only you and friends eat the food\n- localhost:3000 (your home address)\n- Turn off stove â†’ restaurant closes\n\nProduction (real restaurant):\n- Open to the public!\n- Anyone can visit and order\n- https://my-restaurant.com (real address)\n- Stays open 24/7 (even when you sleep)\n- Professional kitchen staff (hosting servers)\n\nDeploying your Express API is the same:\n- Move from localhost to real internet\n- Get a public URL (like render.com/yourapp)\n- Runs on powerful servers 24/7\n- Anyone can make requests to your API!\n\nPopular platforms: Render (free!), Railway, Heroku",
      "codeExample": "// Deploying Express API - Concepts\n\nconsole.log('=== Express API Deployment ===\\n');\n\n// CONCEPT: Environment-aware server\nconst PORT = process.env.PORT || 3000;  // Use hosting platform's port\nconst NODE_ENV = process.env.NODE_ENV || 'development';\n\nconsole.log('Environment:', NODE_ENV);\nconsole.log('Port:', PORT);\n\n// Simulating Express app ready for deployment\nconst app = {\n  routes: [\n    { method: 'GET', path: '/api/users', handler: 'getUsers' },\n    { method: 'POST', path: '/api/users', handler: 'createUser' },\n    { method: 'GET', path: '/health', handler: 'healthCheck' }\n  ],\n  \n  config: {\n    cors: true,\n    port: PORT,\n    database: process.env.DATABASE_URL,\n    env: NODE_ENV\n  },\n  \n  listen(port) {\n    console.log(`\\n[Server] Listening on port ${port}`);\n    console.log(`[Server] Environment: ${this.config.env}`);\n    console.log(`[Server] CORS enabled: ${this.config.cors}`);\n    \n    if (this.config.env === 'production') {\n      console.log('\\n[Production Mode]');\n      console.log('  - Using DATABASE_URL from environment');\n      console.log('  - Detailed errors hidden from clients');\n      console.log('  - Compression enabled');\n      console.log('  - Security headers added');\n    } else {\n      console.log('\\n[Development Mode]');\n      console.log('  - Using local database');\n      console.log('  - Full error stack traces shown');\n      console.log('  - Hot reload enabled');\n    }\n  }\n};\n\napp.listen(PORT);\n\n// DEPLOYMENT STEPS SIMULATION\nconsole.log('\\n\\n=== Deployment Process ===\\n');\n\nconst deploymentSteps = [\n  {\n    step: 1,\n    title: 'Prepare Your Code',\n    tasks: [\n      'Add \"start\" script to package.json',\n      'Use environment variables (process.env)',\n      'Add .env to .gitignore',\n      'Commit and push to GitHub'\n    ]\n  },\n  {\n    step: 2,\n    title: 'Create Render Account',\n    tasks: [\n      'Go to render.com',\n      'Sign up with GitHub',\n      'Click \"New +\" â†’ \"Web Service\"'\n    ]\n  },\n  {\n    step: 3,\n    title: 'Configure Service',\n    tasks: [\n      'Connect your GitHub repo',\n      'Name: my-api',\n      'Build Command: npm install',\n      'Start Command: npm start',\n      'Select Free plan'\n    ]\n  },\n  {\n    step: 4,\n    title: 'Add Environment Variables',\n    tasks: [\n      'Click \"Environment\"',\n      'Add DATABASE_URL',\n      'Add JWT_SECRET',\n      'Add other secrets from .env'\n    ]\n  },\n  {\n    step: 5,\n    title: 'Deploy!',\n    tasks: [\n      'Click \"Create Web Service\"',\n      'Wait for build (~2 minutes)',\n      'Get your URL: https://my-api.onrender.com',\n      'Test: https://my-api.onrender.com/health'\n    ]\n  }\n];\n\ndeploymentSteps.forEach(({ step, title, tasks }) => {\n  console.log(`Step ${step}: ${title}`);\n  tasks.forEach(task => console.log(`  - ${task}`));\n  console.log('');\n});\n\n// PACKAGE.JSON FOR DEPLOYMENT\nconsole.log('=== package.json Configuration ===\\n');\n\nconst packageJson = {\n  name: 'my-express-api',\n  version: '1.0.0',\n  scripts: {\n    start: 'node server.js',  // Production start command\n    dev: 'nodemon server.js',  // Development with auto-reload\n    build: 'echo \"No build needed for Express\"'\n  },\n  engines: {\n    node: '>=18.0.0'  // Specify Node version\n  },\n  dependencies: {\n    express: '^4.18.0',\n    cors: '^2.8.5',\n    dotenv: '^16.0.0'\n  }\n};\n\nconsole.log(JSON.stringify(packageJson, null, 2));\n\n// HEALTH CHECK ENDPOINT (important!)\nconsole.log('\\n\\n=== Health Check Endpoint ===\\n');\n\nconsole.log('// Add this to your server:');\nconsole.log(\"app.get('/health', (req, res) => {\");\nconsole.log(\"  res.json({\");\nconsole.log(\"    status: 'ok',\");\nconsole.log(\"    timestamp: new Date(),\");\nconsole.log(\"    uptime: process.uptime()\");\nconsole.log(\"  });\");\nconsole.log(\"});\\n\");\n\nconsole.log('Why? Hosting platforms ping /health to check if app is running!');\n\n// TESTING DEPLOYMENT\nconsole.log('\\n\\n=== Testing Your Deployed API ===\\n');\n\nconst tests = [\n  {\n    test: 'Health Check',\n    command: 'curl https://my-api.onrender.com/health',\n    expected: '{ status: \"ok\" }'\n  },\n  {\n    test: 'GET Request',\n    command: 'curl https://my-api.onrender.com/api/users',\n    expected: '[{ id: 1, name: \"Alice\" }, ...]'\n  },\n  {\n    test: 'POST Request',\n    command: 'curl -X POST https://my-api.onrender.com/api/users -d {\"name\":\"Bob\"}',\n    expected: '{ id: 2, name: \"Bob\" }'\n  }\n];\n\ntests.forEach(({ test, command, expected }) => {\n  console.log(`${test}:`);\n  console.log(`  $ ${command}`);\n  console.log(`  Expected: ${expected}\\n`);\n});",
      "syntaxBreakdown": "Express deployment checklist:\n\n1. **Environment Variables** (CRITICAL!):\n   ```javascript\n   // server.js\n   import 'dotenv/config';  // Load .env file\n   \n   const PORT = process.env.PORT || 3000;\n   const DATABASE_URL = process.env.DATABASE_URL;\n   const JWT_SECRET = process.env.JWT_SECRET;\n   \n   // NEVER hardcode secrets!\n   // WRONG: const secret = 'my-secret-key';\n   // RIGHT: const secret = process.env.JWT_SECRET;\n   ```\n\n2. **package.json Scripts**:\n   ```json\n   {\n     \"scripts\": {\n       \"start\": \"node server.js\",\n       \"dev\": \"nodemon server.js\"\n     },\n     \"engines\": {\n       \"node\": \">=18.0.0\"\n     }\n   }\n   ```\n\n3. **Server Listen** (use process.env.PORT):\n   ```javascript\n   const PORT = process.env.PORT || 3000;\n   \n   app.listen(PORT, () => {\n     console.log(`Server running on port ${PORT}`);\n   });\n   ```\n\n4. **CORS Configuration** (allow frontend):\n   ```javascript\n   import cors from 'cors';\n   \n   const allowedOrigins = [\n     'https://my-frontend.vercel.app',\n     'http://localhost:5173'  // For local dev\n   ];\n   \n   app.use(cors({\n     origin: allowedOrigins,\n     credentials: true\n   }));\n   ```\n\n5. **Health Check Endpoint**:\n   ```javascript\n   app.get('/health', (req, res) => {\n     res.json({ status: 'ok', timestamp: new Date() });\n   });\n   ```\n\n6. **.gitignore** (don't commit secrets!):\n   ```\n   node_modules/\n   .env\n   .env.local\n   .env.production\n   dist/\n   *.log\n   ```\n\n7. **Database Connection** (production-ready):\n   ```javascript\n   import { PrismaClient } from '@prisma/client';\n   \n   const prisma = new PrismaClient({\n     datasources: {\n       db: {\n         url: process.env.DATABASE_URL  // From Render env vars\n       }\n     }\n   });\n   ```\n\n8. **Error Handling** (hide details in production):\n   ```javascript\n   app.use((err, req, res, next) => {\n     console.error(err.stack);\n     \n     if (process.env.NODE_ENV === 'production') {\n       res.status(500).json({ error: 'Internal server error' });\n     } else {\n       res.status(500).json({ error: err.message, stack: err.stack });\n     }\n   });\n   ```",
      "challenge": {
        "instructions": "Prepare an Express server for deployment:\n\n1. Create a `server` object that:\n   - Uses process.env.PORT with fallback to 3000\n   - Has a /health route\n   - Logs startup info\n   - Shows different behavior for production vs development\n\n2. Simulate starting the server in both environments",
        "starterCode": "// Express server ready for deployment\n\nconst server = {\n  port: process.env.PORT || 3000,\n  env: process.env.NODE_ENV || 'development',\n  \n  routes: {\n    '/health': function() {\n      return { status: 'ok', timestamp: new Date() };\n    },\n    '/api/users': function() {\n      return [{ id: 1, name: 'Alice' }];\n    }\n  },\n  \n  start() {\n    console.log(`\\n[Server] Starting...`);\n    console.log(`[Server] Environment: ${this.env}`);\n    console.log(`[Server] Port: ${this.port}`);\n    \n    if (this.env === 'production') {\n      console.log('[Server] Running in PRODUCTION mode');\n      console.log('  - Detailed errors hidden');\n      console.log('  - Using production database');\n    } else {\n      console.log('[Server] Running in DEVELOPMENT mode');\n      console.log('  - Full error traces enabled');\n      console.log('  - Using local database');\n    }\n    \n    console.log(`\\nâœ“ Server ready on port ${this.port}`);\n    console.log(`\\nAvailable routes:`);\n    Object.keys(this.routes).forEach(route => {\n      console.log(`  - ${route}`);\n    });\n  }\n};\n\n// Test\nserver.start();\n\n// Simulate health check\nconsole.log('\\n[Test] GET /health');\nconsole.log('Response:', server.routes['/health']());",
        "testCases": [
          {
            "description": "Should use PORT from environment",
            "input": "process.env.PORT = 8080; process.env.PORT || 3000",
            "expectedOutput": "8080"
          }
        ],
        "hint": "Use process.env.PORT and process.env.NODE_ENV"
      },
      "solution": "// Complete production-ready Express server\n\nconst server = {\n  port: process.env.PORT || 3000,\n  env: process.env.NODE_ENV || 'development',\n  databaseUrl: process.env.DATABASE_URL || 'postgres://localhost/mydb',\n  jwtSecret: process.env.JWT_SECRET || 'dev-secret',\n  \n  routes: {\n    '/health': function() {\n      return {\n        status: 'ok',\n        timestamp: new Date(),\n        uptime: process.uptime(),\n        environment: server.env\n      };\n    },\n    '/api/users': function() {\n      return [\n        { id: 1, name: 'Alice', email: 'alice@example.com' },\n        { id: 2, name: 'Bob', email: 'bob@example.com' }\n      ];\n    },\n    '/api/status': function() {\n      return {\n        server: 'Express API',\n        version: '1.0.0',\n        environment: server.env,\n        database: server.databaseUrl ? 'Connected' : 'Disconnected'\n      };\n    }\n  },\n  \n  middleware: {\n    cors: function() {\n      console.log('[Middleware] CORS enabled');\n      console.log('  Allowed origins: https://my-app.vercel.app, http://localhost:5173');\n    },\n    \n    compression: function() {\n      if (server.env === 'production') {\n        console.log('[Middleware] Compression enabled (gzip)');\n      }\n    },\n    \n    security: function() {\n      if (server.env === 'production') {\n        console.log('[Middleware] Security headers added:');\n        console.log('  - helmet (security headers)');\n        console.log('  - rate limiting');\n        console.log('  - XSS protection');\n      }\n    }\n  },\n  \n  start() {\n    console.log('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');\n    console.log('â”‚       Express Server Starting       â”‚');\n    console.log('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\\n');\n    \n    console.log(`Environment: ${this.env}`);\n    console.log(`Port: ${this.port}`);\n    console.log(`Database: ${this.databaseUrl}\\n`);\n    \n    // Load middleware\n    console.log('Loading middleware:');\n    this.middleware.cors();\n    this.middleware.compression();\n    this.middleware.security();\n    \n    console.log('\\n' + 'â”€'.repeat(39));\n    \n    if (this.env === 'production') {\n      console.log('\\nðŸš€ PRODUCTION MODE');\n      console.log('  âœ“ Using production database');\n      console.log('  âœ“ Errors hidden from clients');\n      console.log('  âœ“ Compression enabled');\n      console.log('  âœ“ Security headers active');\n      console.log('  âœ“ Rate limiting enabled');\n    } else {\n      console.log('\\nðŸ”§ DEVELOPMENT MODE');\n      console.log('  âš  Using local database');\n      console.log('  âš  Full error stack traces');\n      console.log('  âš  No compression');\n      console.log('  âš  Hot reload enabled');\n    }\n    \n    console.log('\\n' + 'â”€'.repeat(39));\n    console.log(`\\nâœ“ Server ready at http://localhost:${this.port}`);\n    \n    if (this.env === 'production') {\n      console.log(`âœ“ Public URL: https://my-api.onrender.com`);\n    }\n    \n    console.log('\\nAvailable Endpoints:');\n    Object.keys(this.routes).forEach(route => {\n      console.log(`  - ${route}`);\n    });\n    \n    console.log('\\n' + 'â•'.repeat(39) + '\\n');\n  },\n  \n  handleRequest(path) {\n    console.log(`\\n[Request] GET ${path}`);\n    \n    if (this.routes[path]) {\n      const response = this.routes[path]();\n      console.log('[Response] 200 OK');\n      console.log(JSON.stringify(response, null, 2));\n      return response;\n    } else {\n      console.log('[Response] 404 Not Found');\n      return { error: 'Route not found' };\n    }\n  }\n};\n\n// Simulate deployment\nconsole.log('=== Simulating Deployment ===\\n');\n\n// Development\nconsole.log('1. LOCAL DEVELOPMENT:\\n');\nprocess.env.NODE_ENV = 'development';\nserver.start();\n\nserver.handleRequest('/health');\nserver.handleRequest('/api/users');\n\n// Production\nconsole.log('\\n\\n2. PRODUCTION DEPLOYMENT:\\n');\nprocess.env.NODE_ENV = 'production';\nprocess.env.PORT = 10000;\nprocess.env.DATABASE_URL = 'postgres://render.com/prod-db';\nserver.port = process.env.PORT;\nserver.env = process.env.NODE_ENV;\nserver.databaseUrl = process.env.DATABASE_URL;\n\nserver.start();\n\nserver.handleRequest('/health');\nserver.handleRequest('/api/status');\n\nconsole.log('\\n=== Deployment Checklist ===\\n');\n\nconst checklist = [\n  'âœ“ Set NODE_ENV=production',\n  'âœ“ Use process.env.PORT',\n  'âœ“ Add health check endpoint',\n  'âœ“ Configure CORS for frontend URL',\n  'âœ“ Add environment variables in Render',\n  'âœ“ Never commit .env files',\n  'âœ“ Add \"start\" script to package.json',\n  'âœ“ Test deployed API with curl/Postman'\n];\n\nchecklist.forEach(item => console.log(item));",
      "commonStickingPoints": "Common deployment mistakes:\n\n1. **Hardcoded PORT** (will crash!):\n   ```javascript\n   // WRONG! Render assigns random port\n   app.listen(3000);  // âœ— Will fail on Render\n   \n   // CORRECT!\n   const PORT = process.env.PORT || 3000;\n   app.listen(PORT);  // âœ“ Works everywhere\n   ```\n\n2. **Committed .env file** (security risk!):\n   ```bash\n   # .gitignore MUST include:\n   .env\n   .env.local\n   .env.production\n   \n   # Check if accidentally committed:\n   git ls-files | grep .env  # Should be empty!\n   ```\n\n3. **Missing start script**:\n   ```json\n   // WRONG! (package.json)\n   {\n     \"scripts\": {\n       \"dev\": \"nodemon server.js\"\n       // No \"start\" script!\n     }\n   }\n   \n   // CORRECT!\n   {\n     \"scripts\": {\n       \"start\": \"node server.js\",\n       \"dev\": \"nodemon server.js\"\n     }\n   }\n   ```\n\n4. **CORS not configured for production frontend**:\n   ```javascript\n   // WRONG! Blocks your frontend\n   app.use(cors({\n     origin: 'http://localhost:5173'  // Only allows local!\n   }));\n   \n   // CORRECT!\n   const allowedOrigins = [\n     'https://my-app.vercel.app',  // Production frontend\n     'http://localhost:5173'       // Local development\n   ];\n   \n   app.use(cors({\n     origin: (origin, callback) => {\n       if (!origin || allowedOrigins.includes(origin)) {\n         callback(null, true);\n       } else {\n         callback(new Error('Not allowed by CORS'));\n       }\n     }\n   }));\n   ```\n\n5. **Database URL not from environment**:\n   ```javascript\n   // WRONG! Won't work in production\n   const db = 'postgresql://localhost/mydb';\n   \n   // CORRECT!\n   const db = process.env.DATABASE_URL || 'postgresql://localhost/mydb';\n   ```\n\n6. **Missing health check** (Render needs this!):\n   ```javascript\n   // Add this route:\n   app.get('/health', (req, res) => {\n     res.json({ status: 'ok' });\n   });\n   \n   // Render pings this to check if server is alive\n   ```\n\n7. **Exposing secrets in errors**:\n   ```javascript\n   // WRONG! Leaks sensitive info\n   app.use((err, req, res, next) => {\n     res.status(500).json({ error: err.stack });  // Shows DB passwords!\n   });\n   \n   // CORRECT!\n   app.use((err, req, res, next) => {\n     console.error(err.stack);  // Log server-side only\n     \n     if (process.env.NODE_ENV === 'production') {\n       res.status(500).json({ error: 'Internal server error' });\n     } else {\n       res.status(500).json({ error: err.message });\n     }\n   });\n   ```"
    },
    {
      "id": "14.3",
      "title": "Deploying React Frontend to Vercel (The Storefront Going Live Analogy)",
      "conceptAnalogy": "Imagine opening a physical store:\n\nDevelopment (building in your garage):\n- Test the store layout\n- Only you can see it\n- localhost:5173 (your garage address)\n- Close garage door â†’ store disappears\n\nProduction (real storefront on Main Street):\n- Open to the public!\n- Anyone can visit from anywhere\n- https://my-store.vercel.app (real address)\n- Open 24/7 (never closes)\n- Professional hosting (like a shopping mall)\n\nDeploying your React app is the same:\n- Move from localhost to real internet\n- Build optimized version (Vite build)\n- Get a public URL (vercel.app or netlify.app)\n- Hosted on fast servers worldwide (CDN)\n- Connects to your deployed API!\n\nPopular platforms: Vercel (made by Next.js creators, free!), Netlify, Cloudflare Pages",
      "codeExample": "// Deploying React Frontend - Concepts\n\nconsole.log('=== React Frontend Deployment ===\\n');\n\n// CONCEPT: Build Process\nconst buildProcess = {\n  name: 'Vite Build',\n  \n  steps: [\n    'Read all your React components',\n    'Bundle JavaScript into optimized files',\n    'Minify code (remove whitespace, shorten names)',\n    'Optimize images and assets',\n    'Generate index.html',\n    'Output to dist/ folder'\n  ],\n  \n  before: {\n    files: ['src/App.jsx', 'src/components/*.jsx', 'src/main.jsx'],\n    size: '2.5 MB (readable code)'\n  },\n  \n  after: {\n    files: ['dist/index.html', 'dist/assets/index-a3b4c5d6.js', 'dist/assets/index-e7f8g9h0.css'],\n    size: '150 KB (minified and optimized!)'\n  },\n  \n  run() {\n    console.log('ðŸ”¨ Building React app...\\n');\n    this.steps.forEach((step, i) => {\n      console.log(`  ${i + 1}. ${step}`);\n    });\n    console.log('\\nðŸ“¦ Before build:');\n    console.log(`  Files: ${this.before.files.join(', ')}`);\n    console.log(`  Size: ${this.before.size}`);\n    console.log('\\nâœ… After build:');\n    console.log(`  Files: ${this.after.files.join(', ')}`);\n    console.log(`  Size: ${this.after.size}`);\n    console.log('\\nâœ“ Build complete! Ready to deploy.');\n  }\n};\n\nbuildProcess.run();\n\n// CONCEPT: Environment Variables\nconsole.log('\\n\\n=== Environment Variables ===\\n');\n\nconst environmentConfig = {\n  development: {\n    API_URL: 'http://localhost:3000',\n    DEBUG: 'true'\n  },\n  \n  production: {\n    API_URL: 'https://my-api.onrender.com',\n    DEBUG: 'false'\n  },\n  \n  showConfig(env) {\n    console.log(`${env.toUpperCase()} Environment:`);\n    const config = this[env];\n    for (let [key, value] of Object.entries(config)) {\n      console.log(`  VITE_${key} = \"${value}\"`);\n    }\n  }\n};\n\nconsole.log('Local development:');\nenvironmentConfig.showConfig('development');\n\nconsole.log('\\nProduction deployment:');\nenvironmentConfig.showConfig('production');\n\nconsole.log('\\nIn your React code:');\nconsole.log(\"const API_URL = import.meta.env.VITE_API_URL;\");\nconsole.log(\"fetch(`${API_URL}/api/users`);\\n\");\n\n// DEPLOYMENT STEPS SIMULATION\nconsole.log('\\n=== Deployment Process (Vercel) ===\\n');\n\nconst deploymentSteps = [\n  {\n    step: 1,\n    title: 'Prepare Your React App',\n    tasks: [\n      'Update API URL to use environment variable',\n      'Test build locally: npm run build',\n      'Add .env to .gitignore',\n      'Commit and push to GitHub'\n    ]\n  },\n  {\n    step: 2,\n    title: 'Create Vercel Account',\n    tasks: [\n      'Go to vercel.com',\n      'Sign up with GitHub',\n      'Click \"Add New\" â†’ \"Project\"'\n    ]\n  },\n  {\n    step: 3,\n    title: 'Import Repository',\n    tasks: [\n      'Select your GitHub repo',\n      'Framework Preset: Vite (auto-detected)',\n      'Root Directory: ./ (or your frontend folder)',\n      'Build Command: npm run build',\n      'Output Directory: dist'\n    ]\n  },\n  {\n    step: 4,\n    title: 'Configure Environment Variables',\n    tasks: [\n      'Click \"Environment Variables\"',\n      'Add: VITE_API_URL = https://my-api.onrender.com',\n      'Add any other VITE_ prefixed variables'\n    ]\n  },\n  {\n    step: 5,\n    title: 'Deploy!',\n    tasks: [\n      'Click \"Deploy\"',\n      'Wait for build (~1 minute)',\n      'Get your URL: https://my-app.vercel.app',\n      'Test: Open URL and check if it connects to API'\n    ]\n  },\n  {\n    step: 6,\n    title: 'Update Backend CORS',\n    tasks: [\n      'Add your Vercel URL to backend CORS',\n      \"In Express: allowedOrigins.push('https://my-app.vercel.app')\",\n      'Redeploy backend',\n      'Test frontend â†’ backend connection'\n    ]\n  }\n];\n\ndeploymentSteps.forEach(({ step, title, tasks }) => {\n  console.log(`Step ${step}: ${title}`);\n  tasks.forEach(task => console.log(`  - ${task}`));\n  console.log('');\n});\n\n// SIMULATING DEPLOYMENT\nconsole.log('=== Simulating Frontend Deployment ===\\n');\n\nconst deployment = {\n  platform: 'Vercel',\n  project: 'my-react-app',\n  url: 'https://my-react-app.vercel.app',\n  status: 'Building',\n  \n  logs: [\n    '[1/6] Cloning repository from GitHub...',\n    '[2/6] Installing dependencies (npm install)...',\n    '[3/6] Building project (npm run build)...',\n    '  âœ“ 1247 modules transformed',\n    '  âœ“ Built in 8.3s',\n    '[4/6] Optimizing assets...',\n    '  âœ“ Images optimized: 12 files',\n    '  âœ“ JavaScript minified: 145 KB â†’ 48 KB',\n    '[5/6] Deploying to global CDN...',\n    '[6/6] Assigning domains...',\n    '',\n    'âœ… Deployment successful!',\n    'ðŸŒ https://my-react-app.vercel.app',\n    'âš¡ Served from 100+ edge locations worldwide'\n  ],\n  \n  deploy() {\n    console.log(`Deploying ${this.project} to ${this.platform}...\\n`);\n    this.logs.forEach(log => {\n      console.log(log);\n    });\n    console.log(`\\nâœ“ Live at: ${this.url}`);\n    this.status = 'Live';\n  },\n  \n  stats() {\n    console.log('\\n=== Deployment Stats ===\\n');\n    console.log('Status:', this.status);\n    console.log('Platform:', this.platform);\n    console.log('Build time: 8.3 seconds');\n    console.log('Deploy time: 12 seconds');\n    console.log('Total size: 48 KB (gzipped)');\n    console.log('CDN locations: 100+');\n    console.log('SSL: Enabled (HTTPS)');\n    console.log('Auto-deploy: Enabled (push to main â†’ auto deploy)');\n  }\n};\n\ndeployment.deploy();\ndeployment.stats();\n\n// AUTO-DEPLOYMENT\nconsole.log('\\n\\n=== Auto-Deployment Workflow ===\\n');\n\nconst autoDeploySteps = [\n  '1. You push code to GitHub (git push)',\n  '2. Vercel detects the push',\n  '3. Automatically runs build',\n  '4. Deploys new version',\n  '5. Updates live site',\n  '',\n  'âš¡ Total time: ~1 minute from push to live!'\n];\n\nautoDeploySteps.forEach(step => console.log(step));",
      "syntaxBreakdown": "React deployment configuration:\n\n1. **Environment Variables** (VITE_ prefix required!):\n   ```javascript\n   // .env.local (development)\n   VITE_API_URL=http://localhost:3000\n   VITE_DEBUG=true\n   \n   // In Vercel dashboard (production)\n   VITE_API_URL=https://my-api.onrender.com\n   VITE_DEBUG=false\n   ```\n   \n   ```javascript\n   // Using in React code\n   const API_URL = import.meta.env.VITE_API_URL;\n   \n   fetch(`${API_URL}/api/users`)\n     .then(res => res.json())\n     .then(data => console.log(data));\n   ```\n\n2. **vite.config.js** (usually default is fine):\n   ```javascript\n   import { defineConfig } from 'vite';\n   import react from '@vitejs/plugin-react';\n   \n   export default defineConfig({\n     plugins: [react()],\n     build: {\n       outDir: 'dist',  // Output folder\n       sourcemap: false  // Don't include source maps in production\n     }\n   });\n   ```\n\n3. **Build Command**:\n   ```bash\n   # Test build locally first!\n   npm run build\n   \n   # Creates dist/ folder with:\n   # - index.html\n   # - assets/index-[hash].js\n   # - assets/index-[hash].css\n   \n   # Preview build locally\n   npm run preview\n   # Opens http://localhost:4173\n   ```\n\n4. **package.json Scripts**:\n   ```json\n   {\n     \"scripts\": {\n       \"dev\": \"vite\",\n       \"build\": \"vite build\",\n       \"preview\": \"vite preview\"\n     }\n   }\n   ```\n\n5. **Connecting to Backend API**:\n   ```javascript\n   // src/config/api.js\n   const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000';\n   \n   export async function fetchUsers() {\n     const response = await fetch(`${API_URL}/api/users`);\n     return response.json();\n   }\n   \n   export async function createUser(userData) {\n     const response = await fetch(`${API_URL}/api/users`, {\n       method: 'POST',\n       headers: { 'Content-Type': 'application/json' },\n       body: JSON.stringify(userData)\n     });\n     return response.json();\n   }\n   ```\n\n6. **Update Backend CORS** (CRITICAL!):\n   ```javascript\n   // Express backend server.js\n   const allowedOrigins = [\n     'https://my-app.vercel.app',      // Your Vercel URL\n     'https://my-app-git-*.vercel.app', // Preview deployments\n     'http://localhost:5173'            // Local dev\n   ];\n   \n   app.use(cors({\n     origin: allowedOrigins,\n     credentials: true\n   }));\n   ```\n\n7. **Vercel Configuration** (optional vercel.json):\n   ```json\n   {\n     \"buildCommand\": \"npm run build\",\n     \"outputDirectory\": \"dist\",\n     \"rewrites\": [\n       {\n         \"source\": \"/(.*)\",\n         \"destination\": \"/index.html\"\n       }\n     ]\n   }\n   ```\n   The `rewrites` rule handles client-side routing (React Router).\n\n8. **.gitignore** (don't commit build folder!):\n   ```\n   node_modules/\n   dist/\n   .env\n   .env.local\n   .env.production\n   .vercel\n   ```",
      "challenge": {
        "instructions": "Prepare a React app for deployment:\n\n1. Create a `frontendApp` object that:\n   - Has development and production API URLs\n   - Simulates build process\n   - Shows environment-specific configuration\n\n2. Create a `buildApp()` function that:\n   - Shows build steps\n   - Outputs stats (file size, optimization)\n\n3. Test building for both environments",
        "starterCode": "// React app deployment simulation\n\nconst frontendApp = {\n  name: 'My React App',\n  \n  env: {\n    development: {\n      API_URL: 'http://localhost:3000',\n      NODE_ENV: 'development'\n    },\n    production: {\n      API_URL: 'https://my-api.onrender.com',\n      NODE_ENV: 'production'\n    }\n  },\n  \n  build(environment) {\n    console.log(`\\nðŸ”¨ Building for ${environment}...\\n`);\n    \n    const config = this.env[environment];\n    console.log('Environment variables:');\n    console.log(`  VITE_API_URL=${config.API_URL}`);\n    console.log(`  NODE_ENV=${config.NODE_ENV}\\n`);\n    \n    console.log('Build steps:');\n    console.log('  1. Bundling React components');\n    console.log('  2. Minifying JavaScript');\n    console.log('  3. Optimizing assets');\n    console.log('  4. Generating index.html\\n');\n    \n    if (environment === 'production') {\n      console.log('âœ“ Production optimizations applied');\n      console.log('  - Code minified');\n      console.log('  - Source maps removed');\n      console.log('  - Tree-shaking applied\\n');\n    }\n    \n    console.log('âœ… Build complete!');\n    console.log(`   Output: dist/`);\n    console.log(`   Ready to deploy to Vercel\\n`);\n  }\n};\n\n// Test\nfrontendApp.build('development');\nfrontendApp.build('production');",
        "testCases": [
          {
            "description": "Should use correct API URL for environment",
            "input": "const API = import.meta.env.VITE_API_URL; API",
            "expectedOutput": "https://my-api.onrender.com (in production)"
          }
        ],
        "hint": "Use import.meta.env.VITE_* for environment variables in Vite/React"
      },
      "solution": "// Complete React deployment simulation\n\nconst frontendApp = {\n  name: 'My React App',\n  version: '1.0.0',\n  \n  env: {\n    development: {\n      VITE_API_URL: 'http://localhost:3000',\n      VITE_DEBUG: 'true',\n      NODE_ENV: 'development'\n    },\n    production: {\n      VITE_API_URL: 'https://my-api.onrender.com',\n      VITE_DEBUG: 'false',\n      NODE_ENV: 'production'\n    }\n  },\n  \n  files: {\n    source: [\n      'src/App.jsx',\n      'src/components/UserList.jsx',\n      'src/components/LoginForm.jsx',\n      'src/main.jsx',\n      'src/styles.css'\n    ],\n    sourceSize: 2500,  // KB\n    \n    built: [\n      'dist/index.html',\n      'dist/assets/index-a3b4c5d6.js',\n      'dist/assets/index-e7f8g9h0.css'\n    ],\n    builtSize: 145  // KB after optimization\n  },\n  \n  build(environment) {\n    console.log('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');\n    console.log('â”‚       Building React App            â”‚');\n    console.log('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\\n');\n    \n    console.log(`Environment: ${environment}`);\n    console.log(`Version: ${this.version}\\n`);\n    \n    const config = this.env[environment];\n    console.log('Environment Variables:');\n    Object.entries(config).forEach(([key, value]) => {\n      if (key.startsWith('VITE_')) {\n        console.log(`  ${key}=${value}`);\n      }\n    });\n    \n    console.log('\\n' + 'â”€'.repeat(39));\n    console.log('\\nBuild Process:\\n');\n    \n    const steps = [\n      { name: 'Analyzing dependencies', time: 0.5 },\n      { name: 'Bundling React components', time: 2.1 },\n      { name: 'Transpiling JSX to JavaScript', time: 1.3 },\n      { name: 'Minifying JavaScript', time: 1.8 },\n      { name: 'Optimizing CSS', time: 0.7 },\n      { name: 'Compressing images', time: 0.9 },\n      { name: 'Generating index.html', time: 0.2 }\n    ];\n    \n    steps.forEach((step, i) => {\n      console.log(`  ${i + 1}. ${step.name.padEnd(35)} ${step.time}s`);\n    });\n    \n    const totalTime = steps.reduce((sum, s) => sum + s.time, 0);\n    console.log(`\\n  Total build time: ${totalTime.toFixed(1)}s`);\n    \n    console.log('\\n' + 'â”€'.repeat(39));\n    \n    if (environment === 'production') {\n      console.log('\\nðŸš€ Production Optimizations:\\n');\n      const optimizations = [\n        'Code splitting enabled',\n        'Tree-shaking applied (removed unused code)',\n        'Minification: 2500 KB â†’ 145 KB',\n        'Gzip compression ready',\n        'Source maps removed',\n        'Image optimization: 85% quality',\n        'CSS purged (unused styles removed)'\n      ];\n      optimizations.forEach(opt => console.log(`  âœ“ ${opt}`));\n    } else {\n      console.log('\\nðŸ”§ Development Build:\\n');\n      const devFeatures = [\n        'Source maps included',\n        'Hot module replacement enabled',\n        'Readable code (not minified)',\n        'Detailed error messages'\n      ];\n      devFeatures.forEach(feat => console.log(`  âœ“ ${feat}`));\n    }\n    \n    console.log('\\n' + 'â”€'.repeat(39));\n    console.log('\\nâœ… Build Complete!\\n');\n    console.log('Output Directory: dist/');\n    console.log('Files generated:');\n    this.files.built.forEach(file => {\n      console.log(`  - ${file}`);\n    });\n    console.log(`\\nTotal size: ${this.files.builtSize} KB`);\n    \n    if (environment === 'production') {\n      console.log(`Compression: ${this.files.sourceSize} KB â†’ ${this.files.builtSize} KB (${Math.round((1 - this.files.builtSize / this.files.sourceSize) * 100)}% smaller)\\n`);\n    }\n    \n    console.log('â•'.repeat(39) + '\\n');\n  },\n  \n  deploy(platform) {\n    console.log(`\\nðŸš€ Deploying to ${platform}...\\n`);\n    \n    const deploySteps = [\n      'Uploading dist/ folder',\n      'Distributing to global CDN',\n      'Configuring SSL certificate',\n      'Assigning domain',\n      'Running health checks'\n    ];\n    \n    deploySteps.forEach((step, i) => {\n      console.log(`  ${i + 1}. ${step}...`);\n    });\n    \n    const url = `https://${this.name.toLowerCase().replace(/\\s+/g, '-')}.vercel.app`;\n    \n    console.log(`\\nâœ… Deployment successful!\\n`);\n    console.log(`ðŸŒ Live at: ${url}`);\n    console.log(`âš¡ Served from 100+ edge locations worldwide\\n`);\n    \n    return url;\n  },\n  \n  testConnection(apiUrl) {\n    console.log(`\\nðŸ§ª Testing connection to backend...\\n`);\n    console.log(`Frontend: https://my-app.vercel.app`);\n    console.log(`Backend:  ${apiUrl}\\n`);\n    \n    console.log('Testing endpoints:');\n    const tests = [\n      { endpoint: '/health', status: 200, result: 'OK' },\n      { endpoint: '/api/users', status: 200, result: '[2 users]' },\n      { endpoint: '/api/login', status: 200, result: 'OK' }\n    ];\n    \n    tests.forEach(test => {\n      console.log(`  GET ${apiUrl}${test.endpoint}`);\n      console.log(`    â†’ ${test.status} ${test.result}`);\n    });\n    \n    console.log('\\nâœ… All endpoints responding correctly!\\n');\n  }\n};\n\n// Simulate complete deployment workflow\nconsole.log('=== Complete Deployment Workflow ===\\n');\n\n// 1. Development build\nconsole.log('Step 1: Test build locally\\n');\nfrontendApp.build('development');\n\n// 2. Production build\nconsole.log('\\nStep 2: Production build\\n');\nfrontendApp.build('production');\n\n// 3. Deploy\nconsole.log('\\nStep 3: Deploy to Vercel\\n');\nconst liveUrl = frontendApp.deploy('Vercel');\n\n// 4. Test backend connection\nconsole.log('Step 4: Test API connection\\n');\nfrontendApp.testConnection(frontendApp.env.production.VITE_API_URL);\n\n// 5. Final checklist\nconsole.log('\\n=== Deployment Checklist ===\\n');\nconst checklist = [\n  'âœ“ Environment variables configured in Vercel',\n  'âœ“ API URL points to production backend',\n  'âœ“ Backend CORS allows Vercel domain',\n  'âœ“ Build completes without errors',\n  'âœ“ All API endpoints responding',\n  'âœ“ SSL certificate active (HTTPS)',\n  'âœ“ Auto-deploy enabled on git push',\n  'âœ“ .env files not committed to git'\n];\n\nchecklist.forEach(item => console.log(item));\n\nconsole.log('\\nðŸŽ‰ Deployment complete! Your app is live!\\n');",
      "commonStickingPoints": "Common React deployment mistakes:\n\n1. **Wrong environment variable prefix**:\n   ```javascript\n   // WRONG! Won't work in Vite\n   const API_URL = process.env.REACT_APP_API_URL;  // âœ—\n   const API_URL = process.env.API_URL;             // âœ—\n   \n   // CORRECT for Vite!\n   const API_URL = import.meta.env.VITE_API_URL;   // âœ“\n   ```\n\n2. **Hardcoded API URL**:\n   ```javascript\n   // WRONG! Won't work after deployment\n   fetch('http://localhost:3000/api/users');  // âœ—\n   \n   // CORRECT!\n   const API_URL = import.meta.env.VITE_API_URL;\n   fetch(`${API_URL}/api/users`);  // âœ“\n   ```\n\n3. **Forgot to add env vars in Vercel dashboard**:\n   ```\n   Error: import.meta.env.VITE_API_URL is undefined\n   \n   Fix:\n   1. Go to Vercel project settings\n   2. Environment Variables\n   3. Add: VITE_API_URL = https://my-api.onrender.com\n   4. Redeploy\n   ```\n\n4. **Backend CORS not updated**:\n   ```javascript\n   // Error in browser console:\n   // \"Access to fetch at 'https://api.com' from origin 'https://my-app.vercel.app' \n   // has been blocked by CORS policy\"\n   \n   // Fix in Express backend:\n   const allowedOrigins = [\n     'https://my-app.vercel.app',  // Add this!\n     'http://localhost:5173'\n   ];\n   \n   app.use(cors({ origin: allowedOrigins }));\n   ```\n\n5. **Build folder committed to Git**:\n   ```bash\n   # .gitignore should include:\n   dist/\n   build/\n   .vercel/\n   \n   # If accidentally committed:\n   git rm -r --cached dist\n   git commit -m \"Remove dist folder\"\n   ```\n\n6. **Wrong build output directory**:\n   ```\n   # Vercel settings:\n   Build Command: npm run build\n   Output Directory: dist    â† Must match Vite's output!\n   \n   # Vite outputs to dist/ by default\n   # If you changed it in vite.config.js, update Vercel settings\n   ```\n\n7. **Client-side routing 404 errors**:\n   ```\n   Problem: Refreshing /about gives 404 error\n   \n   Solution: Add vercel.json:\n   {\n     \"rewrites\": [\n       { \"source\": \"/(.*)\", \"destination\": \"/index.html\" }\n     ]\n   }\n   \n   This tells Vercel to serve index.html for all routes\n   (React Router handles routing on the client)\n   ```\n\n8. **Mixed content warning (HTTP/HTTPS)**:\n   ```javascript\n   // WRONG! Frontend is HTTPS, API is HTTP\n   VITE_API_URL=http://my-api.com  // âœ— Browser blocks this!\n   \n   // CORRECT! Both must be HTTPS\n   VITE_API_URL=https://my-api.com  // âœ“\n   ```\n\n9. **Environment variables not rebuilding**:\n   ```\n   Changed VITE_API_URL but still seeing old value?\n   \n   Fix:\n   1. Environment vars are baked into build at build time\n   2. Must trigger new deployment after changing them\n   3. In Vercel: Deployments â†’ Redeploy\n   ```\n\n10. **Forgot to test production build locally**:\n    ```bash\n    # Always test before deploying!\n    npm run build      # Build for production\n    npm run preview    # Preview the build locally\n    \n    # Open http://localhost:4173 and test everything\n    # Make sure API calls work!\n    ```"
    },
    {
      "id": "14.4",
      "title": "Environment Variables in Production (The Secret Recipe Analogy)",
      "conceptAnalogy": "Imagine you own a restaurant chain:\n\nBad approach (hardcoded secrets):\n- Write secret sauce recipe directly in the cookbook\n- Every employee gets a copy\n- Recipe is in every branch location\n- Employee leaves â†’ they have your secrets!\n- Want to change recipe â†’ reprint all cookbooks!\n\nGood approach (environment variables):\n- Cookbook says: \"Use the secret sauce (see manager)\"\n- Each location stores recipe in a safe\n- Only managers have the combination\n- Employee leaves â†’ recipe stays safe\n- Change recipe â†’ just update the safe\n\nEnvironment variables work the same way:\n- Code says: process.env.DATABASE_PASSWORD\n- Secret stored separately (not in code!)\n- Different value per environment (dev vs prod)\n- Change secrets without changing code\n- Never committed to Git (safe!)\n\nThink of env vars as a safe for your app's secrets!",
      "codeExample": "// Environment Variables - Concepts\n\nconsole.log('=== Environment Variables ===\\n');\n\n// CONCEPT: Separating Code from Configuration\n\n// BAD: Hardcoded secrets (NEVER DO THIS!)\nconst badExample = {\n  database: 'postgres://admin:super_secret_password@db.com/prod',\n  jwtSecret: 'my-secret-key-12345',\n  stripeKey: 'sk_live_abc123xyz',\n  apiKey: 'secret-api-key-do-not-share'\n};\n\nconsole.log('âŒ WRONG - Hardcoded Secrets:\\n');\nObject.entries(badExample).forEach(([key, value]) => {\n  console.log(`const ${key} = '${value}';`);\n});\n\nconsole.log('\\nProblems:');\nconst problems = [\n  'âœ— Secrets visible in Git history forever',\n  'âœ— Everyone with code access sees secrets',\n  'âœ— Different environments need different values',\n  'âœ— Changing secrets requires code changes',\n  'âœ— Accidental public repository = leaked secrets!'\n];\nproblems.forEach(p => console.log(`  ${p}`));\n\n// GOOD: Environment variables\nconsole.log('\\n\\nâœ… CORRECT - Environment Variables:\\n');\n\nconst goodExample = {\n  database: process.env.DATABASE_URL,\n  jwtSecret: process.env.JWT_SECRET,\n  stripeKey: process.env.STRIPE_SECRET_KEY,\n  apiKey: process.env.API_KEY\n};\n\nObject.entries(goodExample).forEach(([key, value]) => {\n  console.log(`const ${key} = process.env.${value.replace('process.env.', '')};`);\n});\n\nconsole.log('\\nBenefits:');\nconst benefits = [\n  'âœ“ Secrets never in code or Git',\n  'âœ“ Different values per environment',\n  'âœ“ Change secrets without code changes',\n  'âœ“ Secure storage on hosting platforms',\n  'âœ“ Easy to rotate credentials'\n];\nbenefits.forEach(b => console.log(`  ${b}`));\n\n// CONCEPT: Different Environments\nconsole.log('\\n\\n=== Multi-Environment Setup ===\\n');\n\nconst environments = {\n  development: {\n    NODE_ENV: 'development',\n    DATABASE_URL: 'postgres://localhost/myapp_dev',\n    API_URL: 'http://localhost:3000',\n    JWT_SECRET: 'dev-secret-ok-to-be-simple',\n    DEBUG: 'true',\n    LOG_LEVEL: 'debug'\n  },\n  \n  staging: {\n    NODE_ENV: 'staging',\n    DATABASE_URL: 'postgres://staging-db.internal/myapp_staging',\n    API_URL: 'https://staging-api.myapp.com',\n    JWT_SECRET: 'complex-staging-secret-xyz789',\n    DEBUG: 'false',\n    LOG_LEVEL: 'info'\n  },\n  \n  production: {\n    NODE_ENV: 'production',\n    DATABASE_URL: 'postgres://prod-db.aws.com/myapp_prod',\n    API_URL: 'https://api.myapp.com',\n    JWT_SECRET: 'super-complex-production-secret-abc123xyz',\n    DEBUG: 'false',\n    LOG_LEVEL: 'error'\n  }\n};\n\nObject.entries(environments).forEach(([env, vars]) => {\n  console.log(`${env.toUpperCase()} Environment:`);\n  Object.entries(vars).forEach(([key, value]) => {\n    // Mask secrets\n    let displayValue = value;\n    if (key.includes('SECRET') || key.includes('PASSWORD')) {\n      displayValue = value.substring(0, 8) + '...[hidden]';\n    }\n    console.log(`  ${key}=${displayValue}`);\n  });\n  console.log('');\n});\n\n// SIMULATING ENVIRONMENT VARIABLE USAGE\nconsole.log('=== Using Environment Variables ===\\n');\n\nclass AppConfig {\n  constructor() {\n    // Simulate process.env\n    this.env = process.env;\n    \n    // Required variables\n    this.requiredVars = [\n      'DATABASE_URL',\n      'JWT_SECRET',\n      'NODE_ENV'\n    ];\n  }\n  \n  validate() {\n    console.log('Validating environment variables...\\n');\n    \n    const missing = [];\n    \n    this.requiredVars.forEach(varName => {\n      if (!this.env[varName]) {\n        missing.push(varName);\n      }\n    });\n    \n    if (missing.length > 0) {\n      console.log('âŒ Missing required environment variables:');\n      missing.forEach(v => console.log(`  - ${v}`));\n      console.log('\\nApp cannot start without these variables!\\n');\n      return false;\n    } else {\n      console.log('âœ… All required environment variables present\\n');\n      return true;\n    }\n  }\n  \n  get(key, fallback = null) {\n    const value = this.env[key];\n    if (!value && fallback !== null) {\n      console.log(`âš  ${key} not set, using fallback: ${fallback}`);\n      return fallback;\n    }\n    return value;\n  }\n  \n  showConfig() {\n    console.log('Current Configuration:');\n    console.log(`  Environment: ${this.get('NODE_ENV', 'development')}`);\n    console.log(`  Database: ${this.maskSecret(this.get('DATABASE_URL', 'Not set'))}`);\n    console.log(`  JWT Secret: ${this.maskSecret(this.get('JWT_SECRET', 'Not set'))}`);\n    console.log(`  Port: ${this.get('PORT', '3000')}`);\n    console.log(`  Debug: ${this.get('DEBUG', 'false')}\\n`);\n  }\n  \n  maskSecret(value) {\n    if (!value || value === 'Not set') return value;\n    if (value.length < 10) return '***';\n    return value.substring(0, 10) + '...[hidden]';\n  }\n}\n\n// Test with development environment\nprocess.env.NODE_ENV = 'development';\nprocess.env.DATABASE_URL = 'postgres://localhost/myapp_dev';\nprocess.env.JWT_SECRET = 'dev-secret';\nprocess.env.PORT = '3000';\n\nconst config = new AppConfig();\nconfig.validate();\nconfig.showConfig();\n\n// BEST PRACTICES\nconsole.log('=== Environment Variable Best Practices ===\\n');\n\nconst bestPractices = [\n  {\n    rule: '1. Never commit secrets to Git',\n    example: 'Add .env to .gitignore immediately!'\n  },\n  {\n    rule: '2. Use descriptive names',\n    example: 'DATABASE_URL (good) vs DB (bad)'\n  },\n  {\n    rule: '3. Provide .env.example',\n    example: 'Template showing what vars are needed (no real values!)'\n  },\n  {\n    rule: '4. Validate on startup',\n    example: 'Crash early if required vars missing'\n  },\n  {\n    rule: '5. Use different values per environment',\n    example: 'dev-simple-secret vs prod-complex-secret-xyz789'\n  },\n  {\n    rule: '6. Rotate secrets regularly',\n    example: 'Change JWT_SECRET every few months'\n  },\n  {\n    rule: '7. Document all variables',\n    example: 'README lists all env vars and what they do'\n  }\n];\n\nbestPractices.forEach(({ rule, example }) => {\n  console.log(rule);\n  console.log(`   â†’ ${example}\\n`);\n});\n\n// COMMON VARIABLES\nconsole.log('=== Common Environment Variables ===\\n');\n\nconst commonVars = {\n  'NODE_ENV': 'development | production | test',\n  'PORT': 'Server port (3000, 8080, etc.)',\n  'DATABASE_URL': 'Full database connection string',\n  'JWT_SECRET': 'Secret key for signing tokens',\n  'API_KEY': 'Third-party API keys',\n  'STRIPE_SECRET_KEY': 'Payment processing key',\n  'AWS_ACCESS_KEY_ID': 'AWS credentials',\n  'SMTP_HOST': 'Email server settings',\n  'CORS_ORIGIN': 'Allowed frontend URLs',\n  'LOG_LEVEL': 'debug | info | warn | error'\n};\n\nObject.entries(commonVars).forEach(([name, description]) => {\n  console.log(`${name.padEnd(20)} - ${description}`);\n});",
      "syntaxBreakdown": "Environment variables in practice:\n\n1. **Development (.env file)**:\n   ```bash\n   # .env (local development only, never commit!)\n   NODE_ENV=development\n   PORT=3000\n   DATABASE_URL=postgres://localhost/myapp_dev\n   JWT_SECRET=dev-secret-simple-is-ok\n   STRIPE_SECRET_KEY=sk_test_abc123\n   FRONTEND_URL=http://localhost:5173\n   ```\n\n2. **Loading .env file** (using dotenv):\n   ```javascript\n   // At the very top of server.js\n   import 'dotenv/config';\n   // or\n   require('dotenv').config();\n   \n   // Now process.env has your variables!\n   console.log(process.env.DATABASE_URL);\n   ```\n\n3. **Using environment variables**:\n   ```javascript\n   // Good pattern with fallbacks\n   const PORT = process.env.PORT || 3000;\n   const NODE_ENV = process.env.NODE_ENV || 'development';\n   \n   // Required variables (no fallback)\n   const DATABASE_URL = process.env.DATABASE_URL;\n   if (!DATABASE_URL) {\n     throw new Error('DATABASE_URL environment variable is required!');\n   }\n   \n   // Type conversion\n   const MAX_CONNECTIONS = parseInt(process.env.MAX_CONNECTIONS || '10', 10);\n   const ENABLE_DEBUG = process.env.ENABLE_DEBUG === 'true';\n   ```\n\n4. **Validation helper**:\n   ```javascript\n   function requireEnv(name) {\n     const value = process.env[name];\n     if (!value) {\n       throw new Error(`Missing required environment variable: ${name}`);\n     }\n     return value;\n   }\n   \n   // Usage\n   const DATABASE_URL = requireEnv('DATABASE_URL');\n   const JWT_SECRET = requireEnv('JWT_SECRET');\n   ```\n\n5. **.env.example** (commit this!):\n   ```bash\n   # .env.example - Template for other developers\n   # Copy this to .env and fill in real values\n   \n   NODE_ENV=development\n   PORT=3000\n   DATABASE_URL=postgres://localhost/myapp_dev\n   JWT_SECRET=your-secret-here\n   STRIPE_SECRET_KEY=sk_test_your-key\n   ```\n\n6. **.gitignore** (CRITICAL!):\n   ```\n   # Never commit these!\n   .env\n   .env.local\n   .env.development\n   .env.production\n   .env.test\n   \n   # DO commit this:\n   # .env.example\n   ```\n\n7. **Setting in Render (Backend)**:\n   ```\n   Render Dashboard:\n   1. Go to your web service\n   2. Click \"Environment\"\n   3. Add variables:\n      DATABASE_URL = postgres://...\n      JWT_SECRET = your-production-secret\n      NODE_ENV = production\n   4. Save (triggers redeploy)\n   ```\n\n8. **Setting in Vercel (Frontend)**:\n   ```\n   Vercel Dashboard:\n   1. Project Settings â†’ Environment Variables\n   2. Add variables (must start with VITE_):\n      VITE_API_URL = https://api.myapp.com\n      VITE_STRIPE_PUBLIC_KEY = pk_live_...\n   3. Redeploy to apply changes\n   ```\n\n9. **Environment-specific logic**:\n   ```javascript\n   const isDevelopment = process.env.NODE_ENV === 'development';\n   const isProduction = process.env.NODE_ENV === 'production';\n   \n   if (isDevelopment) {\n     // Detailed logging\n     console.log('Full error:', error.stack);\n     \n     // Allow all CORS in dev\n     app.use(cors({ origin: '*' }));\n   }\n   \n   if (isProduction) {\n     // Hide error details\n     console.log('Error occurred');\n     \n     // Strict CORS\n     app.use(cors({ origin: process.env.FRONTEND_URL }));\n   }\n   ```\n\n10. **Configuration module pattern**:\n    ```javascript\n    // config/index.js\n    export const config = {\n      env: process.env.NODE_ENV || 'development',\n      port: parseInt(process.env.PORT || '3000', 10),\n      \n      database: {\n        url: process.env.DATABASE_URL,\n        poolSize: parseInt(process.env.DB_POOL_SIZE || '10', 10)\n      },\n      \n      jwt: {\n        secret: process.env.JWT_SECRET,\n        expiresIn: process.env.JWT_EXPIRES || '7d'\n      },\n      \n      stripe: {\n        secretKey: process.env.STRIPE_SECRET_KEY,\n        webhookSecret: process.env.STRIPE_WEBHOOK_SECRET\n      },\n      \n      cors: {\n        origin: process.env.CORS_ORIGIN || 'http://localhost:5173'\n      }\n    };\n    \n    // Validate on import\n    const required = ['DATABASE_URL', 'JWT_SECRET'];\n    required.forEach(key => {\n      if (!process.env[key]) {\n        throw new Error(`Missing required env var: ${key}`);\n      }\n    });\n    ```",
      "challenge": {
        "instructions": "Create an environment configuration system:\n\n1. Create a `Config` class that:\n   - Loads variables from process.env\n   - Validates required variables\n   - Provides get() method with fallbacks\n   - Masks secrets when displaying\n\n2. Test with sample environment variables",
        "starterCode": "// Environment configuration manager\n\nclass Config {\n  constructor() {\n    this.required = ['DATABASE_URL', 'JWT_SECRET'];\n  }\n  \n  validate() {\n    const missing = this.required.filter(key => !process.env[key]);\n    \n    if (missing.length > 0) {\n      console.log('âŒ Missing required variables:');\n      missing.forEach(v => console.log(`  - ${v}`));\n      return false;\n    }\n    \n    console.log('âœ… All required variables present');\n    return true;\n  }\n  \n  get(key, fallback = null) {\n    return process.env[key] || fallback;\n  }\n  \n  maskSecret(value) {\n    if (!value || value.length < 8) return '***';\n    return value.substring(0, 8) + '...';\n  }\n  \n  show() {\n    console.log('\\nConfiguration:');\n    console.log(`  NODE_ENV: ${this.get('NODE_ENV', 'development')}`);\n    console.log(`  PORT: ${this.get('PORT', '3000')}`);\n    console.log(`  DATABASE: ${this.maskSecret(this.get('DATABASE_URL', 'not set'))}`);\n    console.log(`  JWT_SECRET: ${this.maskSecret(this.get('JWT_SECRET', 'not set'))}`);\n  }\n}\n\n// Test\nprocess.env.NODE_ENV = 'production';\nprocess.env.PORT = '8080';\nprocess.env.DATABASE_URL = 'postgres://prod-db.com/myapp';\nprocess.env.JWT_SECRET = 'super-secret-key-xyz';\n\nconst config = new Config();\nconfig.validate();\nconfig.show();",
        "testCases": [
          {
            "description": "Should detect missing required variables",
            "input": "delete process.env.JWT_SECRET; config.validate()",
            "expectedOutput": "false (missing JWT_SECRET)"
          }
        ],
        "hint": "Use process.env to access environment variables"
      },
      "solution": "// Complete environment configuration system\n\nclass Config {\n  constructor() {\n    // Define required variables\n    this.required = [\n      'NODE_ENV',\n      'DATABASE_URL',\n      'JWT_SECRET'\n    ];\n    \n    // Define optional variables with defaults\n    this.defaults = {\n      PORT: '3000',\n      LOG_LEVEL: 'info',\n      CORS_ORIGIN: 'http://localhost:5173',\n      JWT_EXPIRES: '7d'\n    };\n    \n    this.env = process.env;\n  }\n  \n  validate() {\n    console.log('ðŸ” Validating environment configuration...\\n');\n    \n    const missing = [];\n    const present = [];\n    \n    this.required.forEach(key => {\n      if (!this.env[key]) {\n        missing.push(key);\n      } else {\n        present.push(key);\n      }\n    });\n    \n    if (present.length > 0) {\n      console.log('âœ… Found required variables:');\n      present.forEach(v => console.log(`  âœ“ ${v}`));\n      console.log('');\n    }\n    \n    if (missing.length > 0) {\n      console.log('âŒ Missing required variables:');\n      missing.forEach(v => console.log(`  âœ— ${v}`));\n      console.log('\\nâš  Application cannot start without these variables!\\n');\n      return false;\n    }\n    \n    console.log('âœ… All required environment variables present!\\n');\n    return true;\n  }\n  \n  get(key, fallback = null) {\n    let value = this.env[key];\n    \n    // Use default if available\n    if (!value && this.defaults[key]) {\n      value = this.defaults[key];\n    }\n    \n    // Use provided fallback\n    if (!value && fallback !== null) {\n      value = fallback;\n    }\n    \n    return value;\n  }\n  \n  getInt(key, fallback = 0) {\n    const value = this.get(key, fallback.toString());\n    return parseInt(value, 10);\n  }\n  \n  getBool(key, fallback = false) {\n    const value = this.get(key, fallback.toString());\n    return value === 'true' || value === '1';\n  }\n  \n  isProduction() {\n    return this.get('NODE_ENV') === 'production';\n  }\n  \n  isDevelopment() {\n    return this.get('NODE_ENV') === 'development';\n  }\n  \n  maskSecret(value) {\n    if (!value || value === 'not set') return value;\n    if (value.length < 8) return '***';\n    return value.substring(0, 8) + '...[hidden]';\n  }\n  \n  show() {\n    console.log('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');\n    console.log('â”‚     Environment Configuration        â”‚');\n    console.log('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\\n');\n    \n    console.log('General:');\n    console.log(`  NODE_ENV:     ${this.get('NODE_ENV')}`);\n    console.log(`  PORT:         ${this.get('PORT')}`);\n    console.log(`  LOG_LEVEL:    ${this.get('LOG_LEVEL')}\\n`);\n    \n    console.log('Database:');\n    console.log(`  DATABASE_URL: ${this.maskSecret(this.get('DATABASE_URL', 'not set'))}\\n`);\n    \n    console.log('Security:');\n    console.log(`  JWT_SECRET:   ${this.maskSecret(this.get('JWT_SECRET', 'not set'))}`);\n    console.log(`  JWT_EXPIRES:  ${this.get('JWT_EXPIRES')}\\n`);\n    \n    console.log('CORS:');\n    console.log(`  CORS_ORIGIN:  ${this.get('CORS_ORIGIN')}\\n`);\n    \n    if (this.isProduction()) {\n      console.log('ðŸš€ Running in PRODUCTION mode');\n    } else {\n      console.log('ðŸ”§ Running in DEVELOPMENT mode');\n    }\n    \n    console.log('\\n' + 'â•'.repeat(39) + '\\n');\n  }\n  \n  toObject() {\n    return {\n      env: this.get('NODE_ENV'),\n      port: this.getInt('PORT'),\n      logLevel: this.get('LOG_LEVEL'),\n      \n      database: {\n        url: this.get('DATABASE_URL')\n      },\n      \n      jwt: {\n        secret: this.get('JWT_SECRET'),\n        expiresIn: this.get('JWT_EXPIRES')\n      },\n      \n      cors: {\n        origin: this.get('CORS_ORIGIN')\n      }\n    };\n  }\n}\n\n// Simulate different environments\nconsole.log('=== Testing Environment Configurations ===\\n');\n\n// Test 1: Development\nconsole.log('Test 1: Development Environment\\n');\nprocess.env.NODE_ENV = 'development';\nprocess.env.PORT = '3000';\nprocess.env.DATABASE_URL = 'postgres://localhost/myapp_dev';\nprocess.env.JWT_SECRET = 'dev-secret-simple';\n\nlet config = new Config();\nconfig.validate();\nconfig.show();\n\n// Test 2: Production\nconsole.log('\\nTest 2: Production Environment\\n');\nprocess.env.NODE_ENV = 'production';\nprocess.env.PORT = '8080';\nprocess.env.DATABASE_URL = 'postgres://prod.aws.com/myapp';\nprocess.env.JWT_SECRET = 'super-complex-prod-secret-xyz789';\nprocess.env.LOG_LEVEL = 'error';\nprocess.env.CORS_ORIGIN = 'https://myapp.com';\n\nconfig = new Config();\nconfig.validate();\nconfig.show();\n\n// Test 3: Missing required variable\nconsole.log('\\nTest 3: Missing Required Variable\\n');\ndelete process.env.JWT_SECRET;\n\nconfig = new Config();\nconst isValid = config.validate();\n\nif (!isValid) {\n  console.log('Cannot start application. Please set missing variables.\\n');\n}\n\n// Best practices guide\nconsole.log('\\n=== Environment Variable Best Practices ===\\n');\n\nconst guide = [\n  {\n    do: 'âœ“ Use .env for local development',\n    dont: 'âœ— Commit .env to Git'\n  },\n  {\n    do: 'âœ“ Provide .env.example template',\n    dont: 'âœ— Put real secrets in .env.example'\n  },\n  {\n    do: 'âœ“ Validate required vars on startup',\n    dont: \"âœ— Let app crash with 'undefined' errors\"\n  },\n  {\n    do: 'âœ“ Use descriptive variable names',\n    dont: 'âœ— Use vague names like SECRET or KEY'\n  },\n  {\n    do: 'âœ“ Different secrets per environment',\n    dont: 'âœ— Reuse dev secrets in production'\n  },\n  {\n    do: 'âœ“ Document all variables in README',\n    dont: 'âœ— Leave developers guessing'\n  }\n];\n\nguide.forEach(({ do: good, dont: bad }) => {\n  console.log(good);\n  console.log(bad);\n  console.log('');\n});",
      "commonStickingPoints": "Common environment variable mistakes:\n\n1. **Committing .env to Git** (MAJOR security issue!):\n   ```bash\n   # Check if .env is tracked:\n   git ls-files | grep .env\n   \n   # If it returns .env, you've committed secrets!\n   # Fix immediately:\n   git rm --cached .env\n   echo \".env\" >> .gitignore\n   git commit -m \"Remove .env from git\"\n   \n   # If already pushed to GitHub:\n   # 1. Rotate all secrets immediately!\n   # 2. Consider the secrets compromised\n   ```\n\n2. **Forgot to load dotenv**:\n   ```javascript\n   // Error: process.env.DATABASE_URL is undefined\n   \n   // Fix: Load dotenv at the very top\n   import 'dotenv/config';  // Must be first!\n   import express from 'express';\n   \n   // or\n   require('dotenv').config();  // Must be first!\n   const express = require('express');\n   ```\n\n3. **Wrong variable names** (typos):\n   ```javascript\n   // .env\n   DATABASE_URL=postgres://...\n   \n   // server.js\n   const db = process.env.DATABSE_URL;  // âœ— Typo! Returns undefined\n   const db = process.env.DATABASE_URL;  // âœ“ Correct\n   \n   // Tip: Use constants to avoid typos\n   const REQUIRED_VARS = ['DATABASE_URL', 'JWT_SECRET'];\n   ```\n\n4. **Not updating production env vars**:\n   ```\n   Changed .env locally but forgot to update Render!\n   \n   Fix:\n   1. Update .env â†’ works locally\n   2. Update Render Environment Variables â†’ works in production\n   3. Must update BOTH places!\n   ```\n\n5. **Hardcoded fallbacks for secrets**:\n   ```javascript\n   // WRONG! Production will use insecure fallback\n   const JWT_SECRET = process.env.JWT_SECRET || 'default-secret';  // âœ—\n   \n   // CORRECT! Fail if secret is missing\n   const JWT_SECRET = process.env.JWT_SECRET;\n   if (!JWT_SECRET) {\n     throw new Error('JWT_SECRET environment variable is required!');\n   }\n   ```\n\n6. **Type confusion** (everything is a string!):\n   ```javascript\n   // WRONG! process.env values are always strings\n   const PORT = process.env.PORT;  // \"3000\" (string)\n   app.listen(PORT);  // Works but technically wrong type\n   \n   const MAX = process.env.MAX_ITEMS;  // \"10\" (string)\n   if (items.length > MAX) // âœ— String comparison!\n   \n   // CORRECT! Convert types explicitly\n   const PORT = parseInt(process.env.PORT || '3000', 10);  // number\n   const MAX = parseInt(process.env.MAX_ITEMS || '10', 10);  // number\n   const DEBUG = process.env.DEBUG === 'true';  // boolean\n   ```\n\n7. **Exposing env vars in frontend** (React/Vite):\n   ```javascript\n   // Backend (.env) - These are SECRET!\n   DATABASE_URL=postgres://...\n   JWT_SECRET=super-secret\n   STRIPE_SECRET_KEY=sk_live_...\n   \n   // Frontend (.env) - These are PUBLIC!\n   VITE_API_URL=https://api.com\n   VITE_STRIPE_PUBLIC_KEY=pk_live_...  // Note: PUBLIC key\n   \n   // Remember: VITE_ vars are bundled into JavaScript\n   // Anyone can see them in browser!\n   // NEVER put secrets in VITE_ variables!\n   ```\n\n8. **Missing .env.example**:\n   ```bash\n   # Create .env.example (commit this!)\n   # Other developers copy this to .env\n   \n   # .env.example\n   NODE_ENV=development\n   PORT=3000\n   DATABASE_URL=postgres://localhost/myapp_dev\n   JWT_SECRET=your-secret-here\n   STRIPE_SECRET_KEY=sk_test_your-key\n   \n   # Instructions for new developers:\n   # 1. Copy .env.example to .env\n   # 2. Fill in real values\n   # 3. Never commit .env!\n   ```\n\n9. **Environment variables not rebuilding**:\n   ```\n   React/Vite issue:\n   - Changed VITE_API_URL in Vercel\n   - Still seeing old value!\n   \n   Why: Env vars are baked into build at build time\n   \n   Fix:\n   1. Change env var in Vercel dashboard\n   2. Trigger new deployment (Deployments â†’ Redeploy)\n   3. Env vars from build time are used, not runtime!\n   ```\n\n10. **Different formats on different platforms**:\n    ```bash\n    # .env file format (local)\n    DATABASE_URL=postgres://localhost/db\n    NODE_ENV=development\n    \n    # Render format (same!)\n    DATABASE_URL = postgres://render.com/db\n    NODE_ENV = production\n    \n    # Note: Render adds spaces around =, both work fine\n    # Just be consistent in your .env file\n    ```"
    },
    {
      "id": "14.5",
      "title": "Production Best Practices (The Professional Kitchen Analogy)",
      "conceptAnalogy": "Imagine running a professional restaurant kitchen:\n\nAmateur kitchen (bad practices):\n- No temperature monitoring â†’ food safety issues\n- No backup ingredients â†’ run out during dinner rush\n- No security cameras â†’ theft happens\n- No health inspector â†’ violations pile up\n- No cleaning schedule â†’ kitchen becomes disaster\n- No documentation â†’ new cooks can't follow recipes\n\nProfessional kitchen (best practices):\n- Temperature sensors everywhere â†’ instant alerts\n- Backup suppliers â†’ never run out\n- Security system â†’ track everything\n- Regular inspections â†’ always compliant\n- Daily cleaning checklist â†’ spotless kitchen\n- Recipe book + training videos â†’ easy onboarding\n- Fire suppression system â†’ handle emergencies\n\nProduction applications need the same professionalism:\n- Monitoring (know what's happening)\n- Backups (recover from disasters)\n- Security (protect user data)\n- Testing (catch bugs before users do)\n- Documentation (help future developers)\n- Error tracking (fix issues quickly)\n- Performance optimization (fast = happy users)\n\nThink of production best practices as running a professional operation!",
      "codeExample": "// Production Best Practices - Concepts\n\nconsole.log('=== Production Best Practices ===\\n');\n\n// CONCEPT 1: Health Checks\nconsole.log('1. HEALTH CHECKS & UPTIME MONITORING\\n');\n\nconst healthCheck = {\n  endpoint: '/health',\n  \n  check() {\n    console.log('Health check running...');\n    \n    const checks = [\n      { name: 'Database', status: this.checkDatabase() },\n      { name: 'API Server', status: 'healthy' },\n      { name: 'Memory Usage', status: this.checkMemory() },\n      { name: 'Disk Space', status: 'healthy' }\n    ];\n    \n    const allHealthy = checks.every(c => c.status === 'healthy');\n    \n    console.log('\\nHealth Status:');\n    checks.forEach(({ name, status }) => {\n      const icon = status === 'healthy' ? 'âœ“' : 'âœ—';\n      console.log(`  ${icon} ${name}: ${status}`);\n    });\n    \n    return {\n      status: allHealthy ? 'healthy' : 'unhealthy',\n      timestamp: new Date(),\n      checks: checks\n    };\n  },\n  \n  checkDatabase() {\n    // Simulate database ping\n    const latency = Math.random() * 100;\n    return latency < 80 ? 'healthy' : 'slow';\n  },\n  \n  checkMemory() {\n    // Simulate memory check\n    const usagePercent = Math.random() * 100;\n    return usagePercent < 90 ? 'healthy' : 'high';\n  }\n};\n\nconst health = healthCheck.check();\nconsole.log(`\\nOverall: ${health.status}\\n`);\n\n// CONCEPT 2: Error Tracking\nconsole.log('\\n2. ERROR TRACKING & LOGGING\\n');\n\nclass ErrorTracker {\n  constructor() {\n    this.errors = [];\n    this.logLevel = process.env.LOG_LEVEL || 'info';\n  }\n  \n  captureError(error, context = {}) {\n    const errorReport = {\n      message: error.message,\n      stack: error.stack,\n      timestamp: new Date(),\n      environment: process.env.NODE_ENV,\n      user: context.userId || 'anonymous',\n      url: context.url || 'unknown',\n      severity: 'error'\n    };\n    \n    this.errors.push(errorReport);\n    \n    console.log('ðŸš¨ Error Captured:');\n    console.log(`  Message: ${errorReport.message}`);\n    console.log(`  User: ${errorReport.user}`);\n    console.log(`  URL: ${errorReport.url}`);\n    console.log(`  Time: ${errorReport.timestamp}\\n`);\n    \n    // In production, send to Sentry/LogRocket/etc.\n    this.sendToMonitoring(errorReport);\n  }\n  \n  sendToMonitoring(report) {\n    console.log('  â†’ Sent to error tracking service (Sentry)\\n');\n  }\n  \n  log(level, message) {\n    const levels = ['debug', 'info', 'warn', 'error'];\n    const currentLevel = levels.indexOf(this.logLevel);\n    const messageLevel = levels.indexOf(level);\n    \n    if (messageLevel >= currentLevel) {\n      console.log(`[${level.toUpperCase()}] ${message}`);\n    }\n  }\n}\n\nconst tracker = new ErrorTracker();\n\ntry {\n  // Simulate error\n  throw new Error('Database connection failed');\n} catch (error) {\n  tracker.captureError(error, {\n    userId: 'user_123',\n    url: '/api/users'\n  });\n}\n\n// CONCEPT 3: Performance Monitoring\nconsole.log('\\n3. PERFORMANCE MONITORING\\n');\n\nclass PerformanceMonitor {\n  constructor() {\n    this.metrics = [];\n  }\n  \n  trackRequest(endpoint, duration) {\n    this.metrics.push({\n      endpoint,\n      duration,\n      timestamp: new Date()\n    });\n    \n    if (duration > 1000) {\n      console.log(`âš  SLOW REQUEST: ${endpoint} took ${duration}ms`);\n    } else {\n      console.log(`âœ“ ${endpoint}: ${duration}ms`);\n    }\n  }\n  \n  getStats() {\n    if (this.metrics.length === 0) return null;\n    \n    const durations = this.metrics.map(m => m.duration);\n    const avg = durations.reduce((a, b) => a + b, 0) / durations.length;\n    const max = Math.max(...durations);\n    const min = Math.min(...durations);\n    \n    return {\n      average: Math.round(avg),\n      max: max,\n      min: min,\n      total: this.metrics.length\n    };\n  }\n  \n  showReport() {\n    console.log('\\n=== Performance Report ===\\n');\n    const stats = this.getStats();\n    if (stats) {\n      console.log(`Total Requests: ${stats.total}`);\n      console.log(`Average Time: ${stats.average}ms`);\n      console.log(`Fastest: ${stats.min}ms`);\n      console.log(`Slowest: ${stats.max}ms\\n`);\n    }\n  }\n}\n\nconst monitor = new PerformanceMonitor();\nmonitor.trackRequest('/api/users', 45);\nmonitor.trackRequest('/api/products', 1200);\nmonitor.trackRequest('/api/orders', 89);\nmonitor.showReport();\n\n// CONCEPT 4: Security Best Practices\nconsole.log('\\n4. SECURITY CHECKLIST\\n');\n\nconst securityChecklist = [\n  {\n    practice: 'Use HTTPS everywhere',\n    why: 'Encrypt data in transit',\n    how: 'SSL certificates (free from Let\\'s Encrypt)'\n  },\n  {\n    practice: 'Validate all input',\n    why: 'Prevent SQL injection, XSS',\n    how: 'Use validation libraries (Zod, Joi)'\n  },\n  {\n    practice: 'Rate limit API endpoints',\n    why: 'Prevent abuse and DDoS',\n    how: 'express-rate-limit middleware'\n  },\n  {\n    practice: 'Use security headers',\n    why: 'Protect against common attacks',\n    how: 'helmet middleware for Express'\n  },\n  {\n    practice: 'Keep dependencies updated',\n    why: 'Patch security vulnerabilities',\n    how: 'npm audit, Dependabot'\n  },\n  {\n    practice: 'Store passwords hashed',\n    why: 'Never store plaintext passwords',\n    how: 'bcrypt library'\n  }\n];\n\nsecurityChecklist.forEach(({ practice, why, how }) => {\n  console.log(`âœ“ ${practice}`);\n  console.log(`  Why: ${why}`);\n  console.log(`  How: ${how}\\n`);\n});\n\n// CONCEPT 5: Deployment Checklist\nconsole.log('\\n5. PRE-DEPLOYMENT CHECKLIST\\n');\n\nconst deploymentChecklist = [\n  { task: 'Run all tests', command: 'npm test', critical: true },\n  { task: 'Check for console.logs', command: 'grep -r \"console.log\" src/', critical: false },\n  { task: 'Build succeeds', command: 'npm run build', critical: true },\n  { task: 'Environment variables set', command: 'Check Render/Vercel dashboard', critical: true },\n  { task: 'Database migrations run', command: 'npx prisma migrate deploy', critical: true },\n  { task: 'CORS configured correctly', command: 'Test from production frontend', critical: true },\n  { task: 'Error tracking enabled', command: 'Verify Sentry DSN', critical: false },\n  { task: 'Monitoring alerts set up', command: 'Configure UptimeRobot/etc', critical: false }\n];\n\nconsole.log('Before deploying, verify:\\n');\ndeploymentChecklist.forEach(({ task, command, critical }) => {\n  const icon = critical ? 'ðŸ”´' : 'ðŸŸ¡';\n  console.log(`${icon} ${task}`);\n  console.log(`   Command: ${command}\\n`);\n});\n\n// BEST PRACTICES SUMMARY\nconsole.log('\\n=== Production Best Practices Summary ===\\n');\n\nconst bestPractices = [\n  '1. Monitoring: Know when things break (before users complain!)',\n  '2. Logging: Track what happened (debug production issues)',\n  '3. Backups: Regular database backups (recover from disasters)',\n  '4. Security: HTTPS, rate limiting, input validation',\n  '5. Performance: Monitor response times, optimize slow queries',\n  '6. Error Tracking: Sentry/LogRocket to catch errors',\n  '7. Testing: Write tests, run before deploy',\n  '8. Documentation: README, API docs, deployment guide',\n  '9. Alerts: Get notified when app goes down',\n  '10. Graceful Degradation: Handle third-party service failures'\n];\n\nbestPractices.forEach(practice => console.log(practice));",
      "syntaxBreakdown": "Production best practices in code:\n\n1. **Health Check Endpoint**:\n   ```javascript\n   // server.js\n   app.get('/health', async (req, res) => {\n     try {\n       // Test database\n       await prisma.$queryRaw`SELECT 1`;\n       \n       res.json({\n         status: 'healthy',\n         timestamp: new Date(),\n         uptime: process.uptime(),\n         memory: process.memoryUsage()\n       });\n     } catch (error) {\n       res.status(503).json({\n         status: 'unhealthy',\n         error: 'Database connection failed'\n       });\n     }\n   });\n   ```\n\n2. **Error Tracking (Sentry)**:\n   ```javascript\n   import * as Sentry from '@sentry/node';\n   \n   Sentry.init({\n     dsn: process.env.SENTRY_DSN,\n     environment: process.env.NODE_ENV\n   });\n   \n   // Error handler\n   app.use((err, req, res, next) => {\n     // Log to Sentry\n     Sentry.captureException(err);\n     \n     console.error(err.stack);\n     \n     if (process.env.NODE_ENV === 'production') {\n       res.status(500).json({ error: 'Internal server error' });\n     } else {\n       res.status(500).json({ error: err.message, stack: err.stack });\n     }\n   });\n   ```\n\n3. **Request Logging (Morgan)**:\n   ```javascript\n   import morgan from 'morgan';\n   \n   if (process.env.NODE_ENV === 'production') {\n     app.use(morgan('combined'));  // Standard Apache format\n   } else {\n     app.use(morgan('dev'));  // Colored, concise output\n   }\n   ```\n\n4. **Rate Limiting**:\n   ```javascript\n   import rateLimit from 'express-rate-limit';\n   \n   const limiter = rateLimit({\n     windowMs: 15 * 60 * 1000,  // 15 minutes\n     max: 100,  // Limit each IP to 100 requests per window\n     message: 'Too many requests, please try again later'\n   });\n   \n   app.use('/api/', limiter);\n   ```\n\n5. **Security Headers (Helmet)**:\n   ```javascript\n   import helmet from 'helmet';\n   \n   app.use(helmet());\n   // Adds:\n   // - X-Content-Type-Options\n   // - X-Frame-Options\n   // - X-XSS-Protection\n   // - And more...\n   ```\n\n6. **Graceful Shutdown**:\n   ```javascript\n   const server = app.listen(PORT);\n   \n   process.on('SIGTERM', () => {\n     console.log('SIGTERM received, shutting down gracefully');\n     \n     server.close(() => {\n       console.log('HTTP server closed');\n       \n       // Close database connections\n       prisma.$disconnect();\n       \n       process.exit(0);\n     });\n   });\n   ```\n\n7. **Input Validation (Zod)**:\n   ```javascript\n   import { z } from 'zod';\n   \n   const userSchema = z.object({\n     email: z.string().email(),\n     password: z.string().min(8),\n     age: z.number().int().positive()\n   });\n   \n   app.post('/api/users', (req, res) => {\n     try {\n       const validData = userSchema.parse(req.body);\n       // Use validData safely\n     } catch (error) {\n       res.status(400).json({ error: error.errors });\n     }\n   });\n   ```\n\n8. **Database Connection Pooling**:\n   ```javascript\n   // Prisma handles this automatically!\n   const prisma = new PrismaClient({\n     log: process.env.NODE_ENV === 'development' ? ['query'] : [],\n     datasources: {\n       db: { url: process.env.DATABASE_URL }\n     }\n   });\n   ```\n\n9. **Compression**:\n   ```javascript\n   import compression from 'compression';\n   \n   app.use(compression());  // Gzip responses\n   ```\n\n10. **Environment-based Configuration**:\n    ```javascript\n    const config = {\n      development: {\n        logLevel: 'debug',\n        cacheEnabled: false,\n        detailedErrors: true\n      },\n      production: {\n        logLevel: 'error',\n        cacheEnabled: true,\n        detailedErrors: false\n      }\n    };\n    \n    export default config[process.env.NODE_ENV || 'development'];\n    ```",
      "challenge": {
        "instructions": "Create a production monitoring system:\n\n1. Create a `ProductionMonitor` class that:\n   - Tracks health checks\n   - Logs errors\n   - Monitors performance\n   - Generates reports\n\n2. Simulate a production environment with various checks",
        "starterCode": "// Production monitoring system\n\nclass ProductionMonitor {\n  constructor() {\n    this.errors = [];\n    this.metrics = [];\n  }\n  \n  healthCheck() {\n    const checks = {\n      database: Math.random() > 0.1 ? 'healthy' : 'down',\n      api: 'healthy',\n      memory: Math.random() * 100 < 90 ? 'healthy' : 'high'\n    };\n    \n    console.log('Health Check:');\n    Object.entries(checks).forEach(([name, status]) => {\n      console.log(`  ${name}: ${status}`);\n    });\n    \n    return checks;\n  }\n  \n  logError(error, context) {\n    this.errors.push({ error: error.message, context, time: new Date() });\n    console.log(`\\nðŸš¨ Error: ${error.message}`);\n  }\n  \n  trackMetric(name, value) {\n    this.metrics.push({ name, value, time: new Date() });\n    console.log(`ðŸ“Š ${name}: ${value}`);\n  }\n  \n  report() {\n    console.log('\\n=== Production Report ===');\n    console.log(`Errors: ${this.errors.length}`);\n    console.log(`Metrics: ${this.metrics.length}`);\n  }\n}\n\n// Test\nconst monitor = new ProductionMonitor();\nmonitor.healthCheck();\nmonitor.trackMetric('response_time', 145);\nmonitor.logError(new Error('DB timeout'), { user: 'user_123' });\nmonitor.report();",
        "testCases": [
          {
            "description": "Should track errors",
            "input": "monitor.logError(new Error('Test')); monitor.errors.length",
            "expectedOutput": "1"
          }
        ],
        "hint": "Track health, errors, and metrics in separate arrays"
      },
      "solution": "// Complete production monitoring system\n\nclass ProductionMonitor {\n  constructor() {\n    this.errors = [];\n    this.metrics = [];\n    this.healthHistory = [];\n    this.alerts = [];\n    this.startTime = Date.now();\n  }\n  \n  healthCheck() {\n    console.log('ðŸ¥ Running Health Check...\\n');\n    \n    const checks = {\n      database: this.checkDatabase(),\n      api: this.checkAPI(),\n      memory: this.checkMemory(),\n      diskSpace: this.checkDisk(),\n      uptime: this.getUptime()\n    };\n    \n    const allHealthy = Object.values(checks).every(c => \n      c.status === 'healthy' || c.status === 'ok'\n    );\n    \n    const healthReport = {\n      timestamp: new Date(),\n      overall: allHealthy ? 'healthy' : 'unhealthy',\n      checks: checks\n    };\n    \n    this.healthHistory.push(healthReport);\n    \n    console.log('Health Status:');\n    Object.entries(checks).forEach(([name, check]) => {\n      const icon = check.status === 'healthy' || check.status === 'ok' ? 'âœ…' : 'âŒ';\n      console.log(`  ${icon} ${name}: ${check.status} ${check.details || ''}`);\n    });\n    \n    console.log(`\\nOverall: ${healthReport.overall.toUpperCase()}\\n`);\n    \n    if (!allHealthy) {\n      this.createAlert('Health check failed', healthReport);\n    }\n    \n    return healthReport;\n  }\n  \n  checkDatabase() {\n    const latency = Math.random() * 150;\n    if (latency > 100) {\n      return { status: 'slow', details: `(${Math.round(latency)}ms)` };\n    }\n    return { status: 'healthy', details: `(${Math.round(latency)}ms)` };\n  }\n  \n  checkAPI() {\n    return { status: 'healthy', details: '(responding)' };\n  }\n  \n  checkMemory() {\n    const usage = Math.random() * 100;\n    if (usage > 90) {\n      return { status: 'critical', details: `(${Math.round(usage)}%)` };\n    } else if (usage > 75) {\n      return { status: 'warning', details: `(${Math.round(usage)}%)` };\n    }\n    return { status: 'healthy', details: `(${Math.round(usage)}%)` };\n  }\n  \n  checkDisk() {\n    return { status: 'healthy', details: '(45% used)' };\n  }\n  \n  getUptime() {\n    const seconds = Math.floor((Date.now() - this.startTime) / 1000);\n    return { status: 'ok', details: `(${seconds}s)` };\n  }\n  \n  logError(error, context = {}) {\n    const errorReport = {\n      message: error.message,\n      stack: error.stack,\n      timestamp: new Date(),\n      severity: context.severity || 'error',\n      user: context.userId || 'anonymous',\n      endpoint: context.endpoint || 'unknown',\n      environment: process.env.NODE_ENV || 'development'\n    };\n    \n    this.errors.push(errorReport);\n    \n    console.log('\\nðŸš¨ ERROR CAPTURED:');\n    console.log('â”€'.repeat(40));\n    console.log(`Time: ${errorReport.timestamp.toISOString()}`);\n    console.log(`Severity: ${errorReport.severity}`);\n    console.log(`Message: ${errorReport.message}`);\n    console.log(`User: ${errorReport.user}`);\n    console.log(`Endpoint: ${errorReport.endpoint}`);\n    \n    if (process.env.NODE_ENV !== 'production') {\n      console.log(`\\nStack Trace:\\n${errorReport.stack}`);\n    }\n    \n    console.log('â”€'.repeat(40) + '\\n');\n    \n    // Simulate sending to error tracking service\n    this.sendToSentry(errorReport);\n    \n    if (errorReport.severity === 'critical') {\n      this.createAlert('Critical error occurred', errorReport);\n    }\n  }\n  \n  sendToSentry(error) {\n    console.log('  â†’ Sent to Sentry for tracking\\n');\n  }\n  \n  trackMetric(name, value, unit = '') {\n    const metric = {\n      name,\n      value,\n      unit,\n      timestamp: new Date()\n    };\n    \n    this.metrics.push(metric);\n    \n    // Check for performance issues\n    if (name === 'response_time' && value > 1000) {\n      console.log(`âš ï¸  SLOW: ${name} = ${value}${unit} (threshold: 1000ms)`);\n      this.createAlert('Slow response time', metric);\n    } else {\n      console.log(`ðŸ“Š ${name}: ${value}${unit}`);\n    }\n  }\n  \n  createAlert(title, data) {\n    const alert = {\n      title,\n      data,\n      timestamp: new Date(),\n      resolved: false\n    };\n    \n    this.alerts.push(alert);\n    \n    console.log(`\\nðŸ”” ALERT: ${title}`);\n    console.log(`   Time: ${alert.timestamp.toISOString()}\\n`);\n  }\n  \n  getMetricStats(metricName) {\n    const metricData = this.metrics\n      .filter(m => m.name === metricName)\n      .map(m => m.value);\n    \n    if (metricData.length === 0) return null;\n    \n    const sum = metricData.reduce((a, b) => a + b, 0);\n    const avg = sum / metricData.length;\n    const max = Math.max(...metricData);\n    const min = Math.min(...metricData);\n    \n    return {\n      count: metricData.length,\n      average: Math.round(avg * 100) / 100,\n      max,\n      min\n    };\n  }\n  \n  generateReport() {\n    console.log('\\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');\n    console.log('â”‚     Production Monitor Report       â”‚');\n    console.log('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\\n');\n    \n    console.log('UPTIME:');\n    const uptimeSeconds = Math.floor((Date.now() - this.startTime) / 1000);\n    console.log(`  ${uptimeSeconds} seconds\\n`);\n    \n    console.log('ERRORS:');\n    console.log(`  Total: ${this.errors.length}`);\n    if (this.errors.length > 0) {\n      const lastError = this.errors[this.errors.length - 1];\n      console.log(`  Last: ${lastError.message}`);\n      console.log(`  Time: ${lastError.timestamp.toISOString()}`);\n    }\n    console.log('');\n    \n    console.log('PERFORMANCE:');\n    const responseStats = this.getMetricStats('response_time');\n    if (responseStats) {\n      console.log(`  Requests: ${responseStats.count}`);\n      console.log(`  Avg Response: ${responseStats.average}ms`);\n      console.log(`  Fastest: ${responseStats.min}ms`);\n      console.log(`  Slowest: ${responseStats.max}ms`);\n    } else {\n      console.log('  No metrics recorded yet');\n    }\n    console.log('');\n    \n    console.log('HEALTH CHECKS:');\n    console.log(`  Total: ${this.healthHistory.length}`);\n    if (this.healthHistory.length > 0) {\n      const latest = this.healthHistory[this.healthHistory.length - 1];\n      console.log(`  Latest: ${latest.overall}`);\n      console.log(`  Time: ${latest.timestamp.toISOString()}`);\n    }\n    console.log('');\n    \n    console.log('ALERTS:');\n    const unresolvedAlerts = this.alerts.filter(a => !a.resolved);\n    console.log(`  Total: ${this.alerts.length}`);\n    console.log(`  Unresolved: ${unresolvedAlerts.length}`);\n    if (unresolvedAlerts.length > 0) {\n      console.log('\\n  Recent unresolved alerts:');\n      unresolvedAlerts.slice(-3).forEach(alert => {\n        console.log(`    - ${alert.title} (${alert.timestamp.toISOString()})`);\n      });\n    }\n    \n    console.log('\\n' + 'â•'.repeat(39) + '\\n');\n  }\n}\n\n// Simulate production environment\nconsole.log('=== Simulating Production Environment ===\\n');\n\nconst monitor = new ProductionMonitor();\n\n// Health check\nmonitor.healthCheck();\n\n// Track some metrics\nconsole.log('Recording API metrics:\\n');\nmonitor.trackMetric('response_time', 45, 'ms');\nmonitor.trackMetric('response_time', 1200, 'ms');  // Slow!\nmonitor.trackMetric('response_time', 89, 'ms');\nmonitor.trackMetric('active_users', 1547, '');\nmonitor.trackMetric('database_queries', 234, '/min');\n\nconsole.log('');\n\n// Log some errors\ntry {\n  throw new Error('Database connection timeout');\n} catch (error) {\n  monitor.logError(error, {\n    userId: 'user_456',\n    endpoint: '/api/users',\n    severity: 'error'\n  });\n}\n\ntry {\n  throw new Error('Payment processing failed');\n} catch (error) {\n  monitor.logError(error, {\n    userId: 'user_789',\n    endpoint: '/api/checkout',\n    severity: 'critical'\n  });\n}\n\n// Another health check\nmonitor.healthCheck();\n\n// Generate comprehensive report\nmonitor.generateReport();\n\n// Best practices summary\nconsole.log('=== Production Best Practices Checklist ===\\n');\n\nconst checklist = [\n  'âœ… Health check endpoint implemented',\n  'âœ… Error tracking configured (Sentry)',\n  'âœ… Request logging enabled (Morgan)',\n  'âœ… Rate limiting active',\n  'âœ… Security headers added (Helmet)',\n  'âœ… HTTPS enforced',\n  'âœ… Database backups scheduled',\n  'âœ… Uptime monitoring set up',\n  'âœ… Performance metrics tracked',\n  'âœ… Graceful shutdown handling',\n  'âœ… Input validation on all endpoints',\n  'âœ… Environment variables secured',\n  'âœ… Dependencies up to date',\n  'âœ… Tests passing before deploy',\n  'âœ… Documentation complete'\n];\n\nchecklist.forEach(item => console.log(item));\n\nconsole.log('\\nðŸŽ‰ Production-ready application!\\n');",
      "commonStickingPoints": "Common production mistakes:\n\n1. **No error tracking**:\n   ```javascript\n   // WRONG! Errors disappear into the void\n   app.use((err, req, res, next) => {\n     console.log(err);  // Only logs to server console!\n     res.status(500).send('Error');\n   });\n   \n   // CORRECT! Track errors properly\n   import * as Sentry from '@sentry/node';\n   \n   Sentry.init({ dsn: process.env.SENTRY_DSN });\n   \n   app.use((err, req, res, next) => {\n     Sentry.captureException(err);  // Tracked forever!\n     res.status(500).json({ error: 'Internal error' });\n   });\n   ```\n\n2. **No health check endpoint**:\n   ```javascript\n   // Add this!\n   app.get('/health', async (req, res) => {\n     try {\n       await prisma.$queryRaw`SELECT 1`;  // Test DB\n       res.json({ status: 'healthy' });\n     } catch (error) {\n       res.status(503).json({ status: 'unhealthy' });\n     }\n   });\n   \n   // Configure Render to ping /health every 5 minutes\n   ```\n\n3. **Exposing detailed errors in production**:\n   ```javascript\n   // WRONG! Leaks sensitive info\n   res.status(500).json({ error: err.stack });  // âœ—\n   \n   // CORRECT! Hide details in production\n   if (process.env.NODE_ENV === 'production') {\n     res.status(500).json({ error: 'Internal server error' });\n   } else {\n     res.status(500).json({ error: err.message, stack: err.stack });\n   }\n   ```\n\n4. **No rate limiting**:\n   ```javascript\n   import rateLimit from 'express-rate-limit';\n   \n   const limiter = rateLimit({\n     windowMs: 15 * 60 * 1000,  // 15 min\n     max: 100  // Max 100 requests per IP\n   });\n   \n   app.use('/api/', limiter);\n   ```\n\n5. **Missing security headers**:\n   ```javascript\n   import helmet from 'helmet';\n   \n   app.use(helmet());  // Adds 11+ security headers!\n   ```\n\n6. **No input validation**:\n   ```javascript\n   // WRONG! Trust user input = disaster\n   app.post('/api/users', (req, res) => {\n     const user = req.body;  // Could be anything!\n     await prisma.user.create({ data: user });\n   });\n   \n   // CORRECT! Validate everything\n   import { z } from 'zod';\n   \n   const userSchema = z.object({\n     email: z.string().email(),\n     password: z.string().min(8)\n   });\n   \n   app.post('/api/users', (req, res) => {\n     const validData = userSchema.parse(req.body);\n     // Now safe to use\n   });\n   ```\n\n7. **No database backups**:\n   ```\n   Render dashboard:\n   1. Go to your database\n   2. Enable automatic backups\n   3. Set schedule (daily recommended)\n   4. Test restore process!\n   ```\n\n8. **No uptime monitoring**:\n   ```\n   Use free services:\n   - UptimeRobot (free, monitors every 5 min)\n   - Pingdom\n   - StatusCake\n   \n   Monitor:\n   - Main app URL\n   - /health endpoint\n   - Database\n   \n   Get alerts via:\n   - Email\n   - SMS\n   - Slack\n   ```\n\n9. **Deploying without testing**:\n   ```bash\n   # ALWAYS run before deploying:\n   npm test              # Run all tests\n   npm run build         # Test build\n   npm audit             # Check vulnerabilities\n   \n   # If any fail, FIX FIRST, then deploy!\n   ```\n\n10. **No graceful shutdown**:\n    ```javascript\n    const server = app.listen(PORT);\n    \n    process.on('SIGTERM', () => {\n      console.log('Shutting down gracefully...');\n      \n      server.close(() => {\n        prisma.$disconnect();\n        process.exit(0);\n      });\n    });\n    \n    // Prevents cutting off active requests during deploy\n    ```\n\n11. **Committing console.logs**:\n    ```javascript\n    // WRONG! Clutters production logs\n    console.log('User data:', user);  // âœ—\n    \n    // CORRECT! Use proper logging\n    import winston from 'winston';\n    \n    const logger = winston.createLogger({\n      level: process.env.LOG_LEVEL || 'info',\n      format: winston.format.json()\n    });\n    \n    logger.info('User created', { userId: user.id });\n    ```\n\n12. **No monitoring of slow queries**:\n    ```javascript\n    // Log slow database queries\n    const prisma = new PrismaClient({\n      log: [\n        { emit: 'event', level: 'query' }\n      ]\n    });\n    \n    prisma.$on('query', (e) => {\n      if (e.duration > 1000) {  // Slower than 1 second\n        console.warn(`SLOW QUERY: ${e.duration}ms - ${e.query}`);\n      }\n    });\n    ```"
    }
  ]
}
