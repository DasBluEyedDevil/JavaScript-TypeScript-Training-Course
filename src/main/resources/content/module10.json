{
  "id": "10",
  "title": "Module 10: Building for the Server - Node.js & Express",
  "description": "Learn how to build server-side applications with Node.js 24 and Express 5, handling HTTP requests, routing, and APIs",
  "goal": "Build RESTful APIs and server applications using modern Node.js and Express patterns",
  "lessons": [
    {
      "id": "10.1",
      "title": "What Is Node.js? (The Restaurant Kitchen Analogy)",
      "conceptAnalogy": "Imagine the difference between a food truck and a restaurant:\n\nFood Truck (Browser JavaScript):\n- Serves food directly to customers on the street\n- Limited space and equipment\n- Can't do heavy-duty cooking\n- Works in one location at a time\n\nRestaurant Kitchen (Node.js):\n- Behind the scenes, powerful equipment\n- Can handle many orders simultaneously\n- Access to storage, databases, file systems\n- Can coordinate multiple stations (services)\n- Sends finished dishes out to customers\n\nNode.js is JavaScript running on the server (the kitchen), not in the browser (the food truck). It can do things browser JavaScript can't: read files, connect to databases, handle thousands of requests, and much more!",
      "codeExample": "// Node.js 24 LTS 'Krypton' - Server-Side JavaScript (2025)\n\n// BUILT-IN MODULES - Node.js comes with powerful tools\n// (Note: These won't work in browser JavaScript!)\n\n// 1. FILE SYSTEM - Read and write files\n// const fs = require('fs');\n// In this demo, we'll simulate file operations\n\nlet simulatedFileContent = 'Hello from a file!';\nconsole.log('File content:', simulatedFileContent);\n\n// 2. PATH - Handle file paths across operating systems\nfunction joinPath(...parts) {\n  return parts.join('/');\n}\n\nlet filePath = joinPath('users', 'documents', 'notes.txt');\nconsole.log('File path:', filePath); // 'users/documents/notes.txt'\n\n// 3. HTTP - Create web servers\n// In Node.js, you can create a server with built-in modules:\n// const http = require('http');\n// const server = http.createServer((req, res) => {\n//   res.writeHead(200, { 'Content-Type': 'text/plain' });\n//   res.end('Hello from Node.js server!');\n// });\n// server.listen(3000);\n\nconsole.log('Node.js can create web servers!');\n\n// 4. PROCESS - Information about the running program\n// Node.js provides a global 'process' object\nlet nodeVersion = 'v24.11.0'; // Node.js 24 LTS\nlet platform = 'linux'; // Could be 'win32', 'darwin' (macOS), etc.\n\nconsole.log('Node.js version:', nodeVersion);\nconsole.log('Platform:', platform);\n\n// 5. ASYNCHRONOUS BY DEFAULT - Node.js is built for async\nfunction simulateFileRead(filename, callback) {\n  // In real Node.js: fs.readFile(filename, 'utf8', callback);\n  setTimeout(() => {\n    callback(null, `Contents of ${filename}`);\n  }, 100);\n}\n\nsimulatFileRead('data.txt', (error, data) => {\n  if (error) {\n    console.log('Error reading file:', error);\n  } else {\n    console.log('File data:', data);\n  }\n});\n\n// 6. NPM PACKAGES - Access to millions of libraries\n// Node.js uses npm (Node Package Manager)\n// You can install packages like:\n// npm install express\n// npm install mongoose\n// npm install axios\n\nconsole.log('Node.js has access to 2+ million npm packages!');\n\n// 7. COMMONJS vs ES MODULES (Node.js 24 supports both)\n// CommonJS (older style):\n// const express = require('express');\n\n// ES Modules (modern style, recommended):\n// import express from 'express';\n\n// Node.js 24 fully supports ES modules!\n\n// 8. NEW IN NODE.JS 24 - Explicit Resource Management\nclass DatabaseConnection {\n  constructor() {\n    console.log('Database connected');\n  }\n  \n  query(sql) {\n    console.log('Executing:', sql);\n    return { rows: [] };\n  }\n  \n  close() {\n    console.log('Database disconnected');\n  }\n}\n\n// Using keyword ensures cleanup (Node.js 24 feature)\nlet db = new DatabaseConnection();\ndb.query('SELECT * FROM users');\ndb.close(); // Always clean up resources!\n\nconsole.log('Node.js 24 supports explicit resource management!');",
      "syntaxBreakdown": "Understanding Node.js fundamentals:\n\n1. **Server-Side JavaScript**:\n   - JavaScript outside the browser\n   - Runs on your computer/server\n   - Has access to file system, network, etc.\n   - No DOM, no window object\n\n2. **Built-in Modules**:\n   - `fs`: File system operations\n   - `path`: File path utilities\n   - `http`: Create web servers\n   - `crypto`: Encryption and hashing\n   - `os`: Operating system information\n   - Import with: `import fs from 'fs'` (ES modules)\n\n3. **Global Objects** (available everywhere):\n   - `process`: Info about current Node.js process\n   - `__dirname`: Current directory path\n   - `__filename`: Current file path\n   - `console`: Same as browser console\n   - `setTimeout`, `setInterval`: Same as browser\n\n4. **NPM (Node Package Manager)**:\n   - Install packages: `npm install package-name`\n   - Save to dependencies: `npm install --save express`\n   - Dev dependencies: `npm install --save-dev typescript`\n   - package.json tracks all dependencies\n\n5. **Module Systems** (Node.js 24):\n   - CommonJS: `require()` and `module.exports`\n   - ES Modules: `import` and `export` (recommended)\n   - Use \"type\": \"module\" in package.json for ES modules\n\n6. **Async-First Design**:\n   - Most Node.js operations are asynchronous\n   - Use callbacks, Promises, or async/await\n   - Non-blocking I/O for high performance\n\n7. **Running Node.js Code**:\n   - Save file as `app.js`\n   - Run with: `node app.js`\n   - No browser needed!",
      "challenge": {
        "instructions": "Create a simple Node.js utility module:\n\n1. Create a function `getSystemInfo()` that returns an object with:\n   - `platform`: 'linux' (simulate process.platform)\n   - `nodeVersion`: 'v24.11.0'\n   - `uptime`: any number (simulate process.uptime())\n\n2. Create a function `readConfig(filename)` that:\n   - Takes a filename as a parameter\n   - Returns a Promise that resolves with simulated file content\n   - Use setTimeout to simulate async file reading\n\n3. Test both functions and log the results",
        "starterCode": "// System info function\nfunction getSystemInfo() {\n  return {\n    platform: 'linux',\n    nodeVersion: 'v24.11.0',\n    uptime: 12345\n  };\n}\n\n// Async file reading simulation\nfunction readConfig(filename) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(`Config from ${filename}`);\n    }, 100);\n  });\n}\n\n// Test the functions\nlet info = getSystemInfo();\nconsole.log('System:', info);\n\nreadConfig('app.config').then(data => {\n  console.log('Config:', data);\n});",
        "testCases": [
          {
            "description": "Should return system info",
            "input": "getSystemInfo().platform",
            "expectedOutput": "linux"
          },
          {
            "description": "Should read config asynchronously",
            "input": "readConfig('test.config').then(d => d)",
            "expectedOutput": "Config from test.config"
          }
        ],
        "hint": "Use new Promise((resolve, reject) => {...}) and setTimeout to simulate async operations."
      },
      "solution": "// Complete Node.js utility module\n\n// System info function\nfunction getSystemInfo() {\n  return {\n    platform: 'linux',\n    nodeVersion: 'v24.11.0',\n    uptime: 12345\n  };\n}\n\n// Async file reading simulation\nfunction readConfig(filename) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (!filename) {\n        reject(new Error('Filename is required'));\n      } else {\n        resolve(`Config from ${filename}`);\n      }\n    }, 100);\n  });\n}\n\n// Test the functions\nlet info = getSystemInfo();\nconsole.log('System info:', info);\nconsole.log('Platform:', info.platform);       // linux\nconsole.log('Node version:', info.nodeVersion); // v24.11.0\n\n// Test async config reading\nreadConfig('app.config').then(data => {\n  console.log('Config loaded:', data); // Config from app.config\n}).catch(error => {\n  console.log('Error:', error.message);\n});\n\n// Using async/await (modern pattern)\nasync function loadSystemConfig() {\n  try {\n    let config = await readConfig('database.config');\n    console.log('Database config:', config);\n  } catch (error) {\n    console.log('Failed to load config:', error.message);\n  }\n}\n\nloadSystemConfig();",
      "commonStickingPoints": "Common Node.js beginner mistakes:\n\n1. **Trying to use browser APIs**:\n   ```javascript\n   // ERROR in Node.js - no DOM!\n   document.getElementById('app'); // ReferenceError: document is not defined\n   window.location.href;           // ReferenceError: window is not defined\n   ```\n   Solution: Node.js is for servers, not browsers\n\n2. **Forgetting Node.js is async**:\n   ```javascript\n   // Wrong - file might not be read yet\n   let data;\n   fs.readFile('file.txt', (err, content) => {\n     data = content;\n   });\n   console.log(data); // undefined!\n   ```\n   Solution: Use callbacks, Promises, or async/await\n\n3. **Module confusion**: `require()` vs `import`\n   - Old style: `const fs = require('fs')`\n   - New style: `import fs from 'fs'` (need \"type\": \"module\" in package.json)\n   - Can't mix both in the same file!\n\n4. **Not handling errors**:\n   ```javascript\n   // Dangerous - no error handling\n   fs.readFile('file.txt', (err, data) => {\n     console.log(data.toString()); // Crashes if file doesn't exist!\n   });\n   ```\n   Solution: Always check for errors first\n\n5. **Wrong file paths**:\n   - Use `path.join()` for cross-platform compatibility\n   - Use `__dirname` for absolute paths\n   - Don't hardcode paths like `C:\\Users\\...`\n\n6. **Not installing dependencies**:\n   - `npm install` before running the app\n   - Check package.json for required packages\n   - Use .gitignore for node_modules/\n\n7. **Running browser code in Node.js**:\n   - Node.js and browser JavaScript are different environments\n   - Some code works in both, some doesn't\n   - Use bundlers (webpack, vite) for browser code"
    },
    {
      "id": "10.2",
      "title": "Your First Express Server (The Restaurant Manager Analogy)",
      "conceptAnalogy": "Imagine running a restaurant:\n\nWithout a manager (plain Node.js HTTP):\n- You handle every customer request manually\n- You write the same instructions over and over\n- You manage reservations, orders, payments all yourself\n- Lots of repetitive work\n\nWith a manager (Express framework):\n- The manager handles common tasks automatically\n- Organized system for taking orders (routes)\n- Standardized way to serve dishes (responses)\n- Easy to add new menu items (endpoints)\n- Less work, more organized!\n\nExpress is like a restaurant manager for your Node.js server. It handles the repetitive stuff so you can focus on your unique features!",
      "codeExample": "// Express 5.1 - Modern Web Framework (2025)\n// Note: This is simulated Express code for learning\n\n// BASIC EXPRESS SERVER STRUCTURE\n\n// Step 1: Import Express (in real Node.js)\n// import express from 'express';\n\n// Step 2: Create an Express application\n// const app = express();\n\n// For this demo, we'll simulate Express behavior:\nclass ExpressApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n    console.log(`Route registered: GET ${path}`);\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n    console.log(`Route registered: POST ${path}`);\n  }\n  \n  listen(port, callback) {\n    console.log(`Server listening on port ${port}`);\n    if (callback) callback();\n  }\n  \n  simulateRequest(method, path) {\n    let route = this.routes.find(r => r.method === method && r.path === path);\n    if (route) {\n      let req = { method, path, query: {}, params: {}, body: {} };\n      let res = {\n        status: function(code) {\n          this.statusCode = code;\n          return this;\n        },\n        json: function(data) {\n          console.log(`Response [${this.statusCode || 200}]:`, JSON.stringify(data));\n        },\n        send: function(data) {\n          console.log(`Response [${this.statusCode || 200}]:`, data);\n        }\n      };\n      route.handler(req, res);\n    } else {\n      console.log(`404 Not Found: ${method} ${path}`);\n    }\n  }\n}\n\nlet app = new ExpressApp();\n\n// ROUTE DEFINITIONS\n\n// 1. Simple GET route - Homepage\napp.get('/', (req, res) => {\n  res.send('Welcome to Express 5.1!');\n});\n\n// 2. GET route with response data\napp.get('/api/status', (req, res) => {\n  res.json({\n    status: 'online',\n    version: '1.0.0',\n    timestamp: Date.now()\n  });\n});\n\n// 3. GET route - List of users\napp.get('/api/users', (req, res) => {\n  let users = [\n    { id: 1, name: 'Alice', email: 'alice@example.com' },\n    { id: 2, name: 'Bob', email: 'bob@example.com' }\n  ];\n  res.json(users);\n});\n\n// 4. POST route - Create new user\napp.post('/api/users', (req, res) => {\n  // In real Express: let newUser = req.body;\n  let newUser = { id: 3, name: 'Charlie', email: 'charlie@example.com' };\n  \n  res.status(201).json({\n    message: 'User created successfully',\n    user: newUser\n  });\n});\n\n// 5. Error handling route\napp.get('/api/error', (req, res) => {\n  res.status(500).json({\n    error: 'Something went wrong!',\n    message: 'Internal server error'\n  });\n});\n\n// Start the server\napp.listen(3000, () => {\n  console.log('Express server is ready!');\n});\n\n// SIMULATE REQUESTS (to demonstrate the routes)\nconsole.log('\\n--- Simulating HTTP Requests ---\\n');\n\napp.simulateRequest('GET', '/');\napp.simulateRequest('GET', '/api/status');\napp.simulateRequest('GET', '/api/users');\napp.simulateRequest('POST', '/api/users');\napp.simulateRequest('GET', '/api/error');\napp.simulateRequest('GET', '/api/notfound');",
      "syntaxBreakdown": "Understanding Express fundamentals:\n\n1. **Creating an Express App**:\n   ```javascript\n   import express from 'express';\n   const app = express();\n   ```\n   - `express()` creates a new application\n   - `app` is your main server object\n\n2. **Route Methods** (HTTP verbs):\n   - `app.get()` - Read data\n   - `app.post()` - Create data\n   - `app.put()` - Update data (replace)\n   - `app.patch()` - Update data (partial)\n   - `app.delete()` - Delete data\n\n3. **Route Structure**: `app.get(path, handler)`\n   - Path: URL pattern (`'/'`, `'/api/users'`)\n   - Handler: Function that runs when route is accessed\n   - Handler gets `req` (request) and `res` (response)\n\n4. **Request Object (req)**:\n   - `req.params` - URL parameters (`/users/:id`)\n   - `req.query` - Query strings (`?search=hello`)\n   - `req.body` - POST/PUT data\n   - `req.headers` - HTTP headers\n\n5. **Response Object (res)**:\n   - `res.send()` - Send text/HTML\n   - `res.json()` - Send JSON data\n   - `res.status()` - Set status code (200, 404, 500, etc.)\n   - `res.sendFile()` - Send a file\n\n6. **Status Codes**:\n   - 200: OK (success)\n   - 201: Created (new resource)\n   - 400: Bad Request (client error)\n   - 404: Not Found\n   - 500: Internal Server Error\n\n7. **Starting the Server**:\n   ```javascript\n   app.listen(3000, () => {\n     console.log('Server running on port 3000');\n   });\n   ```\n   - Port 3000 is common for development\n   - Callback runs when server starts\n   - Server keeps running until you stop it (Ctrl+C)",
      "challenge": {
        "instructions": "Create a simple API for a todo list:\n\n1. Create a GET route `/api/todos` that returns an array of todo objects\n   - Each todo should have: id, task, completed\n\n2. Create a POST route `/api/todos` that:\n   - Simulates creating a new todo\n   - Returns status 201 and the new todo\n\n3. Create a GET route `/api/todos/completed` that:\n   - Returns only completed todos\n\nUse the ExpressApp class from the example. Simulate requests to test your routes.",
        "starterCode": "// Express app simulation\nclass ExpressApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n  }\n  \n  simulateRequest(method, path) {\n    let route = this.routes.find(r => r.method === method && r.path === path);\n    if (route) {\n      let req = { method, path };\n      let res = {\n        status: function(code) { this.statusCode = code; return this; },\n        json: function(data) { console.log(`[${this.statusCode || 200}]`, JSON.stringify(data)); }\n      };\n      route.handler(req, res);\n    }\n  }\n}\n\nlet app = new ExpressApp();\n\n// Sample todo data\nlet todos = [\n  { id: 1, task: 'Learn Express', completed: false },\n  { id: 2, task: 'Build an API', completed: true }\n];\n\n// TODO: Add your routes here\n\n// Test your routes\napp.simulateRequest('GET', '/api/todos');\napp.simulateRequest('POST', '/api/todos');\napp.simulateRequest('GET', '/api/todos/completed');",
        "testCases": [
          {
            "description": "Should return all todos",
            "input": "let todos = [{ id: 1, task: 'Test', completed: false }]; todos.length",
            "expectedOutput": "1"
          },
          {
            "description": "Should filter completed todos",
            "input": "let todos = [{ id: 1, task: 'A', completed: true }, { id: 2, task: 'B', completed: false }]; todos.filter(t => t.completed).length",
            "expectedOutput": "1"
          }
        ],
        "hint": "Use app.get() and app.post(). For filtering, use todos.filter(t => t.completed)."
      },
      "solution": "// Express app simulation\nclass ExpressApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n  }\n  \n  simulateRequest(method, path) {\n    let route = this.routes.find(r => r.method === method && r.path === path);\n    if (route) {\n      let req = { method, path };\n      let res = {\n        status: function(code) { this.statusCode = code; return this; },\n        json: function(data) { console.log(`[${this.statusCode || 200}]`, JSON.stringify(data)); }\n      };\n      route.handler(req, res);\n    }\n  }\n}\n\nlet app = new ExpressApp();\n\n// Sample todo data\nlet todos = [\n  { id: 1, task: 'Learn Express', completed: false },\n  { id: 2, task: 'Build an API', completed: true },\n  { id: 3, task: 'Deploy app', completed: true }\n];\n\n// Route 1: Get all todos\napp.get('/api/todos', (req, res) => {\n  res.json(todos);\n});\n\n// Route 2: Create new todo\napp.post('/api/todos', (req, res) => {\n  let newTodo = {\n    id: todos.length + 1,\n    task: 'New task',\n    completed: false\n  };\n  todos.push(newTodo);\n  \n  res.status(201).json({\n    message: 'Todo created',\n    todo: newTodo\n  });\n});\n\n// Route 3: Get completed todos only\napp.get('/api/todos/completed', (req, res) => {\n  let completedTodos = todos.filter(t => t.completed);\n  res.json(completedTodos);\n});\n\n// Test the routes\nconsole.log('All todos:');\napp.simulateRequest('GET', '/api/todos');\n\nconsole.log('\\nCreate todo:');\napp.simulateRequest('POST', '/api/todos');\n\nconsole.log('\\nCompleted todos:');\napp.simulateRequest('GET', '/api/todos/completed');",
      "commonStickingPoints": "Common Express mistakes:\n\n1. **Forgetting to call res.send() or res.json()**:\n   ```javascript\n   app.get('/api/users', (req, res) => {\n     let users = getUsers();\n     // Missing res.json(users)! Request will hang\n   });\n   ```\n   Solution: Always send a response!\n\n2. **Sending multiple responses**:\n   ```javascript\n   app.get('/api/data', (req, res) => {\n     res.json({ data: 'first' });\n     res.json({ data: 'second' }); // ERROR: Can't send twice!\n   });\n   ```\n   Solution: Only call res.send/json once per request\n\n3. **Route order matters**:\n   ```javascript\n   app.get('/api/users/active', ...);  // Must come first\n   app.get('/api/users/:id', ...);     // This would match /api/users/active too!\n   ```\n   Solution: Put specific routes before parameterized routes\n\n4. **Not parsing request body**:\n   ```javascript\n   // Need middleware to parse JSON\n   app.use(express.json()); // Add this line!\n   \n   app.post('/api/users', (req, res) => {\n     console.log(req.body); // Now this works\n   });\n   ```\n\n5. **Wrong port (already in use)**:\n   - Error: \"EADDRINUSE: Port 3000 already in use\"\n   - Solution: Use a different port or kill the other process\n\n6. **Not handling errors**:\n   ```javascript\n   app.get('/api/users/:id', (req, res) => {\n     let user = findUser(req.params.id);\n     if (!user) {\n       return res.status(404).json({ error: 'User not found' });\n     }\n     res.json(user);\n   });\n   ```\n   Always check if data exists before sending!\n\n7. **Mixing up req.params, req.query, and req.body**:\n   - `req.params`: URL parameters (`/users/:id`)\n   - `req.query`: Query strings (`?search=hello`)\n   - `req.body`: POST/PUT request data"
    },
    {
      "id": "10.3",
      "title": "Routing and Parameters (The Address System Analogy)",
      "conceptAnalogy": "Imagine delivering packages in a city:\n\nSimple addresses (static routes):\n- 123 Main Street (exact address)\n- City Hall (exact location)\n- Central Park (exact destination)\n\nDynamic addresses (parameterized routes):\n- \"Apartment {number} on Floor {floor}\" → Many apartments, one pattern\n- \"House number {X} on {Street Name}\" → Any house, flexible pattern\n- \"Locker {number} at Gym\" → Dynamic, but follows a pattern\n\nExpress routing works the same way:\n- Static routes: `/about`, `/contact` (exact paths)\n- Dynamic routes: `/users/:id`, `/products/:category/:item` (pattern-based)\n\nParameters let you create one route that handles many similar requests!",
      "codeExample": "// Express 5.1 - Advanced Routing (2025)\n\n// Simulated Express with routing features\nclass ExpressApp {\n  constructor() {\n    this.routes = [];\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  simulateRequest(method, url) {\n    console.log(`\\n${method} ${url}`);\n    \n    for (let route of this.routes) {\n      if (route.method !== method) continue;\n      \n      let params = this.matchRoute(route.path, url);\n      if (params !== null) {\n        let [path, queryString] = url.split('?');\n        let query = this.parseQuery(queryString);\n        \n        let req = { method, url, params, query };\n        let res = {\n          json: (data) => console.log('Response:', JSON.stringify(data)),\n          status: function(code) { this.statusCode = code; return this; }\n        };\n        \n        route.handler(req, res);\n        return;\n      }\n    }\n    \n    console.log('404 Not Found');\n  }\n  \n  matchRoute(pattern, url) {\n    let [urlPath] = url.split('?');\n    let patternParts = pattern.split('/');\n    let urlParts = urlPath.split('/');\n    \n    if (patternParts.length !== urlParts.length) return null;\n    \n    let params = {};\n    for (let i = 0; i < patternParts.length; i++) {\n      if (patternParts[i].startsWith(':')) {\n        let paramName = patternParts[i].slice(1);\n        params[paramName] = urlParts[i];\n      } else if (patternParts[i] !== urlParts[i]) {\n        return null;\n      }\n    }\n    return params;\n  }\n  \n  parseQuery(queryString) {\n    if (!queryString) return {};\n    let query = {};\n    queryString.split('&').forEach(pair => {\n      let [key, value] = pair.split('=');\n      query[key] = value;\n    });\n    return query;\n  }\n}\n\nlet app = new ExpressApp();\n\n// ROUTE PARAMETERS (Dynamic segments in URL)\n\n// 1. Single parameter - Get user by ID\napp.get('/api/users/:id', (req, res) => {\n  let userId = req.params.id;\n  \n  // Simulate database lookup\n  let user = {\n    id: userId,\n    name: 'Alice',\n    email: 'alice@example.com'\n  };\n  \n  res.json(user);\n});\n\n// 2. Multiple parameters - Get specific product\napp.get('/api/products/:category/:productId', (req, res) => {\n  let { category, productId } = req.params;\n  \n  res.json({\n    category: category,\n    productId: productId,\n    name: 'Sample Product',\n    price: 29.99\n  });\n});\n\n// 3. Query parameters - Search and filter\napp.get('/api/search', (req, res) => {\n  // Access with req.query\n  let { q, category, minPrice, maxPrice } = req.query;\n  \n  res.json({\n    searchTerm: q || 'none',\n    category: category || 'all',\n    priceRange: {\n      min: minPrice || 0,\n      max: maxPrice || 'unlimited'\n    },\n    results: [\n      { id: 1, name: 'Product A' },\n      { id: 2, name: 'Product B' }\n    ]\n  });\n});\n\n// 4. Combining params and query\napp.get('/api/categories/:category/products', (req, res) => {\n  let category = req.params.category;\n  let { sort, limit } = req.query;\n  \n  res.json({\n    category: category,\n    sortBy: sort || 'name',\n    limit: limit || 10,\n    products: ['Product 1', 'Product 2']\n  });\n});\n\n// TEST THE ROUTES\n\n// Parameter examples\napp.simulateRequest('GET', '/api/users/42');\napp.simulateRequest('GET', '/api/users/999');\n\napp.simulateRequest('GET', '/api/products/electronics/laptop-123');\napp.simulateRequest('GET', '/api/products/books/novel-456');\n\n// Query parameter examples  \napp.simulateRequest('GET', '/api/search?q=laptop&category=electronics&minPrice=500&maxPrice=2000');\napp.simulateRequest('GET', '/api/search?q=headphones');\n\n// Combined params and query\napp.simulateRequest('GET', '/api/categories/electronics/products?sort=price&limit=20');\napp.simulateRequest('GET', '/api/categories/books/products');",
      "syntaxBreakdown": "Understanding Express routing:\n\n1. **Route Parameters** (`:paramName`):\n   ```javascript\n   app.get('/users/:id', (req, res) => {\n     let id = req.params.id;  // Extract from URL\n   });\n   ```\n   - Colon `:` marks a parameter\n   - Matches any value in that position\n   - `/users/42` → `req.params.id = '42'`\n   - `/users/alice` → `req.params.id = 'alice'`\n\n2. **Multiple Parameters**:\n   ```javascript\n   app.get('/posts/:year/:month/:day', (req, res) => {\n     let { year, month, day } = req.params;\n     // /posts/2025/01/15 → year=2025, month=01, day=15\n   });\n   ```\n\n3. **Query Parameters** (after `?`):\n   ```javascript\n   // URL: /search?q=express&page=2\n   app.get('/search', (req, res) => {\n     let searchTerm = req.query.q;     // 'express'\n     let page = req.query.page;        // '2'\n   });\n   ```\n   - Not part of the route pattern\n   - Optional by default\n   - Multiple values: `?key1=value1&key2=value2`\n\n4. **Parameter vs Query - When to Use**:\n   - **Route parameters** (`:id`):\n     * Required parts of the URL\n     * Identifying resources\n     * `/users/:userId/posts/:postId`\n   \n   - **Query parameters** (`?key=value`):\n     * Optional filters\n     * Search terms\n     * Pagination, sorting\n     * `/products?category=books&sort=price&page=2`\n\n5. **Accessing Parameters**:\n   - `req.params` → Object with route parameters\n   - `req.query` → Object with query parameters\n   - `req.body` → Object with POST/PUT data (needs middleware)\n\n6. **Type Conversion**:\n   ```javascript\n   app.get('/api/users/:id', (req, res) => {\n     // req.params.id is always a STRING\n     let userId = parseInt(req.params.id);  // Convert to number\n     let page = parseInt(req.query.page) || 1; // Default to 1\n   });\n   ```\n   All parameters come as strings - convert as needed!",
      "challenge": {
        "instructions": "Create a blog API with routing:\n\n1. GET `/api/posts/:postId` - Get a specific post by ID\n   - Return object with: postId, title, content\n\n2. GET `/api/authors/:authorId/posts` - Get all posts by an author\n   - Return array of posts with authorId in each\n\n3. GET `/api/posts` with query parameters - Search posts\n   - Support: `?search=keyword&category=tech&limit=10`\n   - Return search parameters and mock results\n\nUse the ExpressApp class. Test all routes with simulated requests.",
        "starterCode": "class ExpressApp {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  simulateRequest(method, url) {\n    console.log(`\\n${method} ${url}`);\n    for (let route of this.routes) {\n      if (route.method !== method) continue;\n      let params = this.matchRoute(route.path, url);\n      if (params !== null) {\n        let [path, queryString] = url.split('?');\n        let query = this.parseQuery(queryString);\n        let req = { params, query };\n        let res = { json: (d) => console.log(JSON.stringify(d)) };\n        route.handler(req, res);\n        return;\n      }\n    }\n  }\n  matchRoute(pattern, url) {\n    let [urlPath] = url.split('?');\n    let patternParts = pattern.split('/');\n    let urlParts = urlPath.split('/');\n    if (patternParts.length !== urlParts.length) return null;\n    let params = {};\n    for (let i = 0; i < patternParts.length; i++) {\n      if (patternParts[i].startsWith(':')) {\n        params[patternParts[i].slice(1)] = urlParts[i];\n      } else if (patternParts[i] !== urlParts[i]) return null;\n    }\n    return params;\n  }\n  parseQuery(qs) {\n    if (!qs) return {};\n    let q = {};\n    qs.split('&').forEach(p => { let [k,v] = p.split('='); q[k] = v; });\n    return q;\n  }\n}\n\nlet app = new ExpressApp();\n\n// TODO: Add your routes here\n\n// Test routes\napp.simulateRequest('GET', '/api/posts/123');\napp.simulateRequest('GET', '/api/authors/42/posts');\napp.simulateRequest('GET', '/api/posts?search=express&category=tech&limit=5');",
        "testCases": [
          {
            "description": "Should extract post ID from params",
            "input": "let params = { postId: '123' }; params.postId",
            "expectedOutput": "123"
          },
          {
            "description": "Should parse query parameters",
            "input": "let query = { search: 'test', limit: '10' }; query.limit",
            "expectedOutput": "10"
          }
        ],
        "hint": "Use req.params for :postId and :authorId. Use req.query for search parameters."
      },
      "solution": "class ExpressApp {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  simulateRequest(method, url) {\n    console.log(`\\n${method} ${url}`);\n    for (let route of this.routes) {\n      if (route.method !== method) continue;\n      let params = this.matchRoute(route.path, url);\n      if (params !== null) {\n        let [path, queryString] = url.split('?');\n        let query = this.parseQuery(queryString);\n        let req = { params, query };\n        let res = { json: (d) => console.log(JSON.stringify(d, null, 2)) };\n        route.handler(req, res);\n        return;\n      }\n    }\n    console.log('404 Not Found');\n  }\n  matchRoute(pattern, url) {\n    let [urlPath] = url.split('?');\n    let patternParts = pattern.split('/');\n    let urlParts = urlPath.split('/');\n    if (patternParts.length !== urlParts.length) return null;\n    let params = {};\n    for (let i = 0; i < patternParts.length; i++) {\n      if (patternParts[i].startsWith(':')) {\n        params[patternParts[i].slice(1)] = urlParts[i];\n      } else if (patternParts[i] !== urlParts[i]) return null;\n    }\n    return params;\n  }\n  parseQuery(qs) {\n    if (!qs) return {};\n    let q = {};\n    qs.split('&').forEach(p => { let [k,v] = p.split('='); q[k] = v; });\n    return q;\n  }\n}\n\nlet app = new ExpressApp();\n\n// Route 1: Get specific post\napp.get('/api/posts/:postId', (req, res) => {\n  let { postId } = req.params;\n  \n  res.json({\n    postId: postId,\n    title: `Post ${postId} Title`,\n    content: 'This is the post content...',\n    author: 'Alice'\n  });\n});\n\n// Route 2: Get posts by author\napp.get('/api/authors/:authorId/posts', (req, res) => {\n  let { authorId } = req.params;\n  \n  res.json({\n    authorId: authorId,\n    posts: [\n      { id: 1, title: 'First Post', content: 'Content 1' },\n      { id: 2, title: 'Second Post', content: 'Content 2' }\n    ]\n  });\n});\n\n// Route 3: Search posts with query parameters\napp.get('/api/posts', (req, res) => {\n  let { search, category, limit } = req.query;\n  \n  res.json({\n    search: search || 'all',\n    category: category || 'all',\n    limit: limit || '10',\n    results: [\n      { id: 1, title: 'Express Tutorial', category: 'tech' },\n      { id: 2, title: 'Node.js Guide', category: 'tech' }\n    ]\n  });\n});\n\n// Test all routes\napp.simulateRequest('GET', '/api/posts/123');\napp.simulateRequest('GET', '/api/authors/42/posts');\napp.simulateRequest('GET', '/api/posts?search=express&category=tech&limit=5');\napp.simulateRequest('GET', '/api/posts');",
      "commonStickingPoints": "Common routing mistakes:\n\n1. **Parameter type confusion**:\n   ```javascript\n   app.get('/users/:id', (req, res) => {\n     if (req.params.id > 100) {  // String comparison! '9' > '100' is true!\n       // Wrong!\n     }\n     \n     // Correct:\n     if (parseInt(req.params.id) > 100) {\n       // Right!\n     }\n   });\n   ```\n   Remember: ALL params and query values are strings!\n\n2. **Route order conflicts**:\n   ```javascript\n   // Wrong order!\n   app.get('/users/:id', ...);        // This matches EVERYTHING\n   app.get('/users/active', ...);     // Never reached!\n   \n   // Correct order:\n   app.get('/users/active', ...);     // Specific route first\n   app.get('/users/:id', ...);        // Generic route last\n   ```\n\n3. **Missing query parameters**:\n   ```javascript\n   app.get('/search', (req, res) => {\n     let limit = req.query.limit;  // undefined if not provided!\n     \n     // Better:\n     let limit = req.query.limit || 10;  // Default value\n     let limit = parseInt(req.query.limit) || 10;  // With parsing\n   });\n   ```\n\n4. **Confusing params, query, and body**:\n   - URL: `/api/users/42?active=true`\n   - `req.params.id` → '42' (from `:id`)\n   - `req.query.active` → 'true' (from `?active=true`)\n   - `req.body` → POST/PUT data (not in GET requests)\n\n5. **Complex parameter patterns**:\n   ```javascript\n   // This works but is confusing:\n   app.get('/api/:version/:resource/:id/:action', ...);\n   \n   // Better - use query params for optional stuff:\n   app.get('/api/v1/users/:id', ...);\n   ```\n   Keep route patterns simple and predictable!\n\n6. **Forgetting URL encoding**:\n   - Query values may contain special characters\n   - `?search=hello world` → Spaces become `%20`\n   - Express automatically decodes for you\n   - Use `encodeURIComponent()` when building URLs"
    },
    {
      "id": "10.4",
      "title": "Middleware (The Assembly Line Analogy)",
      "conceptAnalogy": "Imagine a factory assembly line:\n\nWithout assembly line (no middleware):\n- One worker does EVERYTHING for each product\n- Unwrap materials, assemble, test, package, label\n- Repetitive, inefficient, error-prone\n\nWith assembly line (middleware):\n- Station 1: Unwrap and inspect materials (authentication)\n- Station 2: Assemble parts (body parsing)\n- Station 3: Quality check (validation)\n- Station 4: Package product (route handler)\n- Station 5: Add label (response formatting)\n\nEach station does one job, passes to the next!\n\nExpress middleware works the same way:\n- Request comes in\n- Passes through middleware functions in order\n- Each middleware does one specific task\n- Finally reaches your route handler\n- Response goes back to client\n\nMiddleware = functions that process requests before they reach your routes!",
      "codeExample": "// Express 5.1 - Middleware (2025)\n\n// Simulated Express with middleware support\nclass ExpressApp {\n  constructor() {\n    this.routes = [];\n    this.middleware = [];\n  }\n  \n  use(handler) {\n    this.middleware.push(handler);\n    console.log('Middleware registered');\n  }\n  \n  get(path, handler) {\n    this.routes.push({ method: 'GET', path, handler });\n  }\n  \n  post(path, handler) {\n    this.routes.push({ method: 'POST', path, handler });\n  }\n  \n  simulateRequest(method, path, body = null) {\n    console.log(`\\n--- ${method} ${path} ---`);\n    \n    let req = { \n      method, \n      path, \n      body: body,\n      headers: { 'user-agent': 'Test Client' },\n      timestamp: Date.now()\n    };\n    \n    let res = {\n      statusCode: 200,\n      headers: {},\n      sent: false,\n      json: function(data) {\n        if (this.sent) {\n          console.log('ERROR: Response already sent!');\n          return;\n        }\n        this.sent = true;\n        console.log(`Response [${this.statusCode}]:`, JSON.stringify(data));\n      },\n      status: function(code) {\n        this.statusCode = code;\n        return this;\n      },\n      setHeader: function(key, value) {\n        this.headers[key] = value;\n      }\n    };\n    \n    // Run middleware chain\n    let middlewareIndex = 0;\n    \n    let next = () => {\n      if (middlewareIndex < this.middleware.length) {\n        let currentMiddleware = this.middleware[middlewareIndex++];\n        currentMiddleware(req, res, next);\n      } else {\n        // Middleware done, find and run route handler\n        let route = this.routes.find(r => r.method === method && r.path === path);\n        if (route) {\n          route.handler(req, res);\n        } else {\n          res.status(404).json({ error: 'Not found' });\n        }\n      }\n    };\n    \n    next(); // Start middleware chain\n  }\n}\n\nlet app = new ExpressApp();\n\n// MIDDLEWARE EXAMPLES\n\n// 1. Logging Middleware - Runs on EVERY request\napp.use((req, res, next) => {\n  console.log(`[LOG] ${req.method} ${req.path} at ${new Date(req.timestamp).toISOString()}`);\n  next(); // MUST call next() to continue!\n});\n\n// 2. Request Timing Middleware\napp.use((req, res, next) => {\n  req.startTime = Date.now();\n  \n  // Wrap res.json to add timing\n  let originalJson = res.json;\n  res.json = function(data) {\n    let duration = Date.now() - req.startTime;\n    console.log(`[TIMING] Request took ${duration}ms`);\n    originalJson.call(this, data);\n  };\n  \n  next();\n});\n\n// 3. Authentication Middleware\napp.use((req, res, next) => {\n  // Simulate checking auth token\n  let token = req.headers['authorization'] || 'valid-token';\n  \n  if (token === 'valid-token') {\n    req.user = { id: 1, name: 'Alice', role: 'admin' };\n    console.log('[AUTH] User authenticated:', req.user.name);\n    next();\n  } else {\n    console.log('[AUTH] Invalid token!');\n    res.status(401).json({ error: 'Unauthorized' });\n    // Note: No next() call - request stops here!\n  }\n});\n\n// 4. Request Body Parser Middleware (simulated)\napp.use((req, res, next) => {\n  if (req.method === 'POST' && req.body) {\n    // In real Express: express.json() does this\n    console.log('[PARSER] Parsing JSON body');\n    // req.body is already parsed in our simulation\n  }\n  next();\n});\n\n// ROUTES (run AFTER middleware)\n\napp.get('/api/public', (req, res) => {\n  res.json({ \n    message: 'Public endpoint',\n    user: req.user ? req.user.name : 'anonymous'\n  });\n});\n\napp.get('/api/protected', (req, res) => {\n  // req.user added by auth middleware\n  res.json({ \n    message: 'Protected data',\n    user: req.user.name,\n    role: req.user.role\n  });\n});\n\napp.post('/api/data', (req, res) => {\n  res.json({ \n    message: 'Data received',\n    data: req.body,\n    processedBy: req.user.name\n  });\n});\n\n// TEST MIDDLEWARE CHAIN\n\napp.simulateRequest('GET', '/api/public');\napp.simulateRequest('GET', '/api/protected');\napp.simulateRequest('POST', '/api/data', { title: 'Test', value: 42 });",
      "syntaxBreakdown": "Understanding Express middleware:\n\n1. **Middleware Signature**: `(req, res, next) => { ... }`\n   - `req`: Request object (incoming data)\n   - `res`: Response object (sending data back)\n   - `next`: Function to call the next middleware\n   - MUST call `next()` to continue the chain!\n\n2. **Registering Middleware**: `app.use(middlewareFunction)`\n   - Runs on EVERY request\n   - Order matters - middleware runs in the order you add it\n   - Place before routes\n\n3. **Middleware Flow**:\n   ```\n   Request → Middleware 1 → Middleware 2 → Middleware 3 → Route Handler → Response\n   ```\n   Each middleware calls `next()` to pass control\n\n4. **Common Built-in Middleware**:\n   ```javascript\n   // Parse JSON request bodies\n   app.use(express.json());\n   \n   // Parse URL-encoded forms\n   app.use(express.urlencoded({ extended: true }));\n   \n   // Serve static files (HTML, CSS, images)\n   app.use(express.static('public'));\n   ```\n\n5. **Stopping the Chain**:\n   ```javascript\n   app.use((req, res, next) => {\n     if (!isAuthorized(req)) {\n       res.status(401).json({ error: 'Unauthorized' });\n       // No next() - request stops here!\n       return;\n     }\n     next(); // Continue to next middleware\n   });\n   ```\n\n6. **Route-Specific Middleware**:\n   ```javascript\n   // Only runs for this route\n   app.get('/admin', authMiddleware, (req, res) => {\n     res.json({ message: 'Admin panel' });\n   });\n   ```\n\n7. **Error Handling Middleware** (4 parameters):\n   ```javascript\n   app.use((err, req, res, next) => {\n     console.error(err);\n     res.status(500).json({ error: 'Something went wrong' });\n   });\n   ```\n   Must have 4 parameters and go at the end!\n\n8. **Middleware Use Cases**:\n   - Authentication/Authorization\n   - Logging requests\n   - Parsing request bodies\n   - CORS handling\n   - Rate limiting\n   - Compression\n   - Session management",
      "challenge": {
        "instructions": "Create a middleware system for a blog API:\n\n1. Create a logging middleware that logs the method and path\n2. Create a validation middleware that:\n   - For POST requests, checks if req.body has a 'title' property\n   - If missing, return 400 error and stop the chain\n   - If present, call next()\n3. Create a route POST `/api/posts` that:\n   - Returns the post data with a generated ID\n4. Register middleware in the correct order\n5. Test with valid and invalid requests\n\nUse the ExpressApp class provided.",
        "starterCode": "class ExpressApp {\n  constructor() { this.routes = []; this.middleware = []; }\n  use(handler) { this.middleware.push(handler); }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  simulateRequest(method, path, body) {\n    console.log(`\\n${method} ${path}`);\n    let req = { method, path, body };\n    let res = {\n      json: function(d) { console.log('Response:', JSON.stringify(d)); },\n      status: function(c) { this.statusCode = c; return this; }\n    };\n    let i = 0;\n    let next = () => {\n      if (i < this.middleware.length) {\n        this.middleware[i++](req, res, next);\n      } else {\n        let route = this.routes.find(r => r.method === method && r.path === path);\n        if (route) route.handler(req, res);\n      }\n    };\n    next();\n  }\n}\n\nlet app = new ExpressApp();\n\n// TODO: Add logging middleware\n\n// TODO: Add validation middleware\n\n// TODO: Add POST route\n\n// Test\napp.simulateRequest('POST', '/api/posts', { title: 'My Post', content: 'Hello' });\napp.simulateRequest('POST', '/api/posts', { content: 'No title!' });",
        "testCases": [
          {
            "description": "Should validate title exists",
            "input": "let body = { title: 'Test' }; body.title ? true : false",
            "expectedOutput": "true"
          },
          {
            "description": "Should detect missing title",
            "input": "let body = { content: 'Test' }; body.title ? true : false",
            "expectedOutput": "false"
          }
        ],
        "hint": "In validation middleware, check if (!req.body.title) and return error without calling next(). Otherwise, call next()."
      },
      "solution": "class ExpressApp {\n  constructor() { this.routes = []; this.middleware = []; }\n  use(handler) { this.middleware.push(handler); }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  simulateRequest(method, path, body) {\n    console.log(`\\n${method} ${path}`);\n    let req = { method, path, body };\n    let res = {\n      sent: false,\n      json: function(d) {\n        if (this.sent) return;\n        this.sent = true;\n        console.log(`Response [${this.statusCode || 200}]:`, JSON.stringify(d));\n      },\n      status: function(c) { this.statusCode = c; return this; }\n    };\n    let i = 0;\n    let next = () => {\n      if (i < this.middleware.length) {\n        this.middleware[i++](req, res, next);\n      } else {\n        let route = this.routes.find(r => r.method === method && r.path === path);\n        if (route) route.handler(req, res);\n      }\n    };\n    next();\n  }\n}\n\nlet app = new ExpressApp();\n\n// Middleware 1: Logging\napp.use((req, res, next) => {\n  console.log(`[LOG] ${req.method} ${req.path}`);\n  next();\n});\n\n// Middleware 2: Validation\napp.use((req, res, next) => {\n  if (req.method === 'POST') {\n    if (!req.body || !req.body.title) {\n      console.log('[VALIDATION] Missing title!');\n      res.status(400).json({ \n        error: 'Validation failed',\n        message: 'Title is required'\n      });\n      // Don't call next() - stop here!\n      return;\n    }\n    console.log('[VALIDATION] Title found:', req.body.title);\n  }\n  next();\n});\n\n// Route: Create post\napp.post('/api/posts', (req, res) => {\n  let post = {\n    id: Math.floor(Math.random() * 1000),\n    title: req.body.title,\n    content: req.body.content || '',\n    createdAt: new Date().toISOString()\n  };\n  \n  res.json({\n    message: 'Post created successfully',\n    post: post\n  });\n});\n\n// Test with valid request\napp.simulateRequest('POST', '/api/posts', { \n  title: 'My First Post', \n  content: 'Hello World!' \n});\n\n// Test with invalid request (missing title)\napp.simulateRequest('POST', '/api/posts', { \n  content: 'No title here!' \n});\n\n// Test with completely empty body\napp.simulateRequest('POST', '/api/posts', null);",
      "commonStickingPoints": "Common middleware mistakes:\n\n1. **Forgetting to call next()**:\n   ```javascript\n   app.use((req, res, next) => {\n     console.log('Request received');\n     // Missing next()! Request hangs forever!\n   });\n   ```\n   Solution: Always call `next()` unless you're ending the request\n\n2. **Calling next() after sending response**:\n   ```javascript\n   app.use((req, res, next) => {\n     res.json({ error: 'Error' });\n     next(); // WRONG! Response already sent\n   });\n   ```\n   Solution: Use `return` after sending response\n\n3. **Wrong middleware order**:\n   ```javascript\n   // Wrong!\n   app.get('/api/users', ...);  // Routes first\n   app.use(express.json());     // Body parser after routes!\n   \n   // Correct!\n   app.use(express.json());     // Middleware first\n   app.get('/api/users', ...);  // Routes after\n   ```\n   Middleware must come BEFORE routes that need it\n\n4. **Modifying req/res incorrectly**:\n   ```javascript\n   app.use((req, res, next) => {\n     req.user = getCurrentUser(); // Good - adding property\n     req = {}; // BAD - replacing entire object!\n     next();\n   });\n   ```\n   Add properties to req/res, don't replace them\n\n5. **Error handling middleware placement**:\n   ```javascript\n   // Must be LAST!\n   app.use((err, req, res, next) => {\n     res.status(500).json({ error: err.message });\n   });\n   ```\n   Error middleware (4 parameters) must be registered last\n\n6. **Async middleware without error handling**:\n   ```javascript\n   // Wrong - errors not caught\n   app.use(async (req, res, next) => {\n     await someAsyncOperation();\n     next();\n   });\n   \n   // Correct - wrap in try/catch\n   app.use(async (req, res, next) => {\n     try {\n       await someAsyncOperation();\n       next();\n     } catch (error) {\n       next(error); // Pass error to error handler\n     }\n   });\n   ```\n\n7. **Using middleware for everything**:\n   - Not every function needs to be middleware\n   - If it's specific to one route, make it a regular function\n   - Use middleware for cross-cutting concerns (logging, auth, etc.)"
    },
    {
      "id": "10.5",
      "title": "Building a RESTful API (The Library Catalog Analogy)",
      "conceptAnalogy": "Imagine managing a library catalog system:\n\nLibrary Operations (RESTful API):\n- GET /books - View all books (like browsing shelves)\n- GET /books/:id - View one specific book (like requesting a book by card number)\n- POST /books - Add a new book (like cataloging a new arrival)\n- PUT /books/:id - Update book info completely (like replacing a catalog card)\n- PATCH /books/:id - Update part of book info (like correcting a typo)\n- DELETE /books/:id - Remove a book (like removing from catalog)\n\nEach operation uses a specific method (GET, POST, etc.) and follows a pattern!\n\nREST = Representational State Transfer\n- A standard way to design APIs\n- Uses HTTP methods correctly\n- Predictable URL patterns\n- Stateless (each request is independent)\n\nFollowing REST makes your API intuitive and easy to use!",
      "codeExample": "// Express 5.1 - RESTful API Example (2025)\n\n// Simulated Express app\nclass ExpressApp {\n  constructor() { this.routes = []; }\n  get(path, handler) { this.routes.push({ method: 'GET', path, handler }); }\n  post(path, handler) { this.routes.push({ method: 'POST', path, handler }); }\n  put(path, handler) { this.routes.push({ method: 'PUT', path, handler }); }\n  delete(path, handler) { this.routes.push({ method: 'DELETE', path, handler }); }\n  \n  simulateRequest(method, path, body = null) {\n    console.log(`\\n=== ${method} ${path} ===`);\n    if (body) console.log('Body:', JSON.stringify(body));\n    \n    let [urlPath, paramId] = this.parseUrl(path);\n    let route = this.routes.find(r => {\n      if (r.method !== method) return false;\n      let routePattern = r.path.replace(':id', '([^/]+)');\n      return new RegExp('^' + routePattern + '$').test(path);\n    });\n    \n    if (route) {\n      let id = path.match(/\\d+$/)?.[0];\n      let req = { method, path, params: { id }, body };\n      let res = {\n        status: function(code) { this.statusCode = code; return this; },\n        json: function(data) {\n          console.log(`Status: ${this.statusCode || 200}`);\n          console.log('Response:', JSON.stringify(data, null, 2));\n        }\n      };\n      route.handler(req, res);\n    } else {\n      console.log('Status: 404');\n      console.log('Response: Not Found');\n    }\n  }\n  \n  parseUrl(url) {\n    let parts = url.split('/');\n    let id = parts[parts.length - 1];\n    let path = parts.slice(0, -1).join('/');\n    return [path, id];\n  }\n}\n\nlet app = new ExpressApp();\n\n// IN-MEMORY DATABASE (simulated)\nlet books = [\n  { id: 1, title: '1984', author: 'George Orwell', year: 1949, available: true },\n  { id: 2, title: 'To Kill a Mockingbird', author: 'Harper Lee', year: 1960, available: true },\n  { id: 3, title: 'The Great Gatsby', author: 'F. Scott Fitzgerald', year: 1925, available: false }\n];\n\nlet nextId = 4;\n\n// RESTful API ROUTES\n\n// 1. GET /api/books - List all books\napp.get('/api/books', (req, res) => {\n  res.json({\n    count: books.length,\n    books: books\n  });\n});\n\n// 2. GET /api/books/:id - Get one book\napp.get('/api/books/:id', (req, res) => {\n  let id = parseInt(req.params.id);\n  let book = books.find(b => b.id === id);\n  \n  if (!book) {\n    return res.status(404).json({ \n      error: 'Book not found',\n      id: id \n    });\n  }\n  \n  res.json(book);\n});\n\n// 3. POST /api/books - Create new book\napp.post('/api/books', (req, res) => {\n  let newBook = {\n    id: nextId++,\n    title: req.body.title,\n    author: req.body.author,\n    year: req.body.year,\n    available: true\n  };\n  \n  // Validation\n  if (!newBook.title || !newBook.author) {\n    return res.status(400).json({\n      error: 'Validation failed',\n      message: 'Title and author are required'\n    });\n  }\n  \n  books.push(newBook);\n  \n  res.status(201).json({\n    message: 'Book created successfully',\n    book: newBook\n  });\n});\n\n// 4. PUT /api/books/:id - Update entire book (replace)\napp.put('/api/books/:id', (req, res) => {\n  let id = parseInt(req.params.id);\n  let index = books.findIndex(b => b.id === id);\n  \n  if (index === -1) {\n    return res.status(404).json({ error: 'Book not found' });\n  }\n  \n  // Replace entire book (keeping the ID)\n  books[index] = {\n    id: id,\n    title: req.body.title,\n    author: req.body.author,\n    year: req.body.year,\n    available: req.body.available\n  };\n  \n  res.json({\n    message: 'Book updated successfully',\n    book: books[index]\n  });\n});\n\n// 5. DELETE /api/books/:id - Delete a book\napp.delete('/api/books/:id', (req, res) => {\n  let id = parseInt(req.params.id);\n  let index = books.findIndex(b => b.id === id);\n  \n  if (index === -1) {\n    return res.status(404).json({ error: 'Book not found' });\n  }\n  \n  let deletedBook = books.splice(index, 1)[0];\n  \n  res.json({\n    message: 'Book deleted successfully',\n    book: deletedBook\n  });\n});\n\n// TEST THE API\n\nconsole.log('\\n🔥 RESTful API Demo - Book Library System\\n');\n\n// List all books\napp.simulateRequest('GET', '/api/books');\n\n// Get specific book\napp.simulateRequest('GET', '/api/books/1');\n\n// Get non-existent book\napp.simulateRequest('GET', '/api/books/999');\n\n// Create new book\napp.simulateRequest('POST', '/api/books', {\n  title: 'The Hobbit',\n  author: 'J.R.R. Tolkien',\n  year: 1937\n});\n\n// Update book\napp.simulateRequest('PUT', '/api/books/1', {\n  title: '1984',\n  author: 'George Orwell',\n  year: 1949,\n  available: false  // Changed to unavailable\n});\n\n// Delete book\napp.simulateRequest('DELETE', '/api/books/2');\n\n// List all books after changes\napp.simulateRequest('GET', '/api/books');",
      "syntaxBreakdown": "RESTful API design principles:\n\n1. **HTTP Methods Map to CRUD**:\n   - CREATE → POST\n   - READ → GET\n   - UPDATE → PUT (complete) or PATCH (partial)\n   - DELETE → DELETE\n\n2. **RESTful URL Patterns**:\n   ```\n   GET    /api/resources      → List all\n   GET    /api/resources/:id  → Get one\n   POST   /api/resources      → Create new\n   PUT    /api/resources/:id  → Update (replace)\n   PATCH  /api/resources/:id  → Update (partial)\n   DELETE /api/resources/:id  → Delete\n   ```\n\n3. **Status Codes**:\n   - 200 OK - Successful GET, PUT, PATCH\n   - 201 Created - Successful POST\n   - 204 No Content - Successful DELETE (no body)\n   - 400 Bad Request - Validation error\n   - 404 Not Found - Resource doesn't exist\n   - 500 Internal Server Error - Server problem\n\n4. **Response Format** (JSON is standard):\n   ```javascript\n   // Success\n   res.status(200).json({ data: [...] });\n   \n   // Error\n   res.status(404).json({ \n     error: 'Not found',\n     message: 'Resource does not exist'\n   });\n   ```\n\n5. **Naming Conventions**:\n   - Use plural nouns: `/books` not `/book`\n   - Use lowercase: `/api/users` not `/API/Users`\n   - Use hyphens for multi-word: `/api/book-reviews`\n   - Avoid verbs in URLs: `/api/books/1` not `/api/getBook/1`\n\n6. **Validation**:\n   ```javascript\n   if (!req.body.title) {\n     return res.status(400).json({ \n       error: 'Title is required' \n     });\n   }\n   ```\n   Always validate input before processing!\n\n7. **Idempotency**:\n   - GET, PUT, DELETE should be idempotent (same result if called multiple times)\n   - POST is NOT idempotent (creates new resource each time)\n\n8. **Versioning** (optional but recommended):\n   ```javascript\n   app.get('/api/v1/books', ...);\n   app.get('/api/v2/books', ...);\n   ```",
      "challenge": {
        "instructions": "Build a RESTful API for managing tasks (todo items):\n\n1. Create an array to store tasks (each has: id, title, completed)\n2. Implement these endpoints:\n   - GET /api/tasks - Return all tasks\n   - GET /api/tasks/:id - Return one task (404 if not found)\n   - POST /api/tasks - Create new task (validate title exists)\n   - PUT /api/tasks/:id - Update task completely\n   - DELETE /api/tasks/:id - Delete task\n\n3. Use proper status codes:\n   - 200 for successful GET/PUT\n   - 201 for successful POST\n   - 404 for not found\n   - 400 for validation errors\n\n4. Test all endpoints\n\nUse the ExpressApp class provided.",
        "starterCode": "class ExpressApp {\n  constructor() { this.routes = []; }\n  get(p, h) { this.routes.push({ method: 'GET', path: p, handler: h }); }\n  post(p, h) { this.routes.push({ method: 'POST', path: p, handler: h }); }\n  put(p, h) { this.routes.push({ method: 'PUT', path: p, handler: h }); }\n  delete(p, h) { this.routes.push({ method: 'DELETE', path: p, handler: h }); }\n  simulateRequest(method, path, body = null) {\n    console.log(`\\n${method} ${path}`);\n    let id = path.match(/\\d+$/)?.[0];\n    let route = this.routes.find(r => {\n      if (r.method !== method) return false;\n      let pattern = r.path.replace(':id', '([^/]+)');\n      return new RegExp('^' + pattern + '$').test(path);\n    });\n    if (route) {\n      let req = { params: { id }, body };\n      let res = {\n        status: function(c) { this.statusCode = c; return this; },\n        json: function(d) { console.log(`[${this.statusCode || 200}]`, JSON.stringify(d)); }\n      };\n      route.handler(req, res);\n    }\n  }\n}\n\nlet app = new ExpressApp();\n\n// Task storage\nlet tasks = [\n  { id: 1, title: 'Learn REST', completed: false }\n];\nlet nextId = 2;\n\n// TODO: Implement your routes here\n\n// Test\napp.simulateRequest('GET', '/api/tasks');\napp.simulateRequest('POST', '/api/tasks', { title: 'Build API' });\napp.simulateRequest('GET', '/api/tasks/1');\napp.simulateRequest('DELETE', '/api/tasks/1');",
        "testCases": [
          {
            "description": "Should find task by id",
            "input": "let tasks = [{ id: 1, title: 'Test' }]; tasks.find(t => t.id === 1).title",
            "expectedOutput": "Test"
          },
          {
            "description": "Should validate task has title",
            "input": "let task = { title: 'Test' }; task.title ? true : false",
            "expectedOutput": "true"
          }
        ],
        "hint": "Use tasks.find(t => t.id === parseInt(req.params.id)) to find tasks. Check for undefined and return 404."
      },
      "solution": "class ExpressApp {\n  constructor() { this.routes = []; }\n  get(p, h) { this.routes.push({ method: 'GET', path: p, handler: h }); }\n  post(p, h) { this.routes.push({ method: 'POST', path: p, handler: h }); }\n  put(p, h) { this.routes.push({ method: 'PUT', path: p, handler: h }); }\n  delete(p, h) { this.routes.push({ method: 'DELETE', path: p, handler: h }); }\n  simulateRequest(method, path, body = null) {\n    console.log(`\\n${method} ${path}`);\n    let id = path.match(/\\d+$/)?.[0];\n    let route = this.routes.find(r => {\n      if (r.method !== method) return false;\n      let pattern = r.path.replace(':id', '([^/]+)');\n      return new RegExp('^' + pattern + '$').test(path);\n    });\n    if (route) {\n      let req = { params: { id }, body };\n      let res = {\n        status: function(c) { this.statusCode = c; return this; },\n        json: function(d) { console.log(`[${this.statusCode || 200}]`, JSON.stringify(d, null, 2)); }\n      };\n      route.handler(req, res);\n    }\n  }\n}\n\nlet app = new ExpressApp();\n\n// Task storage\nlet tasks = [\n  { id: 1, title: 'Learn REST', completed: false },\n  { id: 2, title: 'Build API', completed: true }\n];\nlet nextId = 3;\n\n// GET /api/tasks - List all\napp.get('/api/tasks', (req, res) => {\n  res.json({ count: tasks.length, tasks });\n});\n\n// GET /api/tasks/:id - Get one\napp.get('/api/tasks/:id', (req, res) => {\n  let task = tasks.find(t => t.id === parseInt(req.params.id));\n  if (!task) {\n    return res.status(404).json({ error: 'Task not found' });\n  }\n  res.json(task);\n});\n\n// POST /api/tasks - Create\napp.post('/api/tasks', (req, res) => {\n  if (!req.body || !req.body.title) {\n    return res.status(400).json({ error: 'Title is required' });\n  }\n  \n  let newTask = {\n    id: nextId++,\n    title: req.body.title,\n    completed: false\n  };\n  tasks.push(newTask);\n  \n  res.status(201).json({ message: 'Task created', task: newTask });\n});\n\n// PUT /api/tasks/:id - Update\napp.put('/api/tasks/:id', (req, res) => {\n  let index = tasks.findIndex(t => t.id === parseInt(req.params.id));\n  if (index === -1) {\n    return res.status(404).json({ error: 'Task not found' });\n  }\n  \n  tasks[index] = {\n    id: parseInt(req.params.id),\n    title: req.body.title,\n    completed: req.body.completed\n  };\n  \n  res.json({ message: 'Task updated', task: tasks[index] });\n});\n\n// DELETE /api/tasks/:id - Delete\napp.delete('/api/tasks/:id', (req, res) => {\n  let index = tasks.findIndex(t => t.id === parseInt(req.params.id));\n  if (index === -1) {\n    return res.status(404).json({ error: 'Task not found' });\n  }\n  \n  let deleted = tasks.splice(index, 1)[0];\n  res.json({ message: 'Task deleted', task: deleted });\n});\n\n// Tests\nconsole.log('=== Task API Demo ===');\napp.simulateRequest('GET', '/api/tasks');\napp.simulateRequest('GET', '/api/tasks/1');\napp.simulateRequest('POST', '/api/tasks', { title: 'Deploy app' });\napp.simulateRequest('PUT', '/api/tasks/1', { title: 'Learn REST', completed: true });\napp.simulateRequest('DELETE', '/api/tasks/2');\napp.simulateRequest('GET', '/api/tasks');",
      "commonStickingPoints": "Common RESTful API mistakes:\n\n1. **Using verbs in URLs**:\n   ```javascript\n   // Wrong!\n   app.get('/api/getUsers', ...);\n   app.post('/api/createUser', ...);\n   \n   // Correct!\n   app.get('/api/users', ...);\n   app.post('/api/users', ...);\n   ```\n   The HTTP method IS the verb!\n\n2. **Inconsistent responses**:\n   ```javascript\n   // Inconsistent\n   res.json(users);                    // Sometimes array\n   res.json({ data: users });          // Sometimes object\n   \n   // Consistent\n   res.json({ users: users });         // Always object with property\n   res.json({ count: 5, users: [] });  // Always same structure\n   ```\n\n3. **Wrong status codes**:\n   ```javascript\n   // Wrong - returning 200 for error\n   res.json({ error: 'Not found' });  // Still 200!\n   \n   // Correct\n   res.status(404).json({ error: 'Not found' });\n   ```\n\n4. **Not validating input**:\n   ```javascript\n   // Dangerous!\n   app.post('/api/users', (req, res) => {\n     let user = req.body;  // What if body is malformed?\n     users.push(user);\n   });\n   \n   // Safe\n   app.post('/api/users', (req, res) => {\n     if (!req.body.name || !req.body.email) {\n       return res.status(400).json({ error: 'Invalid input' });\n     }\n     // ...\n   });\n   ```\n\n5. **Forgetting to handle not found**:\n   ```javascript\n   app.get('/api/users/:id', (req, res) => {\n     let user = users.find(u => u.id === req.params.id);\n     res.json(user);  // What if user is undefined?\n   });\n   \n   // Better\n   app.get('/api/users/:id', (req, res) => {\n     let user = users.find(u => u.id === req.params.id);\n     if (!user) {\n       return res.status(404).json({ error: 'User not found' });\n     }\n     res.json(user);\n   });\n   ```\n\n6. **Nesting resources too deeply**:\n   ```javascript\n   // Too complex!\n   GET /api/users/123/posts/456/comments/789/replies/999\n   \n   // Better\n   GET /api/comments/789/replies\n   GET /api/replies/999\n   ```\n   Keep URLs simple and flat\n\n7. **Not using plural nouns**:\n   - Use `/api/users` not `/api/user`\n   - Use `/api/products` not `/api/product`\n   - Consistency matters!"
    }
  ]
}
