{
  "id": 5,
  "title": "Module 5: Grouping Information (The 'Containers')",
  "description": "Store and organize multiple pieces of related information using arrays and objects",
  "goal": "Master arrays and objects to manage collections of data efficiently",
  "lessons": [
    {
      "id": "5.1",
      "title": "Ordered Lists of Things (Arrays)",
      "conceptAnalogy": "Imagine you have a shopping list written on paper:\n\n1. Milk\n2. Eggs\n3. Bread\n4. Butter\n\nThis is an ordered list - each item has a position (1st, 2nd, 3rd, etc.). In programming, we call this an ARRAY. It's a single variable that can hold multiple values in a specific order.\n\nThink of an array like a train with numbered cars: Car 0 has apples, Car 1 has bananas, Car 2 has cherries. The numbers (0, 1, 2) are called 'indices' (plural of index), and they tell you where each item is located.\n\nImportant quirk: Programming counts from 0, not 1! So the first item is at position 0, the second at position 1, and so on.",
      "codeExample": "// Creating an array\nlet fruits = ['apple', 'banana', 'cherry'];\n\n// Accessing items by index (position)\nconsole.log(fruits[0]);  // apple (first item)\nconsole.log(fruits[1]);  // banana (second item)\nconsole.log(fruits[2]);  // cherry (third item)\n\n// Arrays can hold different types\nlet mixed = ['text', 42, true, null];\nconsole.log(mixed[1]);  // 42\n\n// Empty array\nlet empty = [];\n\n// Array length (how many items)\nconsole.log(fruits.length);  // 3\n\n// Last item (using length)\nlet lastFruit = fruits[fruits.length - 1];\nconsole.log(lastFruit);  // cherry\n\n// Changing an item\nfruits[1] = 'blueberry';\nconsole.log(fruits);  // ['apple', 'blueberry', 'cherry']\n\n// Loop through array\nfor (let i = 0; i < fruits.length; i++) {\n  console.log('Item ' + i + ': ' + fruits[i]);\n}",
      "syntaxBreakdown": "Array syntax:\n\n// Creating arrays\nlet arrayName = [item1, item2, item3];\nlet empty = [];\n\n// Accessing items (zero-indexed!)\narray[0]  // First item\narray[1]  // Second item\narray[2]  // Third item\n\n// Index visualization:\nlet numbers = [10, 20, 30, 40, 50];\n//  Index:     0   1   2   3   4\n//  Value:    10  20  30  40  50\n\nnumbers[0] → 10\nnumbers[4] → 50\nnumbers[5] → undefined (doesn't exist)\n\nKey properties:\n\n1. .length - number of items\n   - ['a', 'b', 'c'].length → 3\n   - [].length → 0\n\n2. Zero-indexed\n   - First item: array[0]\n   - Last item: array[array.length - 1]\n\n3. Mutable (can be changed)\n   - array[0] = 'new value'\n\n4. Can hold any type\n   - [1, 'text', true, {}, []]  // all valid\n\nCommon patterns:\n\n// Last item\nlet last = array[array.length - 1];\n\n// Check if empty\nif (array.length === 0) {\n  console.log('Empty');\n}\n\n// Loop through all items\nfor (let i = 0; i < array.length; i++) {\n  // use array[i]\n}",
      "challenge": {
        "instructions": "Create a simple gradebook:\n1. Create an array of test scores: [85, 92, 78, 95, 88]\n2. Display the first score (index 0)\n3. Display the last score (use .length - 1)\n4. Calculate and display the average score (sum all, divide by length)",
        "starterCode": "let scores = [85, 92, 78, 95, 88];\n\n// Display first score\n\n// Display last score\n\n// Calculate average\nlet total = 0;\n// Use a loop to sum all scores\n// Then divide by scores.length\n",
        "testCases": [
          {
            "description": "Displays first score",
            "input": "let scores = [85, 92, 78, 95, 88]; console.log(scores[0]);",
            "expectedOutput": "85"
          }
        ],
        "hint": "First: scores[0], Last: scores[scores.length - 1], Average: sum all in loop, divide by scores.length"
      },
      "solution": "let scores = [85, 92, 78, 95, 88];\n\nconsole.log('First score: ' + scores[0]);\nconsole.log('Last score: ' + scores[scores.length - 1]);\n\nlet total = 0;\nfor (let i = 0; i < scores.length; i++) {\n  total += scores[i];\n}\n\nlet average = total / scores.length;\nconsole.log('Average: ' + average);",
      "commonStickingPoints": "Common mistakes:\n\n1. Starting at index 1 instead of 0:\n   array[1]  // This is the SECOND item, not first!\n   array[0]  // This is the first item\n\n2. Accessing index === length:\n   let arr = ['a', 'b', 'c'];  // length is 3\n   arr[3]  // undefined - no such index!\n   // Valid indices: 0, 1, 2\n\n3. Forgetting .length is a property, not a method:\n   array.length()  // WRONG\n   array.length    // CORRECT (no parentheses)\n\n4. Confusing length with last index:\n   let arr = ['a', 'b', 'c'];\n   arr.length       // 3 (count of items)\n   arr[arr.length]  // undefined!\n   arr[arr.length - 1]  // 'c' (last item)\n\n5. Treating arrays like single values:\n   let arr = [1, 2, 3];\n   console.log(arr);  // Prints whole array [1, 2, 3]\n   console.log(arr[0]);  // Prints just first item: 1"
    },
    {
      "id": "5.2",
      "title": "Adding and Removing Items (Array Methods: push, pop, shift, unshift)",
      "conceptAnalogy": "Imagine your array is a line of people:\n\n**push()**: Someone new joins the END of the line\n**pop()**: The person at the END of the line leaves\n**unshift()**: Someone cuts in at the FRONT of the line\n**shift()**: The person at the FRONT of the line leaves\n\nThese four methods let you add or remove items from either end of an array. They're like doors - two at the back (push/pop) and two at the front (shift/unshift).",
      "codeExample": "let fruits = ['apple', 'banana'];\nconsole.log(fruits);  // ['apple', 'banana']\n\n// push() - add to the END\nfruits.push('cherry');\nconsole.log(fruits);  // ['apple', 'banana', 'cherry']\n\n// Can push multiple at once\nfruits.push('date', 'elderberry');\nconsole.log(fruits);  // ['apple', 'banana', 'cherry', 'date', 'elderberry']\n\n// pop() - remove from the END, returns the removed item\nlet removed = fruits.pop();\nconsole.log(removed);  // 'elderberry'\nconsole.log(fruits);  // ['apple', 'banana', 'cherry', 'date']\n\n// unshift() - add to the FRONT\nfruits.unshift('apricot');\nconsole.log(fruits);  // ['apricot', 'apple', 'banana', 'cherry', 'date']\n\n// shift() - remove from the FRONT, returns the removed item\nlet firstItem = fruits.shift();\nconsole.log(firstItem);  // 'apricot'\nconsole.log(fruits);  // ['apple', 'banana', 'cherry', 'date']\n\n// Practical: stack (Last In, First Out)\nlet stack = [];\nstack.push('task 1');\nstack.push('task 2');\nstack.push('task 3');\nlet current = stack.pop();  // 'task 3' - most recent\n\n// Practical: queue (First In, First Out)\nlet queue = [];\nqueue.push('person 1');\nqueue.push('person 2');\nqueue.push('person 3');\nlet next = queue.shift();  // 'person 1' - first in line",
      "syntaxBreakdown": "The four basic array methods:\n\n1. push(item) - add to END\n   - Adds one or more items to the end\n   - Returns new length\n   - Example: arr.push('x') → adds 'x' to end\n\n2. pop() - remove from END\n   - Removes last item\n   - Returns the removed item\n   - Example: let last = arr.pop()\n\n3. unshift(item) - add to FRONT\n   - Adds one or more items to the beginning\n   - Shifts all existing items to higher indices\n   - Returns new length\n   - Example: arr.unshift('x') → adds 'x' to front\n\n4. shift() - remove from FRONT\n   - Removes first item\n   - Shifts all remaining items to lower indices\n   - Returns the removed item\n   - Example: let first = arr.shift()\n\nMemory trick:\n- push/pop: work with the END (both have 'p')\n- shift/unshift: work with the FRONT\n- push/unshift: ADD items\n- pop/shift: REMOVE items\n\nPerformance notes:\n- push() and pop(): Fast (O(1))\n- shift() and unshift(): Slower (O(n)) because indices must be recalculated\n- For large arrays, avoid shift/unshift if performance matters\n\nThese methods MODIFY the original array:\nlet arr = [1, 2];\narr.push(3);  // arr is now [1, 2, 3]\n// The original array changed!",
      "challenge": {
        "instructions": "Simulate a simple to-do list:\n1. Start with an empty array: let todos = []\n2. Add 'Buy groceries' to the end\n3. Add 'Clean room' to the end\n4. Add 'URGENT: Pay bills' to the FRONT (it's urgent!)\n5. Display the array\n6. Complete the first task (remove it with shift())\n7. Display the updated array",
        "starterCode": "let todos = [];\n\n// Add tasks\n\n// Display\n\n// Complete first task\n\n// Display again\n",
        "testCases": [
          {
            "description": "Builds todo list correctly",
            "input": "let todos = []; todos.push('Buy groceries'); todos.push('Clean room'); todos.unshift('URGENT: Pay bills'); console.log(todos.length);",
            "expectedOutput": "3"
          }
        ],
        "hint": "push() for end, unshift() for front, shift() to remove first"
      },
      "solution": "let todos = [];\n\ntodos.push('Buy groceries');\ntodos.push('Clean room');\ntodos.unshift('URGENT: Pay bills');\n\nconsole.log('Todos:', todos);\n// ['URGENT: Pay bills', 'Buy groceries', 'Clean room']\n\nlet completed = todos.shift();\nconsole.log('Completed:', completed);\nconsole.log('Remaining todos:', todos);\n// ['Buy groceries', 'Clean room']",
      "commonStickingPoints": "Common mistakes:\n\n1. Forgetting these methods modify the array:\n   let arr = [1, 2, 3];\n   arr.push(4);  // arr is NOW [1, 2, 3, 4]\n   // It's not arr2 = arr.push(4)\n\n2. Expecting push/pop to work on both ends:\n   arr.pop()  // Removes from END, not front\n   // Use shift() to remove from front\n\n3. Not using the return value:\n   arr.pop();  // Item is removed AND returned\n   let item = arr.pop();  // Save the removed item!\n\n4. Confusing shift/unshift names:\n   shift = remove first (shifts everything left)\n   unshift = add to first (unshifts everything right)\n   Confusing, but that's the name!\n\n5. Using on non-arrays:\n   let str = 'hello';\n   str.push('x');  // ERROR - strings don't have push\n   // Convert to array first: str.split('')"
    },
    {
      "id": "5.3",
      "title": "Searching and Transforming Lists (find, filter, map, reduce)",
      "conceptAnalogy": "Imagine you're managing a music playlist with 1000 songs:\n\n**find()**: 'Find me the first song by Taylor Swift' - you scan through until you find ONE match, then stop.\n\n**filter()**: 'Give me all songs from 2020' - you go through the entire list and create a NEW list with only the songs that match.\n\n**map()**: 'Convert all song titles to uppercase' - you go through each song and create a NEW list where each item has been transformed.\n\n**reduce()**: 'Calculate the total duration of all songs' - you go through each song, adding up all the durations into a SINGLE result. Reduce is like a snowball rolling down a hill, accumulating more snow (data) as it goes.\n\nThese are four of the most powerful array methods in JavaScript. They don't change the original array - they create new values or arrays.",
      "codeExample": "let numbers = [1, 4, 7, 10, 15, 20];\n\n// find() - returns FIRST item that matches\nlet firstBigNumber = numbers.find(function(num) {\n  return num > 10;\n});\nconsole.log(firstBigNumber);  // 15 (first one > 10)\n\n// filter() - returns ALL items that match\nlet bigNumbers = numbers.filter(function(num) {\n  return num > 10;\n});\nconsole.log(bigNumbers);  // [15, 20]\n\n// map() - transforms each item, returns new array\nlet doubled = numbers.map(function(num) {\n  return num * 2;\n});\nconsole.log(doubled);  // [2, 8, 14, 20, 30, 40]\nconsole.log(numbers);  // [1, 4, 7, 10, 15, 20] - original unchanged!\n\n// Real-world examples\nlet products = [\n  { name: 'Laptop', price: 1000 },\n  { name: 'Mouse', price: 25 },\n  { name: 'Keyboard', price: 75 },\n  { name: 'Monitor', price: 300 }\n];\n\n// Find first expensive item\nlet expensive = products.find(p => p.price > 500);\nconsole.log(expensive);  // {name: 'Laptop', price: 1000}\n\n// Filter affordable items\nlet affordable = products.filter(p => p.price < 100);\nconsole.log(affordable);  // Mouse and Keyboard\n\n// Get array of just names\nlet names = products.map(p => p.name);\nconsole.log(names);  // ['Laptop', 'Mouse', 'Keyboard', 'Monitor']\n\n// reduce() - accumulate values into a single result\nlet prices = [100, 200, 50, 75];\n\n// Calculate total (the snowball rolling down the hill!)\nlet total = prices.reduce(function(accumulator, currentPrice) {\n  return accumulator + currentPrice;\n}, 0);  // 0 is the starting value\n\nconsole.log(total);  // 425\n\n// Real-world: Calculate total price of cart\nlet totalCartPrice = products.reduce(function(sum, product) {\n  return sum + product.price;\n}, 0);\n\nconsole.log('Cart total: $' + totalCartPrice);  // $1400\n\n// Count items (using reduce creatively)\nlet words = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple'];\nlet wordCount = words.reduce(function(counts, word) {\n  counts[word] = (counts[word] || 0) + 1;\n  return counts;\n}, {});\n\nconsole.log(wordCount);  // {apple: 3, banana: 2, cherry: 1}",
      "syntaxBreakdown": "Understanding the three methods:\n\n1. **find(callbackFunction)**\n   - Goes through array until callback returns true\n   - Returns the FIRST matching item\n   - Returns undefined if no match found\n   - Syntax: array.find(item => condition)\n\nExample:\nlet ages = [12, 18, 25, 30];\nlet adult = ages.find(age => age >= 18);  // 18\n\n2. **filter(callbackFunction)**\n   - Goes through ENTIRE array\n   - Returns NEW array with ALL matching items\n   - Returns empty array [] if no matches\n   - Original array unchanged\n   - Syntax: array.filter(item => condition)\n\nExample:\nlet adults = ages.filter(age => age >= 18);  // [18, 25, 30]\n\n3. **map(callbackFunction)**\n   - Goes through ENTIRE array\n   - Transforms each item\n   - Returns NEW array (same length as original)\n   - Original array unchanged\n   - Syntax: array.map(item => transformation)\n\nExample:\nlet doubled = ages.map(age => age * 2);  // [24, 36, 50, 60]\n\nCallback function:\n- A function you pass to another function\n- Gets called for each item\n- Receives: (item, index, array)\n- Usually you only need: item\n\nArrow function shorthand:\n// Long form\narray.find(function(item) {\n  return item > 10;\n})\n\n// Short form\narray.find(item => item > 10)\n\n4. **reduce(callbackFunction, initialValue)**\n   - Goes through ENTIRE array\n   - Accumulates/combines all values into a SINGLE result\n   - Like a snowball rolling downhill, gathering more\n   - Can return ANY type (number, string, object, array)\n   - Syntax: array.reduce((accumulator, item) => newAccumulator, startValue)\n\nExample - Sum numbers:\nlet prices = [10, 20, 30];\nlet total = prices.reduce((sum, price) => sum + price, 0);\n// Step 1: sum=0, price=10 → returns 10\n// Step 2: sum=10, price=20 → returns 30\n// Step 3: sum=30, price=30 → returns 60\n// Result: 60\n\nExample - Build object:\nlet fruits = ['apple', 'banana', 'apple'];\nlet counts = fruits.reduce((obj, fruit) => {\n  obj[fruit] = (obj[fruit] || 0) + 1;\n  return obj;\n}, {});\n// Result: {apple: 2, banana: 1}\n\nCallback function parameters:\n- **accumulator**: The accumulated value (result so far)\n- **currentValue**: Current item being processed\n- **index**: Current index (optional)\n- **array**: Original array (optional)\n\nInitial value:\n- Second argument to reduce()\n- Starting point for accumulator\n- Common values: 0 (for sums), '' (for strings), {} (for objects), [] (for arrays)\n- If omitted, first array element is used\n\nReturn value patterns:\n- find: single item or undefined\n- filter: new array (could be empty)\n- map: new array (same length as original)\n- reduce: single value of ANY type (number, string, object, array, etc.)",
      "challenge": {
        "instructions": "You have a list of student objects. Use array methods to:\n1. Find the first student with a grade >= 90\n2. Filter to get all students who passed (grade >= 60)\n3. Map to get an array of just the student names\n\nlet students = [\n  {name: 'Alice', grade: 85},\n  {name: 'Bob', grade: 92},\n  {name: 'Charlie', grade: 58},\n  {name: 'Diana', grade: 95}\n];",
        "starterCode": "let students = [\n  {name: 'Alice', grade: 85},\n  {name: 'Bob', grade: 92},\n  {name: 'Charlie', grade: 58},\n  {name: 'Diana', grade: 95}\n];\n\n// Find first with grade >= 90\n\n// Filter students who passed (>= 60)\n\n// Map to get just names\n",
        "testCases": [
          {
            "description": "Finds first top student",
            "input": "let students = [{name: 'Alice', grade: 85}, {name: 'Bob', grade: 92}]; let top = students.find(s => s.grade >= 90); console.log(top.name);",
            "expectedOutput": "Bob"
          }
        ],
        "hint": "find(s => s.grade >= 90), filter(s => s.grade >= 60), map(s => s.name)"
      },
      "solution": "let students = [\n  {name: 'Alice', grade: 85},\n  {name: 'Bob', grade: 92},\n  {name: 'Charlie', grade: 58},\n  {name: 'Diana', grade: 95}\n];\n\nlet topStudent = students.find(s => s.grade >= 90);\nconsole.log('Top student:', topStudent);  // Bob\n\nlet passed = students.filter(s => s.grade >= 60);\nconsole.log('Passed:', passed);  // Alice, Bob, Diana\n\nlet names = students.map(s => s.name);\nconsole.log('All names:', names);  // ['Alice', 'Bob', 'Charlie', 'Diana']",
      "commonStickingPoints": "Common mistakes:\n\n1. Expecting find() to return all matches:\n   arr.find(x => x > 5)  // Returns FIRST match only\n   arr.filter(x => x > 5)  // Returns ALL matches\n\n2. Forgetting that map() always returns same-length array:\n   [1, 2, 3].map(x => x * 2)  // [2, 4, 6] - still 3 items\n   // Can't make array shorter with map, use filter for that\n\n3. Confusing filter and map:\n   filter: selects items (can make array shorter)\n   map: transforms items (same length)\n\n4. Not returning in the callback:\n   arr.map(x => { x * 2 })  // Returns [undefined, undefined, ...]\n   arr.map(x => x * 2)  // Correct - implicit return\n   arr.map(x => { return x * 2 })  // Also correct - explicit return\n\n5. Forgetting these don't modify original:\n   let arr = [1, 2, 3];\n   arr.map(x => x * 2);  // arr is still [1, 2, 3]!\n   let doubled = arr.map(x => x * 2);  // Save the result!"
    },
    {
      "id": "5.4",
      "title": "Dictionaries: Storing Information with Labels (Objects)",
      "conceptAnalogy": "Imagine you're filling out a form about yourself:\n\nName: Alice\nAge: 25\nCity: New York\nIs Student: true\n\nEach piece of info has a LABEL (Name, Age, etc.) and a VALUE ('Alice', 25, etc.). This is different from an array, where items are accessed by position numbers. Here, you access items by NAME.\n\nIn JavaScript, this is called an OBJECT. Think of it like a real dictionary: you look up a WORD (the key) to find its DEFINITION (the value). Or like a person's contact card: each field (label) has a value.\n\nObjects are perfect for representing things with named properties: a user, a product, a car, etc.",
      "codeExample": "// Creating an object\nlet person = {\n  name: 'Alice',\n  age: 25,\n  city: 'New York',\n  isStudent: false\n};\n\n// Accessing properties (two ways)\nconsole.log(person.name);      // Alice (dot notation)\nconsole.log(person['age']);    // 25 (bracket notation)\n\n// Changing a property\nperson.age = 26;\nconsole.log(person.age);  // 26\n\n// Adding a new property\nperson.email = 'alice@example.com';\nconsole.log(person.email);  // alice@example.com\n\n// Deleting a property\ndelete person.isStudent;\nconsole.log(person.isStudent);  // undefined\n\n// Object with different types\nlet product = {\n  name: 'Laptop',\n  price: 999.99,\n  inStock: true,\n  specs: ['16GB RAM', '512GB SSD'],  // Array inside object!\n  manufacturer: {\n    name: 'Dell',\n    country: 'USA'\n  }  // Object inside object!\n};\n\nconsole.log(product.specs[0]);  // 16GB RAM\nconsole.log(product.manufacturer.name);  // Dell\n\n// Empty object\nlet empty = {};",
      "syntaxBreakdown": "Object syntax:\n\n// Creating an object\nlet objectName = {\n  key1: value1,\n  key2: value2,\n  key3: value3\n};\n\nKey points:\n\n1. Surrounded by curly braces { }\n2. Key-value pairs separated by commas\n3. Key and value separated by colon :\n4. Keys are usually unquoted (unless they have spaces)\n5. Values can be any type\n\nAccessing properties:\n\n// Dot notation (most common)\nobject.propertyName\n\n// Bracket notation (for special cases)\nobject['property name']  // Property has space\nobject[variableName]     // Property name is in a variable\n\nWhen to use brackets:\n- Property name has spaces/special chars: obj['first name']\n- Property name is in a variable: let prop = 'age'; obj[prop]\n- Property name is computed: obj['item' + i]\n\nModifying objects:\n\n// Change existing property\nobj.name = 'new value';\n\n// Add new property\nobj.newProperty = 'value';\n\n// Delete property\ndelete obj.property;\n\n// Check if property exists\nif (obj.property !== undefined) { }\n// OR\nif ('property' in obj) { }\n\nNested structures:\nlet user = {\n  name: 'Alice',\n  address: {\n    street: '123 Main St',\n    city: 'NYC'\n  },\n  hobbies: ['reading', 'coding']\n};\n\nuser.address.city  // NYC\nuser.hobbies[0]    // reading",
      "challenge": {
        "instructions": "Create an object representing a book:\n1. Create object with: title (string), author (string), pages (number), isRead (boolean)\n2. Display the title\n3. Change isRead to true\n4. Add a new property 'rating' with a number 1-5\n5. Display the entire object",
        "starterCode": "// Create your book object\n\n// Display title\n\n// Mark as read\n\n// Add rating\n\n// Display object\n",
        "testCases": [
          {
            "description": "Creates book object correctly",
            "input": "let book = {title: 'Harry Potter', author: 'J.K. Rowling', pages: 300, isRead: false}; console.log(book.title);",
            "expectedOutput": "Harry Potter"
          }
        ],
        "hint": "let book = {title: '...', author: '...', pages: 300, isRead: false};"
      },
      "solution": "let book = {\n  title: '1984',\n  author: 'George Orwell',\n  pages: 328,\n  isRead: false\n};\n\nconsole.log('Title:', book.title);\n\nbook.isRead = true;\n\nbook.rating = 5;\n\nconsole.log('Book:', book);",
      "commonStickingPoints": "Common mistakes:\n\n1. Forgetting commas between properties:\n   {name: 'Alice' age: 25}  // WRONG - missing comma\n   {name: 'Alice', age: 25}  // CORRECT\n\n2. Using = instead of ::\n   {name = 'Alice'}  // WRONG\n   {name: 'Alice'}   // CORRECT\n\n3. Trailing comma on last property:\n   {name: 'Alice', age: 25,}  // Works in modern JS, but some old browsers error\n\n4. Confusing arrays and objects:\n   let arr = [1, 2, 3];    // Square brackets\n   let obj = {a: 1, b: 2}; // Curly braces\n\n5. Trying to use dot notation with spaces:\n   obj.first name  // WRONG\n   obj['first name']  // CORRECT\n   obj.firstName   // BETTER - use camelCase\n\n6. Expecting specific order:\n   Objects don't guarantee property order (though modern JS usually preserves it)\n   If order matters, use an array!"
    },
    {
      "id": "5.5",
      "title": "Working with Object Properties (Iterating and Manipulating)",
      "conceptAnalogy": "Imagine you're a store clerk inventorying products. You need to go through each product and check its details:\n\n'Product 1: Name = Laptop, Price = $1000'\n'Product 2: Name = Mouse, Price = $25'\n\nJust like we looped through arrays, we need to loop through objects. But objects don't have index numbers - they have property NAMES. JavaScript gives us special tools to work with object properties: get all keys, all values, or all key-value pairs.",
      "codeExample": "let student = {\n  name: 'Alice',\n  age: 20,\n  grade: 'A',\n  major: 'Computer Science'\n};\n\n// Get all property names (keys)\nlet keys = Object.keys(student);\nconsole.log(keys);  // ['name', 'age', 'grade', 'major']\n\n// Get all property values\nlet values = Object.values(student);\nconsole.log(values);  // ['Alice', 20, 'A', 'Computer Science']\n\n// Get all key-value pairs\nlet entries = Object.entries(student);\nconsole.log(entries);  // [['name', 'Alice'], ['age', 20], ...]\n\n// Loop through keys\nfor (let key of Object.keys(student)) {\n  console.log(key + ': ' + student[key]);\n}\n\n// Loop through key-value pairs (more elegant)\nfor (let [key, value] of Object.entries(student)) {\n  console.log(key + ': ' + value);\n}\n\n// for...in loop (older way)\nfor (let key in student) {\n  console.log(key + ': ' + student[key]);\n}\n\n// Practical: calculate total prices\nlet cart = {\n  laptop: 1000,\n  mouse: 25,\n  keyboard: 75\n};\n\nlet total = 0;\nfor (let price of Object.values(cart)) {\n  total += price;\n}\nconsole.log('Total: $' + total);  // $1100",
      "syntaxBreakdown": "Three key Object methods:\n\n1. **Object.keys(obj)**\n   - Returns array of property names\n   - {a: 1, b: 2} → ['a', 'b']\n   - Use when you need property names\n\n2. **Object.values(obj)**\n   - Returns array of property values\n   - {a: 1, b: 2} → [1, 2]\n   - Use when you only need values\n\n3. **Object.entries(obj)**\n   - Returns array of [key, value] pairs\n   - {a: 1, b: 2} → [['a', 1], ['b', 2]]\n   - Use when you need both keys and values\n\nLoop patterns:\n\n// Pattern 1: Loop through keys\nfor (let key of Object.keys(obj)) {\n  console.log(key);          // Property name\n  console.log(obj[key]);     // Property value\n}\n\n// Pattern 2: Loop through values\nfor (let value of Object.values(obj)) {\n  console.log(value);  // Just the values\n}\n\n// Pattern 3: Loop through entries (destructuring)\nfor (let [key, value] of Object.entries(obj)) {\n  console.log(key, value);  // Both at once\n}\n\n// Pattern 4: for...in loop (older)\nfor (let key in obj) {\n  console.log(key, obj[key]);\n}\n\nDestructuring in loops:\n// This:\nfor (let entry of Object.entries(obj)) {\n  let key = entry[0];\n  let value = entry[1];\n}\n\n// Can be written as:\nfor (let [key, value] of Object.entries(obj)) {\n  // key and value are extracted automatically!\n}\n\nCounting properties:\nObject.keys(obj).length  // Number of properties",
      "challenge": {
        "instructions": "You have a product inventory object. Calculate:\n1. Total number of products (count of properties)\n2. Total value of all inventory (sum of all prices)\n3. Display each product with its price\n\nlet inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};",
        "starterCode": "let inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};\n\n// Count products\n\n// Calculate total value\n\n// Display each product\n",
        "testCases": [
          {
            "description": "Counts products correctly",
            "input": "let inventory = {laptop: 1200, mouse: 30}; console.log(Object.keys(inventory).length);",
            "expectedOutput": "2"
          }
        ],
        "hint": "Object.keys(inventory).length for count, loop through Object.values() to sum"
      },
      "solution": "let inventory = {\n  laptop: 1200,\n  mouse: 30,\n  keyboard: 80,\n  monitor: 350\n};\n\nlet productCount = Object.keys(inventory).length;\nconsole.log('Total products: ' + productCount);\n\nlet totalValue = 0;\nfor (let price of Object.values(inventory)) {\n  totalValue += price;\n}\nconsole.log('Total inventory value: $' + totalValue);\n\nconsole.log('Product list:');\nfor (let [product, price] of Object.entries(inventory)) {\n  console.log(product + ': $' + price);\n}",
      "commonStickingPoints": "Common mistakes:\n\n1. Calling Object.keys() on non-object:\n   Object.keys([1,2,3])  // Works but returns ['0', '1', '2'] (indices as strings)\n   Object.keys('hello')  // Works but returns ['0', '1', '2', '3', '4']\n   \n2. Forgetting Object.keys() returns an array:\n   Object.keys(obj)  // Returns ARRAY of keys\n   // Must loop through: for (let key of Object.keys(obj))\n\n3. Confusing for...of and for...in:\n   for (let key of obj)  // ERROR - objects aren't iterable with for...of\n   for (let key in obj)  // CORRECT - for...in works on objects\n   for (let key of Object.keys(obj))  // ALSO CORRECT\n\n4. Not using destructuring with entries:\n   for (let entry of Object.entries(obj)) {\n     console.log(entry[0], entry[1]);  // Works but clunky\n   }\n   for (let [key, value] of Object.entries(obj)) {\n     console.log(key, value);  // Much cleaner!\n   }\n\n5. Expecting specific order:\n   Object properties don't have a guaranteed order\n   (Though modern JS usually maintains insertion order)"
    }
  ]
}
