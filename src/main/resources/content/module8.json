{
  "id": 8,
  "title": "Module 8: Asynchronous JavaScript (The 'Waiting Game')",
  "description": "Handle tasks that take time without freezing your application",
  "goal": "Master async patterns for network requests, timers, and responsive UIs",
  "lessons": [
    {
      "id": "8.1",
      "title": "The Restaurant Buzzer (Synchronous vs. Asynchronous)",
      "conceptAnalogy": "Imagine two different ways of ordering food:\n\n**Synchronous (Blocking)**: You stand at the counter. The cook makes your burger while you wait, staring at them. You can't do ANYTHING else until your burger is ready. If it takes 20 minutes, you stand there for 20 minutes. This is how most code works - one line after another, waiting for each to finish.\n\n**Asynchronous (Non-blocking)**: You order, get a buzzer, and sit down. While the kitchen makes your food, you can chat with friends, check your phone, or relax. When food is ready, the buzzer vibrates, and you go pick it up. You're not stuck waiting!\n\nJavaScript is single-threaded (one line at a time), but asynchronous code lets it START a slow task, move on to other things, then come back when the slow task is done. Perfect for network requests, file reading, or anything that takes time.",
      "codeExample": "// SYNCHRONOUS (Blocking) - Everything waits\nconsole.log('Start');\nfor (let i = 0; i < 3; i++) {\n  console.log('Step ' + i);\n}\nconsole.log('End');\n// Output: Start, Step 0, Step 1, Step 2, End (in order)\n\n// ASYNCHRONOUS (Non-blocking) - Using setTimeout\nconsole.log('Start');\n\nsetTimeout(function() {\n  console.log('This runs after 2 seconds');\n}, 2000);\n\nconsole.log('End');\n// Output: Start, End, (wait 2 seconds), This runs after 2 seconds\n// Notice 'End' comes BEFORE the timeout!\n\n// Practical example: Loading data\nconsole.log('Fetching user data...');\n\n// Simulating a slow network request (async)\nsetTimeout(function() {\n  console.log('User data loaded: Alice, age 25');\n}, 1000);\n\nconsole.log('Continuing with other tasks...');\n// Output:\n// Fetching user data...\n// Continuing with other tasks...\n// (1 second later) User data loaded: Alice, age 25\n\n// Multiple async operations\nconsole.log('Cooking eggs');\n\nsetTimeout(() => console.log('Eggs done!'), 2000);\nsetTimeout(() => console.log('Toast done!'), 1000);\nsetTimeout(() => console.log('Coffee done!'), 1500);\n\nconsole.log('Started all cooking tasks');\n// Output:\n// Cooking eggs\n// Started all cooking tasks\n// (1s) Toast done!\n// (1.5s) Coffee done!\n// (2s) Eggs done!",
      "syntaxBreakdown": "Understanding sync vs async:\n\n**Synchronous Code (Default):**\n- Runs line by line\n- Each line waits for the previous to complete\n- Blocking (stops everything until done)\n\nlet a = 1;\nlet b = 2;\nlet c = a + b;  // Waits for a and b\nconsole.log(c);  // Waits for c\n\n**Asynchronous Code:**\n- Starts a task\n- Doesn't wait for it to finish\n- Continues to next line immediately\n- Comes back when task completes\n\nCommon async operations:\n- setTimeout / setInterval (timers)\n- fetch() (network requests)\n- Reading files (Node.js)\n- Database queries\n- User interactions (clicks are async events)\n\n**setTimeout Syntax:**\n\nsetTimeout(callbackFunction, delayInMilliseconds);\n\nExamples:\nsetTimeout(() => console.log('Hi'), 1000);  // After 1 second\nsetTimeout(myFunction, 500);  // After 0.5 seconds\nsetTimeout(() => {\n  console.log('Multiple');\n  console.log('Lines');\n}, 2000);  // After 2 seconds\n\n**setInterval (Repeating Timer):**\n\nsetInterval(callbackFunction, intervalInMilliseconds);\n\nlet count = 0;\nlet intervalId = setInterval(() => {\n  count++;\n  console.log('Count:', count);\n  \n  if (count === 5) {\n    clearInterval(intervalId);  // Stop the interval\n  }\n}, 1000);  // Every 1 second\n\n**Why Async Matters:**\n\n// Synchronous (BAD for web):\nlet data = fetchDataFromServer();  // Takes 3 seconds, UI freezes!\nconsole.log(data);\n\n// Asynchronous (GOOD for web):\nfetchDataFromServer((data) => {\n  console.log(data);\n});  // UI stays responsive!\n\n**The Event Loop:**\n\nJavaScript has:\n1. Call stack (current code running)\n2. Web APIs (setTimeout, fetch, etc.)\n3. Callback queue (waiting callbacks)\n4. Event loop (moves callbacks to stack when empty)\n\nThis is how async works without multiple threads!",
      "challenge": {
        "instructions": "Create a countdown timer that:\n1. Starts at 3\n2. Logs the number every second\n3. Logs 'Liftoff!' after 0\n\nExpected output (over 4 seconds):\n3\n2\n1\n0\nLiftoff!",
        "starterCode": "let count = 3;\n\n// Create an interval that runs every 1000ms\nlet intervalId = setInterval(() => {\n  // YOUR CODE HERE\n  // Log count\n  // Decrease count\n  // If count < 0, log 'Liftoff!' and stop interval\n}, 1000);",
        "testCases": [
          {
            "description": "Countdown works correctly",
            "input": "let count = 3; let output = ''; while (count >= 0) { output += count + '\\n'; count--; } output += 'Liftoff!'; console.log(output.trim());",
            "expectedOutput": "3\n2\n1\n0\nLiftoff!"
          }
        ],
        "hint": "Log count, then count--, then if (count < 0) clearInterval and log Liftoff"
      },
      "solution": "let count = 3;\n\nlet intervalId = setInterval(() => {\n  console.log(count);\n  count--;\n  \n  if (count < 0) {\n    console.log('Liftoff!');\n    clearInterval(intervalId);\n  }\n}, 1000);",
      "commonStickingPoints": "Common mistakes:\n\n1. Expecting async code to run in order:\n   setTimeout(() => console.log('A'), 1000);\n   console.log('B');\n   // Output: B, (wait), A  (not A, B!)\n\n2. Not storing interval ID to clear it:\n   setInterval(() => console.log('Hi'), 1000);\n   // Can't stop it now!\n   \n   Correct:\n   let id = setInterval(() => console.log('Hi'), 1000);\n   clearInterval(id);  // Can stop it\n\n3. Confusing milliseconds with seconds:\n   setTimeout(() => console.log('Hi'), 5);  // 5 milliseconds!\n   setTimeout(() => console.log('Hi'), 5000);  // 5 seconds\n\n4. Creating infinite intervals:\n   setInterval(() => {\n     // Runs forever!\n   }, 1000);\n   // Remember to clearInterval when done\n\n5. Trying to 'wait' for async with sync code:\n   setTimeout(() => data = fetchData(), 1000);\n   console.log(data);  // undefined! Timeout hasn't run yet\n   \n   Must use callbacks or promises (next lessons)"
    },
    {
      "id": "8.2",
      "title": "The Promise of a Future Result (Promises)",
      "conceptAnalogy": "You order a pizza for delivery:\n\n1. **You place the order** (create a Promise) - The restaurant promises to either deliver your pizza OR call you with a problem.\n\n2. **You wait** (Promise is 'pending') - The pizza is being made. You don't have it yet, but you have a promise.\n\n3. **Two possible outcomes**:\n   - **Fulfilled (Resolved)**: Pizza arrives! You eat it (the 'then' callback runs)\n   - **Rejected**: Restaurant calls - they're out of ingredients (the 'catch' callback runs)\n\nA Promise is JavaScript's way of saying: 'I'll get you a result eventually. Here's a guarantee (promise) that I'll let you know when it's done, whether it succeeds or fails.'",
      "codeExample": "// Creating a Promise\nlet myPromise = new Promise((resolve, reject) => {\n  // Simulating async operation\n  let success = true;\n  \n  setTimeout(() => {\n    if (success) {\n      resolve('Operation successful!');  // Fulfilled\n    } else {\n      reject('Operation failed!');  // Rejected\n    }\n  }, 1000);\n});\n\n// Using a Promise\nmyPromise\n  .then((result) => {\n    console.log('Success:', result);\n  })\n  .catch((error) => {\n    console.log('Error:', error);\n  });\n\n// Practical example: Fetching data\nfunction fetchUserData(userId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId > 0) {\n        resolve({ id: userId, name: 'Alice' });\n      } else {\n        reject('Invalid user ID');\n      }\n    }, 1000);\n  });\n}\n\nfetchUserData(1)\n  .then((user) => {\n    console.log('User:', user.name);\n  })\n  .catch((error) => {\n    console.log('Error:', error);\n  });\n\n// Chaining Promises\nfetchUserData(1)\n  .then((user) => {\n    console.log('Got user:', user.name);\n    return fetchUserPosts(user.id);  // Returns another promise\n  })\n  .then((posts) => {\n    console.log('Got posts:', posts);\n  })\n  .catch((error) => {\n    console.log('Error:', error);\n  });\n\n// Promise.all - Wait for multiple promises\nlet promise1 = fetchUserData(1);\nlet promise2 = fetchUserData(2);\nlet promise3 = fetchUserData(3);\n\nPromise.all([promise1, promise2, promise3])\n  .then((results) => {\n    console.log('All users:', results);\n  })\n  .catch((error) => {\n    console.log('At least one failed:', error);\n  });\n\n// Promise.race - First one to finish\nPromise.race([promise1, promise2, promise3])\n  .then((result) => {\n    console.log('First result:', result);\n  });\n\n// Promise.withResolvers() - ES2024 new feature!\nlet { promise, resolve, reject } = Promise.withResolvers();\n\n// Can resolve/reject from anywhere\nsetTimeout(() => resolve('Done!'), 1000);\n\npromise.then(result => console.log(result));",
      "syntaxBreakdown": "Promise syntax:\n\n**Creating a Promise:**\n\nlet promise = new Promise((resolve, reject) => {\n                           │        │\n                           │        └─ Call when operation fails\n                           └────────── Call when operation succeeds\n  // Do async work\n  if (success) {\n    resolve(successValue);\n  } else {\n    reject(errorValue);\n  }\n});\n\n**Using a Promise:**\n\npromise\n  .then((result) => {\n    // Runs if promise resolves (success)\n    console.log(result);\n  })\n  .catch((error) => {\n    // Runs if promise rejects (failure)\n    console.log(error);\n  })\n  .finally(() => {\n    // Always runs (success or failure)\n    console.log('Done');\n  });\n\n**Promise States:**\n\n1. Pending - Initial state, not yet resolved or rejected\n2. Fulfilled - Operation completed successfully (resolve called)\n3. Rejected - Operation failed (reject called)\n\nOnce settled (fulfilled or rejected), state can't change!\n\n**Promise Chaining:**\n\nfetch('/api/user')\n  .then(response => response.json())  // Parse JSON\n  .then(user => {\n    console.log('User:', user);\n    return fetch('/api/posts/' + user.id);  // Next request\n  })\n  .then(response => response.json())\n  .then(posts => {\n    console.log('Posts:', posts);\n  })\n  .catch(error => {\n    console.log('Error anywhere in chain:', error);\n  });\n\n**Promise Utilities:**\n\n1. Promise.all([p1, p2, p3])\n   - Waits for ALL to resolve\n   - Rejects if ANY rejects\n   - Returns array of results\n\n2. Promise.race([p1, p2, p3])\n   - Returns when FIRST settles (resolve or reject)\n\n3. Promise.allSettled([p1, p2, p3])\n   - Waits for ALL to settle\n   - Never rejects\n   - Returns array of {status, value/reason}\n\n4. Promise.any([p1, p2, p3])\n   - Returns when FIRST resolves\n   - Rejects only if ALL reject\n\n5. Promise.withResolvers() - ES2024!\n   - Returns {promise, resolve, reject}\n   - Useful when you need to resolve/reject from outside\n\n**Error Handling:**\n\n// Catch errors\npromise.catch(error => console.log(error));\n\n// Or use second argument to then\npromise.then(\n  result => console.log(result),\n  error => console.log(error)\n);",
      "challenge": {
        "instructions": "Create a function that simulates a dice roll:\n\nfunction rollDice() {\n  // Returns a promise that resolves after 1 second\n  // Resolves with a random number 1-6\n}\n\nUse it like:\nrollDice()\n  .then(result => console.log('Rolled:', result));\n\nHint: Use Math.floor(Math.random() * 6) + 1 for random 1-6",
        "starterCode": "function rollDice() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      // YOUR CODE: Generate random number 1-6 and resolve with it\n    }, 1000);\n  });\n}\n\n// Test it\nrollDice()\n  .then(result => {\n    console.log('You rolled:', result);\n  });",
        "testCases": [
          {
            "description": "Returns a number",
            "input": "function rollDice() { return Promise.resolve(4); } rollDice().then(result => console.log(result));",
            "expectedOutput": "4"
          }
        ],
        "hint": "let roll = Math.floor(Math.random() * 6) + 1; resolve(roll);"
      },
      "solution": "function rollDice() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      let roll = Math.floor(Math.random() * 6) + 1;\n      resolve(roll);\n    }, 1000);\n  });\n}\n\nrollDice()\n  .then(result => {\n    console.log('You rolled:', result);\n  });",
      "commonStickingPoints": "Common mistakes:\n\n1. Forgetting to return a promise from a function:\n   function getData() {\n     new Promise((resolve) => { ... });  // WRONG - not returned!\n   }\n   \n   function getData() {\n     return new Promise((resolve) => { ... });  // CORRECT\n   }\n\n2. Not returning in .then() for chaining:\n   promise\n     .then(data => {\n       processData(data);  // Returns undefined!\n     })\n     .then(result => {\n       console.log(result);  // undefined\n     });\n   \n   Must return:\n   .then(data => {\n     return processData(data);\n   })\n\n3. Calling resolve/reject multiple times:\n   new Promise((resolve) => {\n     resolve('first');\n     resolve('second');  // Ignored!\n   });\n   // Only first resolve/reject counts\n\n4. Mixing callbacks and promises:\n   // Don't do this:\n   getData(function(result) {\n     // Old callback style mixed with promises\n   });\n   \n   // Use promises consistently\n\n5. Not catching errors:\n   fetch('/api/data')\n     .then(response => response.json());\n   // If error occurs, it's unhandled!\n   \n   Always add .catch():\n   fetch('/api/data')\n     .then(response => response.json())\n     .catch(error => console.log(error));"
    },
    {
      "id": "8.3",
      "title": "The Modern, Clean Way (async and await)",
      "conceptAnalogy": "Promises are like getting a tracking number for your package:\n\n**Promises (.then)**: You keep checking the tracking number and saying 'THEN when it arrives, THEN I'll open it, THEN I'll use it, THEN I'll write a review...'\n\n**async/await**: You just wait at the door for the package to arrive, open it when it comes, use it, write review - one step at a time, in order. More natural!\n\nasync/await is syntactic sugar over Promises. It makes asynchronous code LOOK and READ like synchronous code, while still being non-blocking. It's the modern, preferred way to handle async operations.",
      "codeExample": "// OLD WAY: Promises with .then()\nfunction getUser() {\n  fetchUser(1)\n    .then(user => {\n      console.log('User:', user);\n      return fetchPosts(user.id);\n    })\n    .then(posts => {\n      console.log('Posts:', posts);\n    })\n    .catch(error => {\n      console.log('Error:', error);\n    });\n}\n\n// NEW WAY: async/await (same thing, cleaner!)\nasync function getUser() {\n  try {\n    let user = await fetchUser(1);\n    console.log('User:', user);\n    \n    let posts = await fetchPosts(user.id);\n    console.log('Posts:', posts);\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}\n\n// async function returns a Promise\nasync function getData() {\n  return 'Hello';  // Automatically wrapped in Promise.resolve()\n}\n\ngetData().then(result => console.log(result));  // Hello\n\n// await pauses until Promise resolves\nasync function example() {\n  console.log('Start');\n  \n  let result = await someAsyncOperation();  // Waits here\n  console.log('Result:', result);  // Runs after promise resolves\n  \n  console.log('End');\n}\n\n// Multiple awaits in sequence\nasync function sequential() {\n  let user = await fetchUser(1);  // Wait for this\n  let posts = await fetchPosts(user.id);  // Then wait for this\n  let comments = await fetchComments(posts[0].id);  // Then wait for this\n  return { user, posts, comments };\n}\n\n// Multiple awaits in parallel (faster!)\nasync function parallel() {\n  // Start all at once\n  let userPromise = fetchUser(1);\n  let postsPromise = fetchPosts(1);\n  let commentsPromise = fetchComments(1);\n  \n  // Wait for all to finish\n  let user = await userPromise;\n  let posts = await postsPromise;\n  let comments = await commentsPromise;\n  \n  return { user, posts, comments };\n}\n\n// Or use Promise.all\nasync function parallelAll() {\n  let [user, posts, comments] = await Promise.all([\n    fetchUser(1),\n    fetchPosts(1),\n    fetchComments(1)\n  ]);\n  return { user, posts, comments };\n}\n\n// Error handling\nasync function withErrorHandling() {\n  try {\n    let data = await riskyOperation();\n    return data;\n  } catch (error) {\n    console.log('Caught error:', error);\n    return null;\n  }\n}\n\n// Can only use await inside async function\n// This is WRONG:\nfunction normal() {\n  let result = await fetchData();  // ERROR!\n}\n\n// This is CORRECT:\nasync function async() {\n  let result = await fetchData();  // Works!\n}\n\n// Top-level await (ES2022 - in modules only)\nawait fetchData();  // Now works at module top level!",
      "syntaxBreakdown": "async/await syntax:\n\n**async function:**\n\nasync function functionName() {\n│     │\n│     └─ Makes function asynchronous\n└─────── async keyword required\n  // Can use 'await' inside\n}\n\n// async function automatically returns a Promise\nasync function getName() {\n  return 'Alice';  // Becomes Promise.resolve('Alice')\n}\n\n// These are equivalent:\nasync function a() { return 'Hi'; }\nfunction b() { return Promise.resolve('Hi'); }\n\n**await keyword:**\n\nlet result = await promise;\n│            │     │\n│            │     └─ A Promise\n│            └─────── await keyword (pauses until resolved)\n└──────────────────── Result of the promise\n\nRules for await:\n1. Can ONLY be used inside async functions (or module top-level)\n2. Pauses function execution until Promise resolves\n3. Returns the resolved value\n4. Throws if Promise rejects (use try/catch)\n\n**Error Handling:**\n\n// Promises:\npromise\n  .then(result => { })\n  .catch(error => { });\n\n// async/await:\ntry {\n  let result = await promise;\n} catch (error) {\n  // Handle error\n}\n\n**Sequential vs Parallel:**\n\n// Sequential (one after another - SLOW)\nasync function sequential() {\n  let a = await fetchA();  // Wait 1 second\n  let b = await fetchB();  // Wait 1 second\n  // Total: 2 seconds\n}\n\n// Parallel (at same time - FAST)\nasync function parallel() {\n  let [a, b] = await Promise.all([\n    fetchA(),  // Both start at same time\n    fetchB()\n  ]);\n  // Total: 1 second (whichever is slower)\n}\n\n**Common Patterns:**\n\n1. Simple fetch:\n   async function getData() {\n     let response = await fetch('/api/data');\n     let data = await response.json();\n     return data;\n   }\n\n2. With error handling:\n   async function getData() {\n     try {\n       let response = await fetch('/api/data');\n       if (!response.ok) throw new Error('Failed');\n       return await response.json();\n     } catch (error) {\n       console.log('Error:', error);\n       return null;\n     }\n   }\n\n3. Multiple parallel requests:\n   async function getAll() {\n     let [users, posts, comments] = await Promise.all([\n       fetch('/api/users').then(r => r.json()),\n       fetch('/api/posts').then(r => r.json()),\n       fetch('/api/comments').then(r => r.json())\n     ]);\n     return { users, posts, comments };\n   }",
      "challenge": {
        "instructions": "Convert this Promise code to async/await:\n\nfunction loadUserData() {\n  return fetchUser(1)\n    .then(user => {\n      console.log('User:', user.name);\n      return fetchPosts(user.id);\n    })\n    .then(posts => {\n      console.log('Posts:', posts.length);\n      return posts;\n    })\n    .catch(error => {\n      console.log('Error:', error);\n    });\n}\n\nRewrite as async/await with try/catch.",
        "starterCode": "async function loadUserData() {\n  // YOUR CODE HERE using async/await\n}",
        "testCases": [
          {
            "description": "Uses async/await correctly",
            "input": "async function loadUserData() { try { let user = {name: 'Alice', id: 1}; console.log('User:', user.name); let posts = [{}, {}]; console.log('Posts:', posts.length); return posts; } catch (error) { console.log('Error:', error); } } loadUserData();",
            "expectedOutput": ""
          }
        ],
        "hint": "async function with try/catch, await fetchUser, await fetchPosts"
      },
      "solution": "async function loadUserData() {\n  try {\n    let user = await fetchUser(1);\n    console.log('User:', user.name);\n    \n    let posts = await fetchPosts(user.id);\n    console.log('Posts:', posts.length);\n    \n    return posts;\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}",
      "commonStickingPoints": "Common mistakes:\n\n1. Forgetting 'async' keyword:\n   function getData() {\n     let result = await fetch();  // ERROR!\n   }\n   \n   Must be:\n   async function getData() {\n     let result = await fetch();\n   }\n\n2. Not awaiting Promises:\n   async function getData() {\n     let data = fetchData();  // data is a Promise!\n     console.log(data.name);  // undefined!\n   }\n   \n   Must await:\n   async function getData() {\n     let data = await fetchData();\n     console.log(data.name);  // Works!\n   }\n\n3. Sequential when could be parallel:\n   // SLOW (3 seconds total):\n   async function slow() {\n     let a = await fetchA();  // 1s\n     let b = await fetchB();  // 1s\n     let c = await fetchC();  // 1s\n   }\n   \n   // FAST (1 second total):\n   async function fast() {\n     let [a, b, c] = await Promise.all([\n       fetchA(),\n       fetchB(),\n       fetchC()\n     ]);  // All at once!\n   }\n\n4. Not handling errors:\n   async function getData() {\n     let data = await fetch('/api/data');  // What if it fails?\n   }\n   \n   Always try/catch:\n   async function getData() {\n     try {\n       let data = await fetch('/api/data');\n     } catch (error) {\n       console.log('Error:', error);\n     }\n   }\n\n5. Mixing async/await with .then():\n   // Pick one style, don't mix:\n   async function mixed() {\n     let data = await fetchData();\n     data.then(result => { });  // Confusing!\n   }\n   \n   // Use async/await consistently:\n   async function clean() {\n     let data = await fetchData();\n     let result = await processData(data);\n   }"
    },
    {
      "id": "8.4",
      "title": "Ordering from the Menu (Using fetch() to Get API Data)",
      "conceptAnalogy": "Using an API is like ordering from a restaurant:\n\n1. **You look at the menu** (API documentation) - What dishes (endpoints) are available?\n2. **You place an order** (fetch request) - 'I'll have the user data for ID 123, please'\n3. **Kitchen prepares it** (server processes) - Takes time, you wait\n4. **Server brings your food** (response) - Here's your data!\n5. **You eat it** (use the data) - Display on your webpage\n\nAPIs (Application Programming Interfaces) are how websites talk to servers. fetch() is JavaScript's built-in way to request data from APIs. It returns a Promise, so we use async/await!",
      "codeExample": "// Basic fetch - GET request\nasync function getUsers() {\n  try {\n    let response = await fetch('https://jsonplaceholder.typicode.com/users');\n    \n    // Check if request was successful\n    if (!response.ok) {\n      throw new Error('Request failed: ' + response.status);\n    }\n    \n    // Parse JSON response\n    let users = await response.json();\n    console.log(users);\n    \n    return users;\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}\n\n// Fetch with options - POST request\nasync function createUser(userData) {\n  try {\n    let response = await fetch('https://api.example.com/users', {\n      method: 'POST',  // HTTP method\n      headers: {\n        'Content-Type': 'application/json'  // Sending JSON\n      },\n      body: JSON.stringify(userData)  // Convert object to JSON string\n    });\n    \n    let newUser = await response.json();\n    console.log('Created:', newUser);\n    return newUser;\n  } catch (error) {\n    console.log('Error:', error);\n  }\n}\n\n// Example: Create user\ncreateUser({\n  name: 'Alice',\n  email: 'alice@example.com',\n  age: 25\n});\n\n// UPDATE - PUT/PATCH request\nasync function updateUser(userId, updates) {\n  let response = await fetch(`https://api.example.com/users/${userId}`, {\n    method: 'PATCH',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(updates)\n  });\n  \n  return await response.json();\n}\n\n// DELETE request\nasync function deleteUser(userId) {\n  let response = await fetch(`https://api.example.com/users/${userId}`, {\n    method: 'DELETE'\n  });\n  \n  if (response.ok) {\n    console.log('User deleted');\n  }\n}\n\n// Practical example: Display users on page\nasync function displayUsers() {\n  try {\n    let response = await fetch('https://jsonplaceholder.typicode.com/users');\n    let users = await response.json();\n    \n    let userList = document.querySelector('#userList');\n    \n    users.forEach(user => {\n      let li = document.createElement('li');\n      li.textContent = user.name;\n      userList.appendChild(li);\n    });\n  } catch (error) {\n    console.log('Failed to load users:', error);\n  }\n}\n\n// With loading state\nasync function fetchWithLoading() {\n  let loadingEl = document.querySelector('#loading');\n  let contentEl = document.querySelector('#content');\n  \n  try {\n    loadingEl.style.display = 'block';  // Show loading\n    \n    let response = await fetch('/api/data');\n    let data = await response.json();\n    \n    contentEl.textContent = JSON.stringify(data);\n  } catch (error) {\n    contentEl.textContent = 'Error loading data';\n  } finally {\n    loadingEl.style.display = 'none';  // Hide loading\n  }\n}",
      "syntaxBreakdown": "fetch() syntax:\n\n**Basic GET request:**\n\nlet response = await fetch(url);\nlet data = await response.json();\n\n**With options:**\n\nlet response = await fetch(url, {\n  method: 'POST',  // GET, POST, PUT, PATCH, DELETE\n  headers: {       // Request headers\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer token123'\n  },\n  body: JSON.stringify(data)  // Request body (POST/PUT/PATCH)\n});\n\n**Response object properties:**\n\nresponse.ok          // true if status 200-299\nresponse.status      // HTTP status code (200, 404, 500, etc.)\nresponse.statusText  // Status message ('OK', 'Not Found', etc.)\nresponse.headers     // Response headers\nresponse.json()      // Parse as JSON (returns Promise)\nresponse.text()      // Get as text (returns Promise)\nresponse.blob()      // Get as binary (for images, files)\n\n**HTTP Methods (CRUD):**\n\nGET    - Read data (default)\nPOST   - Create new resource\nPUT    - Replace entire resource\nPATCH  - Update part of resource\nDELETE - Delete resource\n\n**Complete pattern:**\n\nasync function apiCall() {\n  try {\n    // 1. Make request\n    let response = await fetch(url, options);\n    \n    // 2. Check if successful\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    \n    // 3. Parse response\n    let data = await response.json();\n    \n    // 4. Use data\n    return data;\n    \n  } catch (error) {\n    // 5. Handle errors\n    console.error('Fetch error:', error);\n    throw error;  // Re-throw or handle\n  }\n}\n\n**Common Headers:**\n\n'Content-Type': 'application/json'  // Sending JSON\n'Authorization': 'Bearer token'      // Authentication\n'Accept': 'application/json'         // Expecting JSON\n\n**Sending Data:**\n\n// Object to JSON string\nlet user = { name: 'Alice', age: 25 };\nlet jsonString = JSON.stringify(user);\n\n// Send in fetch\nbody: JSON.stringify(user)\n\n// Parsing response\nlet data = await response.json();  // JSON string to object\n\n**Error Handling:**\n\n// Network errors (no connection)\ntry {\n  let response = await fetch(url);\n} catch (error) {\n  console.log('Network error:', error);\n}\n\n// HTTP errors (404, 500, etc.)\nif (!response.ok) {\n  throw new Error('HTTP ' + response.status);\n}\n\n// JSON parsing errors\ntry {\n  let data = await response.json();\n} catch (error) {\n  console.log('Invalid JSON:', error);\n}",
      "challenge": {
        "instructions": "Create a function that:\n1. Fetches a random user from: https://randomuser.me/api/\n2. Extracts the name (results[0].name.first)\n3. Returns the name\n4. Handles errors appropriately\n\nHint: The API returns { results: [{name: {first: 'John', last: 'Doe'}}] }",
        "starterCode": "async function getRandomUser() {\n  try {\n    // YOUR CODE HERE\n    // 1. fetch from URL\n    // 2. Check response.ok\n    // 3. Parse JSON\n    // 4. Extract and return name\n  } catch (error) {\n    console.log('Error:', error);\n    return null;\n  }\n}\n\n// Test it\ngetRandomUser().then(name => console.log('Random user:', name));",
        "testCases": [
          {
            "description": "Fetches and parses data",
            "input": "async function getRandomUser() { let data = {results: [{name: {first: 'John'}}]}; return data.results[0].name.first; } getRandomUser().then(name => console.log(name));",
            "expectedOutput": "John"
          }
        ],
        "hint": "let response = await fetch(url); let data = await response.json(); return data.results[0].name.first;"
      },
      "solution": "async function getRandomUser() {\n  try {\n    let response = await fetch('https://randomuser.me/api/');\n    \n    if (!response.ok) {\n      throw new Error('Request failed');\n    }\n    \n    let data = await response.json();\n    let firstName = data.results[0].name.first;\n    \n    return firstName;\n  } catch (error) {\n    console.log('Error:', error);\n    return null;\n  }\n}\n\ngetRandomUser().then(name => console.log('Random user:', name));",
      "commonStickingPoints": "Common mistakes:\n\n1. Not awaiting response.json():\n   let response = await fetch(url);\n   let data = response.json();  // WRONG - data is a Promise!\n   \n   Must await:\n   let data = await response.json();\n\n2. Forgetting to check response.ok:\n   let response = await fetch(url);\n   let data = await response.json();  // Might fail!\n   \n   Always check:\n   if (!response.ok) {\n     throw new Error('HTTP error');\n   }\n\n3. Not stringifying request body:\n   fetch(url, {\n     body: {name: 'Alice'}  // WRONG - object!\n   });\n   \n   Must stringify:\n   fetch(url, {\n     body: JSON.stringify({name: 'Alice'})\n   });\n\n4. CORS errors (Cross-Origin Request Blocked):\n   // Can't fetch from different domain without server permission\n   fetch('https://other-site.com/api')  // Might be blocked\n   // Server must send CORS headers to allow\n\n5. Forgetting Content-Type header:\n   fetch(url, {\n     method: 'POST',\n     body: JSON.stringify(data)  // Server might not parse it!\n   });\n   \n   Need header:\n   fetch(url, {\n     method: 'POST',\n     headers: {\n       'Content-Type': 'application/json'\n     },\n     body: JSON.stringify(data)\n   });\n\n6. Not handling network errors:\n   // If internet is down, fetch throws\n   try {\n     await fetch(url);\n   } catch (error) {\n     // Handle network error\n   }"
    }
  ]
}
